Combining OpenWhisk’s function-as-a-service approach with the ubiquity and strength of Python 3 provides developers exciting new opportunities. Python is a clean, expressive programming language which has seen a substantial surge in popularity because of its readability and because it so easily “fits into the heads” of many developers.

Python 3 was first released in 2008 but the Python community has taken a long time to migrate because the new version broke backward compatibility with Python 2. The transition to Python 3 is now largely complete with popular packages such as the Data Science platform IPython and the web framework Django requiring Python 3 and dropping support for Python 2. Python 3 deliberately broke backward compatibility in order to fix several fundamental flaws in earlier versions of the language.

One key flaw that was evident in our effort to transition OpenWhisk was that Python 2 did not have solid support for Unicode and often allowed programmers to dangerously blur the lines between bytes and strings. Python 3 (and other OpenWhisk languages that were introduced after it) treat all strings as Unicode and require explicit conversion to move between bytes and strings. This enables the creation of apps supporting multi-byte alphabets around the globe while eliminating a whole class of subtle bugs.

One of the other reasons that these popular tools want to make the shift is because they want to leverage asynchronous I/O. Much as we have seen in languages like Go and JavaScript, asynchronous operations simplify the programming model for delivering concurrency (not parallelism). Python already has built-in modules for threading and multiprocessing but their use often creates race conditions which can be difficult to debug. There is now broad understanding that programming languages that support keywords such as async and await make it easier for developers to consistently deliver concurrent code with fewer bugs.

As an OpenWhisk developer, you should be excited to adopt Python 3’s asyncio because from the time that they get triggered, your OpenWhisk actions have just one minute to live. Asyncio enables your code to maximize its use of the CPU by reducing the negative effects of blocking I/O. For instance, if your OpenWhisk action needs to make requests to multiple API end points, those read and write operations are no longer blocking so your code immediately gets the processor back to execute other tasks. If your action needs to open webpages, or files from internet sites, do encoding/decoding, compression/decompression, all of these tasks can be set up to execute asynchronously. You can leverage this power to pack a lot into one minute.

OpenWhisk currently supports both Python 2.7.12 and Python 3.6.1 actions and the runtime continues to include third party modules to bring even more power to your Python actions. If you do not see your favorite module in that list, it might be possible for you to use a virtualenv to package it up with your action code for submission to OpenWhisk. We will explore how to do this in a future post. There are many good sources of information on migrating your code to Python 3 but one of the most helpful is http://python-future.org/compatible_idioms.html. We encourage you to get started today because, like IPython and Django, we would like to drop support for legacy Python and put all of our focus on the present and future of the language.

Let’s try upgrading an action from to :

If you are having trouble completing your migration, please reach out on Slack or GitHub.|||

Combining OpenWhisk’s function-as-a-service approach with the ubiquity and strength of Python 3 provides developers exciting new opportunities. Python is a clean, expressive programming language…