I recently stumbled upon exercism.io. It’s an open source collaborative programming practice site by Katrina Owen of JumpstartLab that grew out of the daily warmup exercises for their gSchool students (Introducing exercism.io). The problems are generally simple, where solutions are fewer than 100 lines of code, usually around 20-30. Unlike the typical Euler problem, you won’t need to rely on much training in mathematics (although it certainly can help!).

At first I thought it would be a fun way to learn a little more about Elixir and Clojure, but I quickly came to the conclusion that what I really wanted was to practice Haskell… so I got to coding and sent a pull request (#562) after porting a handful of exercises. Katrina quickly merged the code and over the course of the next month I systematically ported all 54 exercises.

While I did get in a lot of great practice writing all of the code, the true value of exercism.io is the collaboration. Once you’ve submitted code for an exercise, anyone else who has completed the exercise can review your code and submit “nits”. Nits are roughly equivalent to code review, although many reviewers will go above and beyond to help the submitter better understand the language and/or the problem so that they can arrive at an elegant solution.

I also learned how common it is for new Haskell developers to have an incomplete mental model for how Haskell’s non-strict evaluation works. This commonly manifests as a non-strict fold with a spine-strict data structure in the accumulator, such as building an Int or Map from a list. This certainly isn’t a new discovery (An insufficiently lazy map), and I wasn’t very surprised. It took me a while to wrap my head around it too since the strategies for writing efficient code in Haskell end up being so different from strict functional programming languages (such as Erlang, Clojure, etc.). The best reference I’ve seen on Haskell’s evaluation model is the Lazy Evaluation and Weak Head Normal Form section of Parallel and Concurrent Programming in Haskell. The whole book is fantastic, but that chapter is a must-read for anyone interested in Haskell. You don’t need to be an expert to read it, some basic background (such as reading Learn You a Haskell for Great Good!) is more than sufficient.

If you’re learning Haskell or just looking for a little practice, I highly recommend giving exercism.io a try. I plan to continue spending some time every day to help nitpick, and would be happy to help get you up to speed.|||

