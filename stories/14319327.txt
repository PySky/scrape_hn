Founded in 2010, Kaggle is a Data Science platform where users can share, collaborate, and compete. One key feature of Kaggle is “Competitions”, which offers users the ability to practice on real world data and to test their skills with, and against, an international community.

This guide will teach you how to approach and enter a Kaggle competition, including exploring the data, creating and engineering features, building models, and submitting predictions. We’ll use Python 3 and Jupyter Notebook.

We need to acquire the data for the competition. The descriptions of the features and some other helpful information are contained in a file with an obvious name, .

Download the data and save it into a folder where you’ll keep everything you need for the competition.

We will first look at the data. After we’ve trained a model, we’ll make predictions using the data.

First, import Pandas, a fantastic library for working with data in Python. Next we’ll import Numpy.

We can use Pandas to read in csv files. The method creates a DataFrame from a csv file.

Let’s check out the size of the data.

We see that has only 80 columns, while has 81. This is due to, of course, the fact that the test data do not include the final sale price information!

Next, we’ll look at a few rows using the method.

We should have the available in our folder for the competition. You can also find it here.

Here’s a brief version of what you’ll find in the data description file:

And so on.

The competition challenges you to predict the final price of each home. At this point, we should start to think about what we know about housing prices, Ames, Iowa, and what we might expect to see in this dataset.

Looking at the data, we see features we expected, like (the year the home was last sold) and . Others we might not have anticipated, such as (the slope of the land the home is built upon) and (the materials used to construct the roof). Later, we’ll have to make decisions about how we’ll approach these and other features.

We want to do some plotting during the exploration stage of our project, and we’ll need to import that functionality into our environment as well. Plotting allows us to visualize the distribution of the data, check for outliers, and see other patterns that we might miss otherwise. We’ll use Matplotlib, a popular visualization library.

The challenge is to predict the final sale price of the homes. This information is stored in the column. The value we are trying to predict is often called the target variable.

We can use to get more information.

gives you more information about any series. displays the total number of rows in the series. For numerical data, also gives the , , and values as well.

The average sale price of a house in our dataset is close to , with most of the values falling within the to range.

Next, we’ll check for skewness, which is a measure of the shape of the distribution of values.

When performing regression, sometimes it makes sense to log-transform the target variable when it is skewed. One reason for this is to improve the linearity of the data. Although the justification is beyond the scope of this tutorial, more information can be found here.

Importantly, the predictions generated by the final model will also be log-transformed, so we’ll need to convert these predictions back to their original form later.

will transform the variable, and will reverse the transformation.

We use to plot a histogram of . Notice that the distribution has a longer tail on the right. The distribution is positively skewed.

Now we use to transform and calculate the skewness a second time, as well as re-plot the data. A value closer to 0 means that we have improved the skewness of the data. We can see visually that the data will more resembles a normal distribution.

Now that we’ve transformed the target variable, let’s consider our features. First, we’ll check out the numerical features and make some plots. The method will return a subset of columns matching the specified data types.

The method displays the correlation (or relationship) between the columns. We’ll examine the correlations between the features and the target.

The first five features are the most positively correlated with , while the next five are the most negatively correlated.

Let’s dig deeper on . We can use the method to get the unique values.

The data are integer values in the interval 1 to 10 inclusive.

We can create a pivot table to further investigate the relationship between and . The Pandas docs demonstrate how to accomplish this task. We set and . We chose to look at the here.

To help us visualize this pivot table more easily, we can create a bar plot using the method.

Notice that the median sales price strictly increases as Overall Quality increases.

Next, let’s use to generate some scatter plots and visualize the relationship between the Ground Living Area and .

At first glance, we see that increases in living area correspond to increases in price. We will do the same for .

Notice that there are many homes with for , indicating that they don’t have a garage. We’ll transform other features later to reflect this assumption. There are a few outliers as well. Outliers can affect a regression model by pulling our estimated regression line further away from the true population regression line. So, we’ll remove those observations from our data. Removing outliers is an art and a science. There are many techniques for dealing with outliers.

We will create a new dataframe with some outliers removed.

Let’s take another look.

Next, we’ll examine the null or missing values.

We will create a DataFrame to view the top null columns. Chaining together the methods, we return a Series of the counts of the null values in each column.

The documentation can help us understand the missing values. In the case of , the column refers to Pool Quality. Pool quality is when is , or there is no pool. We can find a similar relationship between many of the Garage-related columns.

Let’s take a look at one of the other columns, . We’ll use the method to return a list of the unique values.

We can use the documentation to find out what these values indicate:

These values describe whether or not the house has a shed over 100 sqft, a second garage, and so on. We might want to use this information later. It’s important to gather domain knowledge in order to make the best decisions when dealing with missing data.

Let’s now consider the non-numeric features.

The column indicates the count of non-null observations, while counts the number of unique values. is the most commonly occurring value, with the frequency of the top value shown by .

For many of these features, we might want to use one-hot encoding to make use of the information for modeling. One-hot encoding is a technique which will transform categorical data into numbers so the model can understand whether or not a particular observation falls into one category or another.

When transforming features, it’s important to remember that any transformations that you’ve applied to the training data before fitting the model must be applied to the test data.

Our model expects that the shape of the features from the set match those from the set. This means that any feature engineering that occurred while working on the data should be applied again on the set.

To demonstrate how this works, consider the data, which indicates whether there is or road access to the property.

In the column, the unique values are and , which describe the type of road access to the property. In the training set, only 5 homes have gravel access. Our model needs numerical data, so we will use one-hot encoding to transform the data into a Boolean column.

We create a new column called . The method will handle this for us.

As mentioned earlier, we need to do this on both the and data.

The values agree. We’ve engineered our first feature! Feature Engineering is the process of making features of the data suitable for use in machine learning and modelling. When we encoded the feature into a column of Boolean values, we engineered a feature.

Let’s try engineering another feature. We’ll look at by constructing and plotting a pivot table, as we did above for .

Notice that has a significantly higher Median Sale Price than the others. We will encode this as a new feature. We select all of the houses where is equal to and assign the value , otherwise assign .

Follow a similar method that we used for above.

Let’s explore this new feature as a plot.

This looks great. You can continue to work with more features to improve the ultimate performance of your model.

Before we prepare the data for modeling, we need to deal with the missing data. We’ll the missing values with an average value and then assign the results to . This is a method of interpolation. The method makes this simple.

This is a quick and simple method of dealing with missing values, and might not lead to the best performance of the model on new data. Handling missing values is an important part of the modeling process, where creativity and insight can make a big difference. This is another area where you can extend on this tutorial.

Check if the all of the columns have 0 null values.

Let’s perform the final steps to prepare our data for modeling. We’ll separate the features and the target variable for modeling. We will assign the features to and the target variable to . We use as explained above to transform the y variable for the model. tells pandas which columns we want to exclude. We won’t include for obvious reasons, and is just an index with no relationship to .

Let’s partition the data and start modeling. We will use the function from scikit-learn to create a training set and a hold-out set. Partitioning the data in this way allows us to evaluate how our model might perform on data that it has never seen before. If we train the model on all of the test data, it will be difficult to tell if overfitting has taken place.

The first parameter value denotes the set of predictor data, and is the target variable. Next, we set . This provides for reproducible results, since sci-kit learn’s will randomly partition the data. The parameter tells the function what proportion of the data should be in the partition. In this example, about 33% of the data is devoted to the hold-out set.

We will first create a Linear Regression model. First, we instantiate the model.

Next, we need to fit the model. First instantiate the model and next fit the model. Model fitting is a procedure that varies for different types of models. Put simply, we are estimating the relationship between our predictors and the target variable so we can make accurate predictions on new data.

We fit the model using and , and we’ll score with and . The method will fit the linear regression on the features and target variable that we pass.

Now, we want to evaluate the performance of the model. Each competition might evaluate the submissions differently. In this competition, Kaggle will evaluate our submission using root-mean-squared-error (RMSE). We’ll also look at The r-squared value. The r-squared value is a measure of how close the data are to the fitted regression line. It takes a value between 0 and 1, 1 meaning that all of the variance in the target is explained by the data. In general, a higher r-squared value means a better fit.

The method returns the r-squared value by default.

This means that our features explain approximately 89% of the variance in our target variable. Follow the link above to learn more.

Next, we’ll consider . To do so, use the model we have built to make predictions on the test data set.

The method will return a list of predictions given a set of predictors. Use after fitting the model.

The function takes two arrays and calculates the .

Interpreting this value is somewhat more intuitive that the r-squared value. The RMSE measures the distance between our predicted values and actual values.

We can view this relationship graphically with a scatter plot.

If our predicted values were identical to the actual values, this graph would be the straight line because each predicted value would be equal to each actual value .

We’ll next try using Ridge Regularization to decrease the influence of less important features. Ridge Regularization is a process which shrinks the regression coefficients of less important features.

We’ll once again instantiate the model. The Ridge Regularization model takes a parameter, , which controls the strength of the regularization.

We’ll experiment by looping through a few different values of alpha, and see how this changes our results.

These models perform almost identically to the first model. In our case, adjusting the alpha did not substantially improve our model. As you add more features, regularization can be helpful. Repeat this step after you’ve added more features.

We’ll need to create a that contains the predicted for each observation in the dataset.

We’ll log in to our Kaggle account and go to the submission page to make a submission. We will use the to create a csv to submit. The first column must the contain the ID from the test data.

Now, select the features from the test data for the model as we did above.

Next, we generate our predictions.

Now we’ll transform the predictions to the correct form. Remember that to reverse we do . So we will apply to our predictions becasuse we have taken the logarithm previously.

Look at the difference.

Lets assign these predictions and check that everything looks good.

One we’re confident that we’ve got the data arranged in the proper format, we can export to a as Kaggle expects. We pass because Pandas otherwise would create a new index for us.

We’ve created a file called in our working directory that conforms to the correct format. Go to the submission page to make a submission.

We placed 1602 out of about 2400 competitors. Almost middle of the pack, not bad! Notice that our score here is , which is better than the score we observed on the test data. That’s a good result, but will not always be the case.

You can extend this tutorial and improve your results by:

We created a set of categorical features called that were not all included in the final model. Go back and try to include these features. There are other methods that might help with categorical data, notably the method. After working on these features, repeat the transformations for the test data and make another submission.

Working on models and participating in Kaggle competitions can be an iterative process – it’s important to experiment with new ideas, learn about the data, and test newer models and techniques.

With these tools, you can build upon your work and improve your results.|||

Get started with Kaggle competitions. Learn how to prepare your data, train a model and make a submission.