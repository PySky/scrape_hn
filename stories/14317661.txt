Now, the last and most important, reason why gitworkflow isn’t widely adopted: it’s hard to wrap your mind around it, or at least it was for me. Adam states:

In contrast, Gitworkflows actually has four such “important” branches, though of course only one of the four is “eternal”: maint, master, next, and pu. Exactly why do I need all of these branches and what the f*k is pu? The “Managing Branches” section of the gitworkflows(7) man page, and these sections of MaintNotes and maintain-git.txt, are all worth reading again. And again (they may make more sense after finishing this article).

Consider that, if we are maintaining releases of a project, we probably have different “versions” of it at varying levels of stability. A stable “release” (or “production”) version, a beta (or “testing”) version for ambitious users and testers which is somewhat stable, and an alpha (or “development”) version that contains all the latest goodies, but in which there is probably a bunch of broken stuff as well.

Not coincidentally, our gitworkflow branches master, next, and pu (proposed updates) correspond to these release/beta/alpha levels of stability respectively. The remaining branch maint is branched off of master at release points, and simply contains hot fixes to already released code.

Now that we understand the purpose of each “integration branch” in terms of stability, we combine this with the concept of “topic branches”. Topic branches themselves are non-controversial — both GitFlow and Adam recommend using them. Topic branches are where all the current work is being done — one branch per issue, bug, or feature, and there can be many topic branches undergoing development at once. In gitworkflow, however, topic branches are actually fundamental to the flow as opposed to just being a temporary place to develop code in isolation.

Topic branches always start from either maint or master. Branch from maint if the topic eventually needs merging to the current release represented by maint, or master if the topic is intended for a future release (not necessarily the next one). Note one caveat: if a new topic topic-b depends on code written on an earlier topic topic-a, then topic-b should still branch from maint or master, but topic-a should be merged into topic-b. This keeps topic-b logically separate from topic-a, but makes the dependency explicit.

Since topics branch from maint or master, they can also be merged into next and pu without any hassle at all — since both of those branches share a common ancestor with the topic in the form of a commit on master (or maint, which master always always includes). Most branch strategies wrongly assume that one can only merge into the same branch one forked from, but Git is smarter and more flexible than that.

Topic branches start out in an unstable state, and probably contain errors and unfinished work. However, this shouldn’t stop us from integrating our work with other work in progress to see what happens, both at merge time and at run time — this process is represented by our alpha-state code in the pu, or proposed updates, branch. Periodically pu is reset to the current master, and then all the topic branches are merged into it to identify merge issues, run tests, and to produce alpha-state build artifacts. Note the order of the merges does not really matter, but can be defined on a project or case-by-case basis. Performing the merges in a consistent order will best allow useful tools like to work correctly, and can be semi-automated via scripts.

Merging to pu is extremely useful for initial feedback on development work from product owners, functional testers, and keen users. GitFlow does not offer any inherent way to do this — CI has become shorthand for running tests on individual topic branches automatically, but at its core, it’s the capability to merge and test all current work in progress that is true CI and that gitworkflow enables.

Finally, note another useful attribute of gitworkflow: pu is well understood to be a throw-away branch that may be rebased at any time, and therefore no commits should generally be based on it. Therefore, despite past merges to pu, topics can still be interactively rebased as much as is necessary to produce a great, easily reviewable, and understandable series of commits, without worrying about other people having to “recover from upstream rebase” (an easy process but not one that should often be needed).

After a topic branch has undergone several cycles of refinement, code review, and testing, it may reach the point (in someone’s judgement) that it is good enough to be released to a beta (or user acceptance test) environment. At this point, in gitworkflow, the topic “graduates” to the next branch. Graduation simply consists of merging the topic to next with .

Now that the topic has graduated to next, it can be part of a beta, or acceptance release. So every topic on next can now undergo a second round of stabilization, which is exactly the purpose of a beta release / acceptance testing environment. However, note that with gitworkflow, we still have not committed (no pun intended!) to having this topic as part of our next release to production — it still has not been merged to master. This is similar in concept to GitFlow’s release branch, but far more flexible and powerful, since master has no dependencies on next whatsoever, nor is next ever merged wholesale into master (unlike the corresponding GitFlow branches develop and release).

What if topic branches continue to evolve with new commits after merging and testing on next? The branch is simply merged to next again, as is necessary. Optionally, these further changes can also undergo an extra stabilization period by merging them to pu first. Since next is an integration branch with a finite lifetime, repeated merges of topics to it do complicate it’s history, but only until the next rebuild of next (which may happen at the next release, but gitworkflow is flexible here). Irrelevant and distracting history here, and on pu, is eventually dropped and forgotten.

And lastly, once a topic is judged stable enough to release, the topic graduates again and is merged to master (or perhaps maint), again with to preserve the complete history of the topic branch.

A couple of topic branches merged to next, tested there as beta-releases, and then finally graduating to master for release could look something like this:

Note that in gitworkflow, unstable and stable development work is never mixed together on the same branch. In contrast, with GitFlow I have two choices: 1) I can test my topic in isolation on its own branch, or 2) I can merge it to develop for testing. Neither choice is appealing. The former doesn’t offer a true test of a topic’s stability when deployed together with other ongoing work, and the latter commits the topic to develop perhaps before it is stable.

For the same reason, GitFlow has no process-assisted way to identify in advance which topics may cause conflicts with other work in progress, so that the developers in question can coordinate efforts before that big final merge of their topic to develop. In short, in GitFlow there is always an unsolvable tension between the desire to keep development work clean and isolated on a topic branch, and integrating topic branches with other work by merging them to develop to make them visible and testable and to check for conflicts. Gitworkflow allows both goals to be achieved without sacrificing one for the other.|||

There are a few common branching and process models for distributed development with Git on larger teams and projects. GitFlow, created by Vincent Drieesen, is one such common branching model…