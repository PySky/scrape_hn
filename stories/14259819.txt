This describes the changes between v0.11.3 and v1.0.0. Notes for the 1.0 release canditates are here.

This is one big document. Everything's changed. Grab a coffee.

was originally a proof-of-concept, experimenting both with React and Scala.JS back in 2014. Once the concept was validated it immediately began being used in anger in a real-world project, and over the years this drove the discovery of additional required changes and features. These changes were usually implemented via hacks due a lack of initial design and discovered direction. Oft times how to solve certain problems was unclear and begat more experimentation which created more churn and mess. To be honest, I was also less experienced in Scala than I am today, and wrote code in a way that sometimes defied readability and easy comprehension when in a team: implicits everywhere, symbols and abbreviations all over the place (Haskell influence), etc.

In the end, the v0.x branch ended up being a codebase too design-constrained and near impossible to extend, hacks everywhere, littered with experiments both successful and failed.

It was time to give this library a proper, solid foundation. This time around, there was plenty of 20/20 hindsight and real-world project code to draw on to guide tough decisions. It still doesn't have everything imaginable, but it is infinitely more extensible now, meaning it will be much easier where difficult, and possible where impossible, to add more functionality to this. It's even possible for people to start making external modules for their features if they want to, as the library is finally open enough to support it.

I think it's ended up in a really good place. I hope you enjoy the new experience.

The vast majority of the module has been rewritten from scratch. The other modules have received major revision too and in some cases, rewriting.

Both the library internals and the code you write as a library user are much simpler now. Complex, verbose types have been simplified (no more everywhere). Changes are simple to make and don't require hacks anymore. Comprehending and maintaining existing functionality is easy now.

An effort has also been made to make the experience consistent. Different parts of the library that do related things, now have consistent names and a consistent API. This is more cohesive, less surprising and ultimately less to remember.

Contributing to Simplification, is Reduction. Similar concepts, structures, and utilities have been consolidated. Experiments that were too noisy and not useful enough have been removed. So too have little utilities that didn't provide enough benefit.

There's now less to learn, less to remember, less caveats to consider, and a consistent way of doing things.

A common, very valid complaint was that it had poor readability. There were too many symbols, inconsistencies in the API, single-letter suffixes all over the place, non-obvious abbreviations. (Example: )

All (ok, 98%) of this has been removed and replaced with a clearer API. In some places it's more verbose now but really, especially with auto-complete, what's an extra 10 chars on a line, every now and then? The readability improvement is worth it. Less cognitive load.

As everything previously grew from JS facades, there was a lot of implicits and monkey-patching. No longer. Nothing in components is hidden anymore, types provide full access to their lineage and you can see exactly how the layers stack. For example it's completely transparent that (and how) a builds on a which in turn has a raw JS-world value.

It is now easy-peasy for scalajs-react code to

There are two main reasons for this.

Generic representations. There is now a generic interface for components and their unmounted & mounted states. This allows any kind of component (JS, Clojure, ES6 classes, some custom super-simple Scala wizard) to be used and integrate with the library. Many library features now work with and provide functionality to all kinds of components. Want Scalaz extensions to some Typescript-based component you found and are using in Scala? done! Want access to a parent component's state regardless of what kind of component it is, regardless of whether the state you're interested in is a subset or whole, has transformation or not? done! Proper representation of non-Scala components. Various types of components, and their idiosyncrasies, can now be modelled easily. Included in the library are four types: - It's now a one-liner (not counting Scala.JS facades) to use community components written in pure JS. No more hacks! You can even get type-safety for JS components that expose ad-hoc methods once mounted; just specify the JS facade. - React "functional components" written in pure JS. Also a one-liner to create, similar to above. - Create React components in Scala using the functional builder with an optional backend. This is the best way to write components and is still around. Where as there used to be before, it's now . 

 There's also for creating efficient, static views. - Create React "functional components" in Scala. Basically a built on a Scala function, compatible with Scala types. Transformation of ALL component type parameters. When you have a component (or its Unmounted or Mounted stages), you can now completely map everything that goes in and out of it. Specifically you can: Transform props types and values (at top-level, and in Unmounted & Mounted too). Transform state types and values (at top-level, and in Unmounted & Mounted too). All JS facades are in a separate package (without any Scala niceness). All components expose their underlying JS values. Call on anything to get what you'd have if you were using pure JS. JS-based components have a Scala representation that allows nice, safe usage. It's transparent that you've got a Scala facade over the raw JS. The structure of components that you create using the Scala Builder are completely transparent too. You have access to the underlying (showing exactly how the Scala boxing and backend support is implemented), and access to its raw JS value. Nearly no more implicits are used. Nearly all the methods are now directly on the objects. Interoperability. It should be trivial to mix with other React libraries, regardless of the language. Using from JS or another language: due to the transparency changes you have full access to all underlying JS values and any transformations required. Using from another Scala-based React library: see above point, one could create implicit conversions as necessary. Using JS from : one-liner; see above. Using another language or Scala-based library from : either grab the pure JS values and call a few methods to add any required transformations, or create your own representations by extending the generic traits in the library. Children are now finally declared. There are currently two declarations: and . This means that you can no longer pass children to a component that won't use them, and you can no longer forget to pass children to a component that uses them. It might be an idea to add another case for components that want exactly one child, and enforce it in the constructor but this hasn't been done yet. The code is open to it which is nice. Props values can be pre-specified. This happens automatically when creating components with singleton types like and . It's also customisable in various ways. Input and output can be transformed. Additional fields on the raw/underlying JS props object can be specified.

Under-the-hood, the types have been rewritten and simplified, and is now easier to work and maintain. This no longer bears any resemblance to Scalatags. Scalatags was however, tremendously helpful in this journey so if you have a chance, please join me in giving @lihaoyi a big thanks for his work. VDOM attributes now have type-safety with regard to their values. Eg no longer compiles because the library knows that the attribute requires a boolean; works. Event-handler attributes now know which types of events they accept. Eg knows to expect a mouse event and won't compile if you pass it a drag event handler. No more automatic expansion of s. Either add or flatten it out of an array, or use to turn it into an array from React's perspective (which requires keys). Optional VDOM supported when enclosed in , , or . All VDOM now has and , allowing you to conditionally include/omit dom. This replaces the syntax. Note, that evaluation semantics have changed: was a "by name" parameter in , providing lazy semantics. When using and , vdom is evaluated, regardless of the condition value. React node array handling is safer, more efficient and has its own type ( ) with a nicer interface. Manually-specified objects now compose with other style attributes. All VDOM is now composable via . This was usually the case but there were a few corner cases that had differences. When it comes to , the operator has been removed -- to join many at once, instead of , use or the less efficient . React.JS has deprecated and will eventually remove String-based refs, and so they have been removed from scalajs-react. New type-safe refs to HTML/SVG tags that preserve the DOM type. Functional components do not support refs and so, there is no mechanism to do so anymore. In scalajs-react v0.x you could create refs to anything so this is an improvement. now has its own type that provides simple, idiomatic Scala usage. There are many types and methods that remain from v0.x and have been renamed for clarity and readability. Gone are the abbreviations, the symbols like and , the one letter suffixes, etc. Not all cases, but the vast majority. The result is code can occasionally be a little bit more verbose but much clearer. And don't worry about having to tediously update your codebase; there is a migration script will take of it for you. The underlying types used by components are complex. It's necessary to support all the desirable features we now have. What's not necessary is for that to leak into users' code. There are now many simple ways of accessing and/or abstracting over components. Which one you choose depends on the use-case and there is a guide in TYPES.md. Also: components no longer track DOM types. In cases where accessing a component's DOM is desirable, add a method to the backend (or externally) that casts it. Example: { ( : [ , ]) { Cast it yourself when desired [html. ] bs.getDOMNode.map(_.domCast[html. ]) } } Components created with now result in ES6 classes under-the-hood, instead using which was deprecated in React v15.5. There is also a raw facade for ES6 classes, and external React classes integrate with scalajs-react like any other components.

As usual, there is a migration script that will update the majority of your code base. This time however, there are also a bunch of things you'll have to update manually.

Go to your project directory. Make sure you've checked everything into version-control before you begin. 

Then run:

Alternatively you can open up 1.0.0-migrate.sh in your browser, inspect it, ensure it doesn't do anything nefaious or that you're uncomfortable with, then copy-paste it into your shell as a single command.

Make sure you've done the automated migration first.

These are the breaking changes that must be manually updated:

The migration script takes care of these but it's also worth highlighting these so you know:|||

scalajs-react - Facebook's React on Scala.js