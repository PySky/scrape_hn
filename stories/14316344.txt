This is part 4 in a series of posts on writing JIT compilers for BF.

Even though, for performance considerations, most JIT compilers are written in down-to-metal languages like C and C++, in some scenarios it could be useful to write them in higher-level languages as well .

This post intends to do just that, by presenting yet another JIT for BF - this time written in Python. It presents both a low-level approach to JITing native machine code, and using a higher-level library to perform instruction encoding. The JIT implemented here is not optimized (equivalent to the "simple" JIT from part 2), so I'm not going to discuss any performance results. The idea is just to show how JITing in Python works.

How to JIT from Python To be able to JIT-compile BF, we should first be capable of JITing any code at all. It's worth showing how to do this in plain Python without any third-party libraries. In part 2 of the series we've used the same approach as presented in my older How to JIT post for basic JITing by copying machine code into an executable memory segment and jumping to it. That was done in C and C++, but it turns out it's not much harder in Python due to the magic of . I've written about doing runtime calls to C code via ctypes before, and if you're not familiar with this wonderful tool, I encourage you to read more about it. What follows is a complete code sample that implements the JITing presented in the "How to JIT" post; it's heavily commented, so it should be reasonably clear what's going on: # Equivalent to dlopen(NULL) to open the main process; this means the Python # interpreter, which links the C library in. Alternatively, we could open # Grab the mmap foreign function from libc, setting its signature to: # Allocate RWX memory with mmap. Using mmap from libc directly rather than # Python's mmap module here because the latter returns a special "mmap object" # and we just need the raw address of the mapping. However, we will use the # PROT_* and MAP_* constants from the mmap module rather than duplicating them. # Emit code into the allocated address. This sequence of x86-64 machine code # Declare the type for our JITed function: long (*JitFuncType)(long), and cast # code_address (which is a void*) to this type so we could just call it. If you execute this code it will print -96, since the JITed function adds 4 to its argument. From this point on, it should be easy to implement a full JIT-compiler for BF using hand-rolled instruction encoding, just like in part 2. Feel free to do it as an exercise :) You'll face the same issue discussed in that post - manually encoding instructions and resolving labels/branches is tedious, and it would be nice if a library could do it for us.

Enter PeachPy - an x86-64 assembler embedded in Python. It's a relatively new project mostly aimed at writing highly-optimized assembly kernels for numerical computations without leaving the domain of Python. It even has a cute logo: PeachPy has some examples strewn around the web, and my code for this post can serve as another example. Let's start by replicating the simple JIT functionality shown above. PeachPy takes care of all the memory mapping behind the scenes , so the full code we need to write is just this: PeachPy lets us write our code in assembly rather than directly in machine code, and it also handles the loading for us. As we'll see soon, it lets us use symbolic labels (just like ) and takes care of jump target resolution automatically. In other words, it's just the tool we need to focus on our domain - compiling BF - without worrying too much about the low level details. Note how PeachPy uses Python's context managers (a very common approach for DSLs embedded in Python). The statement creates a context manager within which all assembly instructions (like and ) are appended to the function.

With the sample above, we actually already have most of the building blocks we need to JIT-compile BF. What remains is just a matter of digging in PeachPy's source and examples (sadly there's very little documentation) to figure out how to invoke and properly use its assembly primitives. The following is very similar to how is implemented in part 2. The full code sample is available here; I'll just highlight the important snippets of code. First the function "declaration": # Use r13 as our data pointer; initially it points at the memory buffer In this code we'll be passing from the host side (from Python, in this case), so the function signature is . We then give the symbolic name . The usual instruction-by-instruction BF compilation loop follows: PeachPy dresses Python in assembly-like flavor. Registers placed in brackets like imply dereferencing. While refers to the value of the register itself, refers to the value of the memory word whose address is held in - this is similar to the syntax of many assembly languages. For emitting I/O operations, we resort to syscalls again : For emitting the loops, we use a stack of PeachPy objects with one label for the loop and another for the "after loop". Again, this is very similar to how it was done with in part 2. # Create labels for the loop start and after-loop. # Jump to after the loop if the current cell is 0. # Jump back to loop if the current cell is not 0. Finally, this is how the JITed function is invoked: # Allocate memory as a ctypes array and initialize it to 0s. Then perform There's just a little bit of trickiness here in our usage of . Since we have to pass arguments to C functions, lets us declare C-like types like which is a . The funky syntax on the following line is nothing more than Python's destructuring of a list of 30000 zeros. So is now an object we can safely pass to our JITed function which expects a argument: This calls the JITed function, the result of which is I/O and modified memory cells in .

PeachPy - more features and some limitations My usage of PeachPy in this post has been fairly limited, and the library has many more features. For example: Since PeachPy was mainly developed to write fast mathematical kernels, it has fairly good support for the newest vector extensions like AVX512. There's some support for automatic register allocation. In the BF JIT, the register is used directly, but we don't really care which register it is. We could ask PeachPy for a "general purpose 64-bit register" and it would allocate one for us. When writing a much more complicated piece of assembly code, this can be very useful. There's also some support for generating ARM code, though I don't know how mature it is. However, PeachPy is also a fairly new library which means there are still limitations and rough edges. When developing the JIT I ran into a bug and sent a PR - which was promptly accepted. PeachPy also doesn't do well with a large number of assembly instructions. It has some recursive analysis logic that blows up the Python stack when run on large code. In the BF JIT, I'm setting the stack to a higher limit artificially; with that, PeachPy doesn't crash but takes quite a while to assemble large programs like Mandelbrot. According to PeachPy's maintainer, this is due to the design of PeachPy being aimed towards writing assembly code manually rather than generating it from some other language. Fair enough - but definitely something to keep in mind. All in all, the maintainer is responsive and the library seems to be improving quickly - so these limitations may go away in the future.

A somewhat higher-level alternative to JITing from Python is using , the new Python binding to LLVM. I wrote about llvmlite before and also ported the LLVM official tutorial to Python using it. would definitely do the job here (and most likely not have the limitations of PeachPy), but I wanted to go with something different in this part. After all, a BF JIT with LLVM was already covered in part 3, and is a binding to the same library, just in Python. PeachPy offers an altenative approach for machine code generation from Python - with more direct control of the emitted instructions, though none of the optimizations LLVM provides automatically.|||

