How to cite this blog post: 

 Abhi Gupta, Pearl Li, Erica Moszkowski, Marco Del Negro, and Marc Giannoni, "Forecasting with Julia," Federal Reserve Bank of New York Liberty Street Economics (blog), May 8, 2017, http://libertystreeteconomics.newyorkfed.org/2017/05/forecasting-with-julia.html.

A little more than a year ago, in this post , we announced DSGE.jl —a package for working with dynamic stochastic general equilibrium (DSGE) models using Julia, the open-source computing language. At that time, DSGE.jl contained only the code required to specify, solve, and estimate such models using Bayesian methods. Now, we have extended the package to provide the additional code needed to produce economic forecasts counterfactual simulations , and inference on unobservable variables, such as the natural rate of interest or the output gap. The old, pre-Julia version of the code, which was written in MATLAB and is posted here on Github , a public repository hosting service, also performed some of these functions, but not quite as fast. So what does DSGE.jl version 2.0 do? Version 1.0 of the package just estimated the parameters of the model. While this is a necessary step, and perhaps the most challenging one from a computational point of view, it is by no means the end goal. The real questions that motivate the use of DSGE models are: What are output growth and inflation going to be over the next two years? What are the drivers of these forecasts? What were the causes of the slow recovery from the financial crisis (a slow recovery that, unlike most private forecasters, the FRBNY DSGE model predicted back in 2010 )? What is the natural rate of interest—also known as r*—and how is it going to evolve in the future? We need to go beyond parameter estimation in order to address these questions.The FRBNY DSGE is a linear state-space model . A state-space model is a dynamic system where the underlying “state of the economy,” which we do not directly observe, evolves over time, and where the variables that we observe and forecast—such as real GDP growth—are a function of this state of the economy. If we want to make projections, we therefore need to come up with an estimate of the state of the economy today, and use it to guess the economy’s future evolution. If we want to also characterize the uncertainty about the model’s forecasts—that is, to construct the blue shaded areas in the charts in this earlier post —we need to take into account that we don’t quite know the current state of the economy or its evolution, and that even if we did know, future shocks will hit the economy. This chapter in the Handbook of Economic Forecasting provides an overview of the algorithm just described, which is implemented by the codes.When we want to plot the history of latent variables such as the natural rate of interest, a guess about the current state of the economy is not enough. We also need to conduct inference on the state of the economy in the past. For this type of inference, known as “smoothing,” we need another set of routines. The so-called “Kalman smoother” produces our average guess for the latent variables, while the “distribution smoother” produces the whole distribution. We build the former using an efficient algorithm developed by Koopman, and the latter using the approach of Durbin and Koopman (although code implementing an alternative approach by Carter and Kohn is also available). We use these very same techniques to extract the histories of the shocks that hit the economy over our estimation sample, and then use these histories to identify the drivers of economic fluctuations. Since all of these codes are also useful outside the realm of DSGE models, we made them available as a stand-alone package called StateSpaceRoutines.jl For those interested in the programming details, this technical post provides some information about the challenges we faced in writing the Julia code and how we addressed them. While the old estimation code was largely a direct port (in other words, a translation) of the original MATLAB code, we completely redesigned the forecast section to obtain code that is much faster and easier to use. Our efforts paid off to huge effect, with our most recent model running the full-distribution forecast step in approximately fifteen minutes, compared with the seventy minutes our old code took to perform the same tasks. In the technical post we discuss the design principles and Julia parallel computing tools that made these speedups possible. The Federal Reserve Bank of New York recently lent its expertise in code development to other central banks eager to learn about this new open-source computing language. In March, two of us traveled to give Julia workshops organized by QuantEcon at the Reserve Banks of Australia and New Zealand. The workshops covered Julia syntax, important features, and packages relevant to statisticians and economists, as well as our experience with Julia in the FRBNY DSGE team. All of the workshop materials can be found on Github . The two kangaroos shown in the photo to the left came back with us from the trip to Australia. Their names are An&Schorfheide (small kangaroo) and Smets&Wouters (large).The views expressed in this post are those of the authors and do not necessarily reflect the position of the Federal Reserve Bank of New York or the Federal Reserve System. Any errors or omissions are the responsibility of the authors.This post reflects the experience of the authors with Julia and MATLAB and does not represent an endorsement by the Federal Reserve Bank of New York or the Federal Reserve System of any particular product or service.|||

A little more than a year ago, in this post, we announced DSGE.jl—a package for working with dynamic stochastic general equilibrium (DSGE) models using Julia, the open-source computing language. At that time, DSGE.jl contained only the code required to specify, solve, and estimate such models using Bayesian methods. Now, we have extended the package to provide the additional code needed to produce economic forecasts, counterfactual simulations, and inference on unobservable variables, such as the natural rate of interest or the output gap. The old, pre-Julia version of the code, which was written in MATLAB and is posted here on Github, a public repository hosting service, also performed some of these functions, but not quite as fast.