One of the first questions I had when entering the commercial software industry was - “why are our code bases such sprawling messes of inconsistency and unnecessary complexity?” It took years of investigation, but I found the answer to boil down to three words — ‘collective code ownership’.

Marxist thinking is obsessed with collectivization of our most valuable resources. In software, we see its embodiment in ‘collective code ownership’. This practice allows individual engineers to steamroll necessary system design invariants to solve short-term problems. Predictably enough, this results in a ‘tragedy of the commons’ for our code bases.

Theoretically, there is a code review process that should preempt this to some degree, but in most places I’ve worked, code reviews that would block the most devastating forms of destruction get overridden by management. Worse, code review in general is usually the first ‘Agile’ practice to be discontinued. After all, you should ‘never be blocked’ in Agile, right?

Amazingly, when engineers under pressure annihilate architectural constraints as a side-effect of hurriedly patching in new features, this is called having ‘high velocity’. Appallingly, this type of ‘velocity’ is the main measure by which engineering progress is judged in Agile. Agile basically turns software companies into Soviet shoe factories.

We live in age of companies going abroad for talent. Now there are two reasons companies do this, where one is legitimate, and the other is mostly not.

The legitimate reason that companies go abroad for talent is to find the best of the best. If you’re an NBA team, you are poorly served to confine your scouts to American geography! The best software engineers make the best software companies — skin color, gender, and cultural differences mean fuck all when it comes to programming. Unfortunately, this legitimate approach to sourcing labor is happening less and less in favor of —

The illegitimate reason that companies go abroad is to cut labor costs. There are easily hundreds of thousands of under-employed engineers in the US, and when companies go abroad to undercut them even further with cheap labor… Well, it seems a terrific insult to the American people, in my view.

Workplace Marxism actually compounds the problem. The Marxist mindset is that for any given problem, it only need additional labor sources to be solved. It is the mindset against which David Brooks argued so many years ago in his book, ‘The Mythical Man-Month’. The Marxist mindset despises any reliance on exceptional talent, for a reliance on such an uncommon trait would create a dependency which cannot be thoughtlessly cut. Out of that would come individual empowerment of said talent, and that is the main thing that Marxist leadership can not tolerate.

So instead of hiring a few talented engineers, our dear Leaders take advantage of cheap labor pools to hire as many interchangeable mediocrites as possible. In spite of all reason and evidence, they continue to insist that 9 women can make a baby in one month. To them it would be a contradiction to believe otherwise.

A primary tenet of Marxism reasoning is — when you can’t win an argument with Marxist means of reasoning, shut down the debate. This is the worst thing you can in an intellectual endeavor like software engineering. Rigorous debate about the technical merits of our given decisions are ugly, time-consuming, painful… and completely necessary.

Unfortunately, thanks to workplace Marxism, we now work by the credo — “Anything you say can, and will, be used against you in a kangaroo court of HR.”

Social and evolutionary psychologists have for years been trying to explain that speech is a necessary mechanism of thought. We think we can think without speaking, but only in a way that falls prey to confirmation bias. When dealing with subjects as vastly complex as software engineering and legacy systems spanning millions of lines of code, your thinking must be as near to perfect as it can be. But when you work in an environment where anyone can choose to be offended by anything and go running off to HR to end you… You learn to keep to yourself, thinking sub-optimal thoughts, and ultimately making technical decisions that could haunt you for a very long time.

The most ironic thing about workplace Marxism is that it thinks it has a monopoly on team work. When it comes to team work, however, its politicizing nature has a deeply stifling effect.

In the types of environments that I have experienced, the problems start off when a couple of snowflakes figure out that they can bully others by anonymously tattling any perceived thought-crimes to HR. Marxist HR policy is that anyone can be accused, but no accuser may ever be identified. As people learn to play the game, in the end it becomes a Hobbesian war of all against all, with everyone running to HR at each slight, each strike more pre-emptive than the last. HR, being power hungry as it is, uses the situation its policies create to justify ever-increasing resources for intervention. In our organizations, HR is usually the wellspring of workplace Marxism for a reason. In a toxic environment of fomented mistrust and ideological witch hunts, HR grows like a bloated tumor.

Back to tech. The reason such an environment is particularly pernicious for tech is that engineers need to trust each other. There are so many incredibly difficult intellectual challenges, and so many different views on solving them, that a high-trust factor among teammates is necessary. Often times a bit of mind-melding can be the only way to solve our hardest problems. Even under post-Agile methodologies like Sovereign Software Development, programming is still a hugely collaborative effort (and rightly so). But if you’re in an environment of social assassination and in a constant state of political maneuver, you’ll never know who you can trust — if anyone at all.

Back when tech was free, software teams were smaller and significantly more independent. Like the Kulak farms of the pre-Soviet era, small teams were headed up by senior experts with local ownership. Collaboration within these tiny teams was intense, but magnificently productive. There were problems with this model (crunch time was often an issue), but it had too many advantages for the Agilists to easily displace…

In order to overthrow the existing social hierarchy under which software had long been developed, the Agilists undertook a metaphorical Balkanization against these Kulaks. By promising junior engineers less crunch time, more technical equality, and ultimately less responsibility, the Agilists were able to effectively bulldoze the existing order — and replace it with their own. The senior engineers who resisted were (with the help of a colluding HR department) railroaded out on accusation of — you may have guessed it — ‘not being team players’.

I’ll be the first to admit that the social order that the Agilists destroyed was imperfect. Still, it was the social order that arose naturally to create the Tech industry. Unfortunately, Marxists always make the perfect the enemy of the good in their bids to seize power.

Many engineers have recently discovered the simplifying power of functional programming. And most programmers recognize that our industry’s primary technical problem is that of exploding development complexity. It is obvious to many that functional programming would be a great tool to wield against many of our long-standing problems. Functional programming is a fundamental innovation in our field, solving most of the problems imposed by object-oriented solutions (due to the fundamentally complecting behavior of mutation).

So why is it that OOP is not being displaced by functional programming where it is technically appropriate to do so?

Marxism often makes an enemy of the unfamiliar, especially in regard to unfamiliar ways of thinking. To think novel thoughts, and then to speak them in disregard of how it will make others feel is in contrast with the feelings-first environment that workplace Marxism imposes. The mere experience of realizing that one has made a technically incorrect decision with lasting negative impact is a brutal enough. To be told this by an apparently crusading asshole like myself, unforgivable.

Pragmatically, there is also much about the inefficiencies of object-orientation that workplace Marxism has come to love. The fact that object-oriented systems suffer a fundamental lack of modularity goes a long way to justify the collective code ownership. Because you can’t reliably establish ownership roles without reliable module boundaries, Agile ends up punting on the ownership question with collective code ownership. Contrastingly, the uncommon genius and mathematical talent associated with functional programming does violence to the Marxist ideal of human interchangeability.

When Marxist leadership needs a 10x engineer, it just hires 10 engineers. Often on visa.

Workplace Marxism is a deeply intolerant mode of thought, but also one in serious denial of that fact. It is in such denial of its own intolerance that it has to project an opposite intolerance on others in order to justify expressing its own!

For example, in order for workplace Marxism to express its intolerance of white men in tech, it must invent a fiction of overwhelming misogyny and racism in tech. But the truth is, a vast majority of engineers (including myself) have personalities marked by the trait openness. We are naturally unprejudiced people, and if we disdain anything, it would be humanity as a whole. What we care about are ideas and rigor — which is why we are in tech in the first place! Identity politics is the domain of Marxists and KKK hillbillies — not tech geeks who just want to build cool things.

But in order for Marxism to self-justify, the fiction must be written. This is why you see so many fake hate crimes being perpetrated by Marxists in schools and the workplace — http://www.fakehatecrimes.org/

This twisted form of intolerance too often makes software development more about politics than about engineering, and slows natural productivity down to a crawl, and setting fire to one pile of money after another.

Frankly, I’m not really sure.

I’ve been in the commercial software industry for over a decade, and I’ve noticed there’s a lot of things outside the control of an individual. As someone who intentionally stays in a low-level coding role, I don’t often personally find myself in a position of influence. But let’s say I found myself in a leadership role. What would I do?

I suppose, to the extent that I could, I would avoid imposing methodologies like Agile that are rooted in this type of ideology. I would push for post-Agile methodologies like Sovereign Software Development. But it’s not clear how much success I would have. The difficulty is made apparent when we see that the problem of cultural Marxism is, quite unironically, cultural. I would say that tech is not a source of this problem, but more of a willing victim.

What I’m attempting to say is that I’m not sure that any fight against workplace Marxism should take place against tech directly. That would be akin to jailing a patient because his lifestyle choices resulted in him getting cancer. All we as engineers can really do is balance our own personal survival with the small non-conformities we can achieve against the prevailing dogma. At a minimum, we must become aware that when we choose to apply, conform to, or enforce policies rooted in Marxist thought that we necessarily trade away our collective engineering capabilities. We must understand that our software disasters are a result of a larger phenomenon — one that only the whole of our culture can deal with directly.

One question I repeatedly get is system with code ownership, like Sovereign Software Development, deals with the bus factor. The bus factor is the hypothetical scenario where one engineer who owns a piece of code is hit by a bus. For those who have read my writing in-depth, they will already know how the concept of ‘Steward’ was introduced to solve the issue.

Essentially, it works like this — while a module of code is owned by a ‘Vassal’, there are one or more Stewards who are responsible for the functionality and general knowledge of said code. So any time a Vassal checks in a change, it is reviewed post-hoc by the code’s Steward(s). Stewards thus act as sanity-checks for ongoing changes, as well provide redundant understanding of the code. With each Vassal being a Steward for one or more modules other than the one he owns, there is enough redundancy to take care of our hypothetical bus factor.|||

One of the first questions I had when entering the commercial software industry was - “why are our code bases such sprawling messes of inconsistency and unnecessary complexity?” It took years of…