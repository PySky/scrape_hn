Simply put, Webpack is a tool whose main purpose is to put together your various .js files into however many bundles you want, while making sure that the outputted bundles contain all the .js files of your project in the correct order. That’s it.

In order to use Webpack there is a single big requirement; your JavaScript must be organized in a module format. This means that each file must explicitly require all the other .js files that it depends upon and potentially make some items available to other .js files. With old-school techniques, there is no way of declaring file dependency apart from saying “Hey I’ll make sure that the script tag of A.js will get loaded before the script tag of B.js”.

In the modern world though there are mainly 3 different techniques of doing that:

Whether you are creating a project from scratch or you already have an ongoing project, you’ll have to structure it in such a way, as to comply with one of the above. At this point, i should mention that with the release of ES6 (or ES2015 or “the new version of JavaScript”), commonJS and AMD patterns are considered mostly deprecated, so unless you have a good reason of picking either of these, i would urge you to stick with ES6 modules when creating a new project, since that’s where the market is slowly shifting towards.

So, as we said earlier, each file must explicitly describe what it needs as inputs and what it will make available to other files. Whatever is not made available to other files, stays within the confines of the file it was declared in and will never be exposed. In a pseudo-language, this would look something like that:

So how would you be requiring other files? Well first of all you would need to scrap all of your <script … ></script> tags within the .html files. After that you would need to inform all of your .js files of their loading priority, which would translate to “Hey you need to be loaded after another file loads first”. In the module format world, requirement of files translates to a requirement of variables, functions, components, objects, etc., and it would resemble something close to the following:

The statements above, define add.js and variables.js as a dependency for our whatever.js. With that in mind, .js files have dependencies that fully describe what needs to be loaded, calculated or ran before they themselves can be loaded or ran. Webpack now takes these statements and tries to create a directed acyclic graph, which in plain English means that it tries to put all dependencies in order without any cycles. Having a cycle would mean that file A depends on file B and file B depends on file A, making the bundling impossible. If no cycles are detected however, Webpack is able to take the contents of all those files and inject them into a single .js file with the correct order.

But how does Webpack know which files to bundle, since there are no <script> tags present anywhere? The answer is that there is simply no way of knowing it. That’s why we need to declare a file that will work as an entry point. Webpack would describe the entry point as such: “Point me to a file so that when I recursively traverse its requirements, then everything that your project might need would have been imported”. In a modern case scenario that would be the .js file that holds the core/base component of your application. In an older case scenario that would be the file that needs to be loaded after every other .js file has been loaded. In our specific example from above, the entry point would be the whatever.js file.

As a final step, you only need to add a single <script> tag that will point to the bundled .js file that Webpack produced for us.|||

Much has been said about Webpack but I constantly come across people who are unaware, not only of its existence but of its actual purpose as well. In this article I’ll try and explain to you why…