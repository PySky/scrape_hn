Grokking these concepts intuitively will make understanding advanced features in Python like lambdas and decorators much easier. It also puts you on a path towards functional programming techniques. In this tutorial I’ll guide you through a number of examples to help you develop this intuitive understanding. The examples will build on top of one another, so you might want to read them in sequence and even to try out some of them in a Python interpreter session as you go along. Wrapping your head around the concepts we’ll be discussing here might take a little longer than expected. Don’t worry—that’s completely normal. I’ve been there. You might feel like you’re banging your head against the wall, and then suddenly things will “click” and fall into place when you’re ready. Throughout this tutorial I’ll be using this function for demonstration purposes. It’s a simple toy example with easily recognizable output:

All data in a Python program is represented by objects or relations between objects. Things like strings, lists, modules, and functions are all objects. There’s nothing particularly special about functions in Python. Because the function is an object in Python you can assign it to another variable, just like any other object: This line doesn’t call the function. It takes the function object referenced by and creates a second name pointing to it, . You could now also execute the same underlying function object by calling : Function objects and their names are two separate concerns. Here’s more proof: You can delete the function’s original name ( ). Because another name ( ) still points to the underlying function you can still call the function through it: "name 'yell' is not defined" By the way, Python attaches a string identifier to every function at creation time for debugging purposes. You can access this internal identifier with the attribute: While the function’s is still “yell” that won’t affect how you can access it from your code. This identifier is merely a debugging aid. A variable pointing to a function and the function itself are two separate concerns.

Functions Can Be Stored In Data Structures As functions are first-class citizens you can store them in data structures, just like you can with other objects. For example, you can add functions to a list: Accessing the function objects stored inside the list works like it would with any other type of object: You can even call a function object stored in the list without assigning it to a variable first. You can do the lookup and then immediately call the resulting “disembodied” function object within a single expression:

Functions Can Be Passed To Other Functions Because functions are objects you can pass them as arguments to other functions. Here’s a function that formats a greeting string using the function object passed to it and then prints it: You can influence the resulting greeting by passing in different functions. Here’s what happens if you pass the function to : Of course you could also define a new function to generate a different flavor of greeting. For example, the following function might work better if you don’t want your Python programs to sound like Optimus Prime: The ability to pass function objects as arguments to other functions is powerful. It allows you to abstract away and pass around behavior in your programs. In this example, the function stays the same but you can influence its output by passing in different greeting behaviors. Functions that can accept other functions as arguments are also called higher-order functions. They are a necessity for the functional programming style. The classical example for higher-order functions in Python is the built-in function. It takes a function and an iterable and calls the function on each element in the iterable, yielding the results as it goes along. Here’s how you might format a sequence of greetings all at once by mapping the function to them: has gone through the entire list and applied the function to each element.

Python allows functions to be defined inside other functions. These are often called nested functions or inner functions. Here’s an example: Now, what’s going on here? Every time you call it defines a new inner function and then calls it. And here’s the kicker— does not exist outside : "name 'whisper' is not defined" But what if you really wanted to access that nested function from outside ? Well, functions are objects—you can return the inner function to the caller of the parent function. For example, here’s a function defining two inner functions. Depending on the argument passed to top-level function it selects and returns one of the inner functions to the caller: Notice how doesn’t actually call one of its inner functions—it simply selects the appropriate function based on the argument and then returns the function object: Of course you could then go on and call the returned function, either directly or by assigning it to a variable name first: Let that sink in for a second here… This means not only can functions accept behaviors through arguments but they can also return behaviors. How cool is that? You know what, this is starting to get a little loopy here. I’m going to take a quick coffee break before I continue writing (and I suggest you do the same.)

You just saw how functions can contain inner functions and that it’s even possible to return these (otherwise hidden) inner functions from the parent function. Best put on your seat belts on now because it’s going to get a little crazier still—we’re about to enter even deeper functional programming territory. (You had that coffee break, right?) Not only can functions return other functions, these inner functions can also capture and carry some of the parent function’s state with them. I’m going to slightly rewrite the previous example to illustrate this. The new version takes a “volume” and a “text” argument right away to make the returned function immediately callable: Take a good look at the inner functions and now. Notice how they no longer have a parameter? But somehow they can still access the parameter defined in the parent function. In fact, they seem to capture and “remember” the value of that argument. Functions that do this are called lexical closures (or just closures, for short). A closure remembers the values from its enclosing lexical scope even when the program flow is no longer in that scope. In practical terms this means not only can functions return behaviors but they can also pre-configure those behaviors. Here’s another bare-bones example to illustrate this idea: In this example serves as a factory to create and configure “adder” functions. Notice how the “adder” functions can still access the argument of the function (the enclosing scope).|||

Python’s functions are first-class objects. You can assign them to variables, store them in data structures, pass them as arguments to other functions, and even return them as values from other functions.