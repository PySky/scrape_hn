Golang, the open-source programming language started in-house at Google, is turning 8 years old come November. Is Go — often called golang — just an attempt by a big-name tech player to brand itself as an industry leader (like Microsoft tries to do with C#) or lock people in to an ecosystem (ahem, Apple Swift), or is there a strategic purpose to Google’s programming language?

Google says that “Go was designed with an eye on felicity of programming, speed of compilation, orthogonality of concepts, and the need to support features such as concurrency and garbage collection.”

We think it’s FOSS at its best, a language written on the backbone of C (but without all the baggage) and made better by community involvement. And because it was started by Google, its emphasis on lean, network-efficient runtimes means it’s a perfect fit for DevOps. Let’s take a look at this statically typed language and why it could be your company’s next kick.

Libraries are not established. Compared to Java, Go seems like it doesn’t even have libraries. True, golang has plenty of standard packages in its library, and a few more community-driven sub-repositories, but don’t expect to find “Top 100” lists of golang libraries like you do with Java, for instance. You might need to create your own library or get creative if your project needs one that isn’t available. Conventions are specified and enforced through the compiler and formatter but are significantly different from other languages. For example, exported (“public”) variables and functions must be capitalized. While it reduces boilerplate, it creates a semantical difference between variable names that isn’t obvious unless you know about it. Switch statement cases don’t require the keyword; instead, if you want the execution to continue to the next case, you must insert the keyword. All the files in a single directory must have a single package. There is no getting around this, even if you want a ‘main’ package that calls into your ‘app’ package for multiple entry points or binaries. Doesn’t have generics. Most languages utilize them (all the languages we mentioned at the beginning do), and generics really help with making your code reusable for different applications. But why are they needed? Remember how we pointed out that Go is fast, like ludicrously fast? One of the reasons is because it doesn’t implement generics, so compile time and runtime are sped up. If you need to problem-solve with golang and still need generic functionality, try an array, slice, or map instead.

Infoworld says that Go’s native concurrency features make it shine because of its goroutines (lightweight threads) and channels. This is why we are rewriting Lumberjack’s smart agent in golang (more on that in the near future).

It’s also why container giants Docker and Kubernetes are built on golang. It’s lightning fast, and it’s perfect for serving up your applications. In fact, it’s so efficient that Netflix moved its network infrastructure from the once-invincible Node.js to Go. And as Uber was having difficulty managing geofence requests for their platform, they moved from Node.js to golang as well. Here’s what Uber’s engineering manager Kai Wei had to report on his company’s transition in 2015:

“This service has had 99.99% uptime since inception. The only downtime was caused by beginner programming errors and a file descriptor leak bug in a third party library. Importantly, we haven’t seen any issues with Go’s runtime.”

According to the Computer Language Benchmarks Game hosted on Debian.org, golang is fast. Like 100x or more fast. Golang beats Python in task performance on everything from CPU load, memory usage and more. Reason being is because it’s a low-level language, focused on fast compiling and faster runtimes. This is why file-sharing heavyweight Dropbox moved their sync platform from Python to Go in 2014 — and they haven’t looked back. Video game broadcasting service Twitch had a problem with garbage collection and also made the switch to golang in 2015. After implementing, they reported “a 20x improvement in garbage collection (GC) pause time” and “another 10x improvement in Go 1.6’s pause.” They also reported an additional 10x speedup in Go 1.7, which obsoleted their manual tuning. (Golang is currently on version 1.8, released in February 2017.)

When we started porting Lumberjack’s agent into golang from its previous Python iteration, we noticed speed improvements of up to 100x over its older version. We’re excited to pass that on to customers after our beta ends in the summer.

So far we’ve been singing praises in Google’s general direction. But Golang can’t be and is not the One Language to rule them all. Where does golang fall short and what should DevOps people be wary of when adopting?

Golang wasn’t meant to be a great language for GUI applications. Sure, a library once existed for that on GitHub, but it has been abandoned. If you’re needing a GUI with your Go application, trying pairing it with an HTML5 web interface instead.

As mentioned above, golang doesn’t have compile-time generics, which means you might be required to have duplicate code or type-cast to accomplish your purposes. Language extensibility can make some tasks more verbose as well, meaning more code. However, given that golang is an extremely lightweight language already, you might find that without generics, your codebase ends up being significantly smaller than on other languages anyways.

Think kernels, drivers, and embedded systems. This is what Mozilla’s Rust was built for. And this is also why Google’s own operating systems, Chrome OS and Android, aren’t built on Go.

So you’ve bit the bullet and want to start learning Go. Where do you, um, go for that? Given the open-source nature of the language, there’s a ton of resources available from the community, almost all of them free.

First, you can get started by going to golang’s own introduction at tour.golang.org. The tour is meant for programmers; if this is your first language, don’t start there.

For community support, there’s the Golang-dev development list. Meanwhile, the Golang-nuts Google Group is quite active and is staffed by a cadre of passionate golang fans. The principal authors of golang, Robert Griesemer, Rob Pike, and Ken Thompson, have also been known to speak up on the forum from time to time.

Additionally, Karl Seguin’s popular 84-page “Little Go Book” is free and is available on the go (no pun intended) as a PDF. A GitHub wiki lists some of the more popular online resources for learning golang as well. Finally, online learning platform Udemy has a number of Go courses ranging from $20 to $200.

We recommend starting with gofmt first, a built-in library that will clean up your project code. While gofmt is great for formatting your code, it doesn’t make it pretty. For that, you can use golint, a community-driven linting library that is maintained on GitHub. By the way, if you’re interested in error checking, check out go vet, which vets code for errors not caught by compilers, such as Printf arguments that don’t match the format string.

We hope this miniguide has been a useful primer on golang and why we think it’s the perfect language for your DevOps projects. We think Golang is so good that we are porting Lumberjack’s agent from Python over to it, and we’re already noticing major improvements our customers will love. Check back on the Blue Matador blog in the near future to read why Lumberjack is better in Go.|||

Apple has Swift, Microsoft has C#, so what’s Google’s Go good for? DevOps applications, it turns out. And we tell you everything you need to know about golang here.