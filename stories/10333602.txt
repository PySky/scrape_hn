Just like a lot of other embedded software engineers, I used to ship my embedded applications to production without testing them properly. Only some manual tests were done. I was under the impression that there's no real way to test them: you know, embedded applications run in a custom hardware and interact with this specific hardware heavily, which makes them not so easy to test automatically. But the more I worked in this field, the more I thought that there should be some way to make my applications more reliable. Of course, I strive to develop right application design and write good implementation, but mistakes (sometimes very silly ones) happen. And one day, I've come across the awesome book: Test Driven Development for Embedded C by James W. Grenning. It is a very good book, and it explains the topic very thoroughly; highly recommended. Although this article is based heavily on what I've learned from this book, it is not just a very short version of it: while trying to put my knowledge to practice, I found some new tools that simplify the process even more. I hope that the article will help you to start quickly.

Embedded development differs from other software engineering fields in that embedded application has to interact with the hardware, and the hardware might be very different from application to application. Unfortunately, I've seen a great deal of code which performs some application logic while interacting with the hardware directly. It is sometimes done in the name of efficiency (on the very low-end chips, even function calls might be considered as expensive), but eventually it might lead to one's habit, which, of course, is to be avoided. The main idea (which is very good in itself, not only for unit testing) is to separate the hardware interaction and the application logic as much as possible. Then, we end up with a bunch of separate modules, which can be tested outside of the hardware. And when we write our application with the testability in mind, we literally have to separate things. So, one “side effect” of writing a testable code is the modularity, which is a good thing to have. Testable code is all good! So, in this article, we will not test the hardware layer. It has to be as thin as possible, and I still test it manually. What we will test is everything else: the modules that use hardware layer, and the modules that use other modules. While there are techniques to run tests on the target hardware (and the book by James W. Grenning touches upon them, among other things), this article focuses on testing on the host machine instead. And it's probably worth mentioning that unit tests are not the silver bullet that will magically turn your projects in completely bug-free ones. This is not true even for desktop programming, where we use the same compiler for tests and for production; and in the embedded world, it's even worse, since: We can't test for compiler bugs (and, unfortunately, embedded compilers tend to be… not very good); There may be subtle issues in software-hardware interaction; Still, from my personal experience, the final outcome is a way better on carefully tested projects than on untested ones. At least, well-written tests will save you from your own silly mistakes. And if you're like me, you definitely want that.

In order to bring the project to its initial state, checkout to the tag : This device should merely measure some voltages (which are converted to an integer via ADC), and display them properly. It should also be available to communicate with the checker device, which will calibrate the electric circuits. Initial project tree looks as follows: There are three directories: Since the resources are very limited, we don't use a RTOS: just a super-loop. We also can't use any -like functions, as they are too expensive. And we can't use floats: we use integers only. So, the looks like this: This is a quite common scheme for non-RTOS solutions: in the super-loop, we just call each module's function, which might do some job. Currently, we have just one module there: . The module is an MCU-dependent routines to retrieve raw ADC values. Its looks like this: /** * Type that is used for ADC raw counts. */ T_BspAdcCounts       bsp_adc__init   /** * Returns raw ADC counts for the specified channel */ T_BspAdcCounts bsp_adc__value__get E_ApplAdcChannel channel_num   /** * To be repeatedly called from the application's super loop: stores current * measurement when it's ready and switches between different channels as * appropriate */ bsp_adc__proceed As you see, it's very easy. When we call , it returns the raw ADC value for specified channel, which is not particularly useful. We'd like to convert it to something more human-readable, right? That is, to the value in Volts. There is an module for that. Basically, it just applies a summand and a multiplier to the raw value returned by , and we get an integer value in Volts, multiplied by some scale factor (in this example, the factor is used; so, the value means 12.5 Volts. For each instance of ADC handler ( ), we call its constructor function: S_ADCHandler_CtorParams   /** * Maximum value that ADC could return. Say, for 10-bit ADC it should be * 0x3ff. */ T_ADCHandler_CountsValue max_counts   /** * The board-dependent maximum voltage that could be measured, it * corresponds to the max_counts. * * It is only needed for calculation of nominal multiplier. */ T_ADCHandler_Voltage bsp_max_voltage   /** * Calibration data: summand and multiplier. * * Set just all zeros to use nominal. Nominal mul will be calculated by * max_counts and bsp_max_voltage. add will be copied from * nominal_add (see below) */ T_ADCHandler_Clb clb   T_ADCHandler_Voltage nominal_add_volts   T_ADCHandler_CtorParams And then, when we want to convert some raw ADC value to Volts, it is as easy as: As you see, the ADC handler module is completely self-contained: it doesn't have any dependencies. Modules like this are the easiest ones to test, so, let's start our test journey from ADC handler.

The binary allows us to create new project tree by executing the command , including even main source directory. Since I usually create my projects in some other way, I need to move things around after ceedling has created new project. Let's move on: to the project's directory (where you have the directory), and execute the following: This will create the new directory with the following contents: : directory for our test C files; : directory in which our built test will be located; : ceedling-provided binaries and all accompanying stuff. It includes CMock, Unity, and other tools. Since we're just users of Ceedling, we have little interest of actual contents of this directory, except the documentation: : documentation of Ceedling and components. Very useful; : the directory in which Ceedling assumed to have source files, but we're going to store files not here, but in our own directory; : it is needed to run tests; you don't need to understand it; : the actual project file, which we need to adjust for our needs. The heart of the test build system is the project file: . Among other things, it contains paths to your application source files. Since our source files are contained not where assumed by default, we need to change the project file a bit: open the file and find the section: As you might have already guessed, we need to change to the path to our actual source files, relative to the location of the project file. Ok, that's easy: let's add all source paths that currently exist. We end up with three paths there: Now, in order to avoid confusion, let's delete the auto-created directory, since we're not going to use it. We also want to add some files in our empty directories, so that git will keep them in repository. From the root of the repository, type: Add files to the repository and commit: Note: you can get everything done by using the prepared repository. Type there: . Actually, our test build system, though empty, is ready to run! Try it: make sure you're in the directory, and type in the terminal: You should see the following output: It works, and it predictably reports that we have no tests. So, let's add some meat to the bones!

As mentioned above, we'll start by writing tests for our ADC handler, since it is one of the easiest things to test: it has no application-specific dependencies. The job of ADC handler is to convert from raw ADC counts to voltage, and vice versa. We'll test this functionality. First of all, let's create blank test file. I have a template for this: We can use this template whenever we need to write new test. Our tests are just functions with names that start with . In the example above, we have just empty function. We also have two special functions: and . The is called before running each test, and is called after running each test. We'll take advantage of them soon. Now, let's add ADC handler test here. We begin by adding the header of the module being tested: Then, add an instance that we'll run tests against, together with the result code returned from constructor: And then, construct/destruct it in / , respectively. setUp T_ADCHandler_CtorParams params   params.   params. ADC_HANDLER__SCALE_FACTOR__U   params.     //-- construct the ADC handler, saving the result to _ctor_result _ctor_result adc_handler__ctor _adc_handler params   tearDown adc_handler__dtor _adc_handler Now, the easiest test we can come up with is to check that constructor has returned successful status, i.e. . So, rename our dummy to , and add our first assert: We're ready to run our first test! $ rake test:all Test 'test_adc_handler.c' ------------------------- Generating runner for test_adc_handler.c... Compiling test_adc_handler_runner.c... Compiling test_adc_handler.c... Compiling unity.c... Compiling adc_handler.c... Compiling cmock.c... Linking test_adc_handler.out... Running test_adc_handler.out... ----------- TEST OUTPUT ----------- [test_adc_handler.c] - "" -------------------- OVERALL TEST SUMMARY -------------------- TESTED: 1 PASSED: 1 FAILED: 0 IGNORED: 0 It works, and our test has passed. Good! Among other things, you see that Ceedling has figured out that it needs to build . How does it work? Ceedling examines the headers we include in our test file, and looks for the appropriate source file. Since we have included, Ceedling looks for file in all source paths that we've specified in our , and compiles it. Pretty easy. If you used to apply TDD practices, you know that it's good to make sure our tests fail if code behaves in wrong way. We don't do TDD here, since we already have some code before we write tests, but we still can make sure that our tests can fail. If we change so that it returns, for example, , our test will fail as follows: ----------- TEST OUTPUT ----------- [test_adc_handler.c] - "" ------------------- FAILED TEST SUMMARY ------------------- [test_adc_handler.c] Test: test_ctor_ok At line (72): "Expected 1 Was 6" -------------------- OVERALL TEST SUMMARY -------------------- TESTED: 1 PASSED: 0 FAILED: 1 IGNORED: 0 --------------------- BUILD FAILURE SUMMARY --------------------- Unit test failures. That's it. Let's change back to correct state, and commit. We definitely don't want to include build output in the repository, so, add the directory to ignore list. In the root of the repo, create file with the following contents: And then, commit changes: Note: you can get everything done by using the prepared repository. Type there: . Now let's check that ADC handler is actually able to convert from ADC counts to voltage. We'll test the function . With the parameters we've given in function, we need to make sure that counts are converted to 0.0 Volts, counts are converted to 10.0 Volts, and, for example, counts are converted to 3.33 Volts. If we run this test, it should pass: So, we can be sure now that ADC handler performs its basic job. Note: you can get everything done by using the prepared repository. Type there: .

As was mentioned before, we can't use floats since they are too expensive for this cheap MCU, so, we store voltage as integer in Volts, multiplied by the factor . Of course, we need to convert the voltage integer value like to the string like . That's what the awfully named module is for. The name “itoae” stands for “integer-to-array-extended”. /** * Itoa a bit extended: allows to set minimal length of the string * (effectively allowing us to align text by right edge), * and allows to put decimal point at some fixed position. * * @param p_buf * where to save string data * @param value * value to convert to string * @param dpp * decimal point position. If 0, then no decimal point is put. * if 1, then it is put one digit from the right side, etc. * @param min_len * minimum length of the string. If actual string is shorter than * specified length, then leftmost characters are filled with * fill_char. * @param fill_char * character to fill "extra" space */ itoae p_buf value dpp min_len fill_char You can find the source in the file . The implementation is rather dumb: first, we call “regular” that doesn't know anything about decimal points, it just converts integer to string. Then, if we need for decimal point, then move some characters to the right, and insert the . As you see, this function is very straightforward to test as well. Let's create new file from the template above, and include the header of module being tested: We're going to have a buffer for generated string: As well as the function that wills the buffer with : We will call this function before each assert, so that the buffer is reinitialized every time. And a couple of simple tests: ------------------- FAILED TEST SUMMARY ------------------- [test_itoae.c] Test: test_dpp At line (127): "Expected '12.3' Was '12.3\0xFF\0xFF\0xFF\0xFF\0xFF\0xFF\0xFF\0xFF\0xFF\0xFF\0xFF\0xFF\0xFF\0xFF\0xFF\0xFF'" -------------------- OVERALL TEST SUMMARY -------------------- TESTED: 4 PASSED: 3 FAILED: 1 IGNORED: 0 Oops! Something went wrong. It seems that although the dot was inserted to the string correctly, the terminating wasn't moved to the right by 1 char. After examining the source, I see that here's the offending piece of code: Although I provided the handling of terminating null char, there is a traditional off-by-one error here. The correct code looks as follows: Save, switch to the terminal, run the tests again: Cool! These very simple tests already saved me from the very silly mistake. Believe it or not, this mistake with has actually happened to me, and tests helped to reveal it. This episode quickly encouraged me to invest my time in tests even more. Note: not all tests code is included in the article, since it is very repetitive and straightforward. You can get everything done by using the prepared repository. Type there: .

Our application needs for some resourceful way to get current voltage on some particular channel, in Volts. It would be unwise to use our + modules across the whole application. Now, let's add the module , which will have at least the function to get current voltage on some channel, in Volts. The header should contain at least the following:     appl_adc__init   /** * Get current voltage of the given channel. */ T_ADCHandler_Voltage appl_adc__voltage__get E_ApplAdcChannel channel_num This function should call for the given , then feed returned value to the appropriate , and return resulting value in Volts. For now, let's just fake the implementation ( ): And get to tests: create new file , and put the tests template in it. As usual, include the header of the module being tested: Our and are very simple: And get to the test for : As was mentioned before, first of all should call for the appropriate channel. How do we test it? The answer is - with CMock. And Ceedling will help us here as well: if we need to “mock” some module, all we need to do is to include the header of the module to mock, with the prefix (well, actually, the prefix is customizable in , and by default it is ). Go on then: add the following include directive: Now, the module being tested will use mocked versions of all functions from , and we are provided with the “expect” functions. Let's see them in action: test_voltage_get //-- We expect bsp_adc__value__get() to be called: bsp_adc__value__get_ExpectAndReturn //-- the argument that is expected to be given to APPL_ADC_CH__I_SETT   //-- and the value that bsp_adc__value__get() should return   //-- actually call the function being tested, that should perform T_ADCHandler_Voltage voltage appl_adc__voltage__get APPL_ADC_CH__I_SETT   //-- check the voltage returned (we assume that adc_handler is initialized // with the same params, where 0x3ff is the maximum ADC value, and // it corresponds to the value (10 * ADC_HANDLER__SCALE_FACTOR__U)) TEST_ASSERT_EQUAL_INT ADC_HANDLER__SCALE_FACTOR__U voltage If we run the tests, we get the following result: So it complains that returned value was wrong. Okay, let's fake our dummy even more: make it return instead of : Oh, cool! It reports that the function was called less times than expected (effectively, it wasn't called at all). CMock in action! Well, it's time to implement more or less completely: we're going to use both and there.         T_ADCHandler _adc_handlers APPL_ADC_CH_CNT       appl_adc__init E_ApplAdcChannel channel   channel channel APPL_ADC_CH_CNT channel T_ADCHandler_CtorParams params   //-- here, we initialize all channels with the same params, // but in real life different ADC channels may, of course, params. params. ADC_HANDLER__SCALE_FACTOR__U params.   //-- construct the ADC handler, saving the result to _ctor_result adc_handler__ctor _adc_handlers channel params   T_ADCHandler_Voltage appl_adc__voltage__get E_ApplAdcChannel channel_num adc_handler__voltage__get_by_counts_value _adc_handlers channel_num bsp_adc__value__get channel_num Ok, it seems, everything is right. Try to run tests: Linking test_appl_adc.out... build/test/out/appl_adc.o: In function 0097ppl_adc__init': /home/dimon/projects/indicator_git/test_ceedling/../src/appl/appl_adc.c:70: undefined reference to 0097dc_handler__ctor' build/test/out/appl_adc.o: In function 0097ppl_adc__voltage__get': /home/dimon/projects/indicator_git/test_ceedling/../src/appl/appl_adc.c:76: undefined reference to 0097dc_handler__voltage__get_by_counts_value' collect2: error: ld returned 1 exit status .... NOTICE: If the linker reports missing symbols, the following may be to blame: 1. Test lacks #include statements corresponding to needed source files. 2. Project search paths do not contain source files corresponding to #include statements in the test. 3. Test does not #include needed mocks. Oh, dear. Linker complains about undefined reference to ADC handler functions. And Ceedling is being very kind here by providing us with useful notice: as it suggests, one of the possible reasons is that test lacks statements corresponding to needed source files. Do you remember that Ceedling examines the headers we include in our test file, and looks for the appropriate source file? So, to make it work, we should include the header to our : //-- other modules that need to be compiled Now, the tests should finally work: Note: you can get everything done by using the prepared repository. Type there: .

The easiest option is to ignore arguments given to whatsoever. That's what functions are for (generated by CMock): test_voltage_get //-- We expect bsp_adc__value__get() to be called: bsp_adc__value__get_ExpectAndReturn //-- the argument that is expected to be given to APPL_ADC_CH__I_SETT   //-- and the value that bsp_adc__value__get() should return   adc_handler__voltage__get_by_counts_value_IgnoreAndReturn   //-- actually call the function being tested, that should perform T_ADCHandler_Voltage voltage appl_adc__voltage__get APPL_ADC_CH__I_SETT   //-- check the voltage returned (it should be 456 from the mock above) TEST_ASSERT_EQUAL_INT voltage ------------------- FAILED TEST SUMMARY ------------------- [test_appl_adc.c] Test: test_voltage_get At line (57): "Function 'adc_handler__ctor' called more times than expected." Oh yes, we forgot that now we have to mock not only , but the constructor as well, which is called from . We're going to ignore its arguments too, so, the modified looks as follows: setUp //-- ADC handler constructor is going to be called for each channel. E_ApplAdcChannel channel channel channel APPL_ADC_CH_CNT channel adc_handler__ctor_IgnoreAndReturn ADC_HANDLER_RES__OK   appl_adc__init Note: you can get everything done by using the prepared repository. Type there: .

Apart from easy-to-use helpers, CMock provides us with the very flexible callback helper. The callback should have the same signature as the mocked function, but it takes one additional argument: . When the function called first time, is 0, and it will be incremented by 1 with each subsequent call. In the callback, we might check whatever we want, and if something goes wrong, we can call Unity macro .   T_ADCHandler_Voltage _get_by_counts_value_Callback T_ADCHandler me T_ADCHandler_CountsValue counts_value num_calls T_ADCHandler_Voltage ret   num_calls counts_value   //-- We can check whatever we want here. For example, we may // check the data pointed to by "me", but NOTE that currently // it is just zeros, since we have mocked adc_handler__ctor() // as well, so the original constructor isn't called, and   TEST_FAIL_MESSAGE   ret   TEST_FAIL_MESSAGE   ret And in our , we use it as follows: Although callbacks like this don't look quite elegant, and for this particular example it is an unnecessary overkill, they are extremely flexible. So, keep it in your toolbox, and use when appropriate. Note: you can get everything done by using the prepared repository. Type there: .

Compilers often have some useful non-standard built-in things. For example, the XC8 Microchip compiler has the function , which, how its name suggests, puts software breakpoint. If the MCU runs in it with debugger attached, debugger halts execution. This function becomes available if we include the header. I often use it for some conditions that should never happen. For example, our should never be called with wrong . Let's add a check for this:     T_ADCHandler_Voltage appl_adc__voltage__get E_ApplAdcChannel channel_num T_ADCHandler_Voltage ret   channel_num APPL_ADC_CH_CNT ret adc_handler__voltage__get_by_counts_value _adc_handlers channel_num bsp_adc__value__get channel_num //-- illegal channel_num given: should never be here __builtin_software_breakpoint   ret Checks like this are a must have in any application, but if we try to run tests, we'll end up with the following error: Compiling appl_adc.c... ../src/appl/appl_adc.c:15:16: fatal error: xc.h: No such file or directory #include "xc.h" Obviously, GCC (which is used for tests by default) have neither such a built-in function, nor the header file. We can address this problem by using the Ceedling “support” directory, which is located by default at . Let's create the file in it, and put the following contents there: If we run tests now, we'll have different error: Nice: at least, our file is clearly used by file, and now we need to provide actual implementation of . The easiest way to do that is to mock it. So, add the following line to our file: Now, run tests, and they pass! And we can write one more test: let's check that is called if we pass illegal channel number: test_voltage_get_wrong_channel_number //-- we expect __builtin_software_breakpoint() to be called ... __builtin_software_breakpoint_Expect   //-- ... when we call appl_adc__voltage__get() with illegal appl_adc__voltage__get APPL_ADC_CH_CNT You're encouraged to verify that if we remove a call to in case of illegal channel number, tests will fail. Note: you can get everything done by using the prepared repository. Type there: .

Testing on host machine is quite convenient: running tests is just a matter of a few keystrokes, tests run fast, and we get results almost immediately. But we should take some care, since the architectures are different. As already discussed above, different compilers have some built-in functions. Apart from this, the memory alignment is often different: at 8-bit MCUs, the alignment is 1 byte, but on your host machine it's usually 4 or 8 bytes (depending on your architecture). So, we have to multi-target our applications. I often find myself creating a file like , in which I declare some things depending on the compiler being used. For example, if I need some structure to be , I have to use compiler-specific attribute. So it may look like this: //-- no need for "packed" attr on 8-bit MCU And in the application code, I use the macro . This way, we can write code that works both on target MCU as well as on the host machine. Of course, it takes additional effort and time, but so do tests in general. I spend a lot of time writing tests these days. It pays off very well.

Writing tests code is often considered as a tedious process, and I can't entirely disagree. However, I always encourage myself to find some new ways to test things, instead of repeatedly test this and that. As an example, consider the EEPROM module (Electrically Erasable Programmable Read-Only Memory). We will most likely end up with MCU- or board-specific module which can just read plain data to and from specified addresses. As it is heavily hardware-dependent, we can't test it on the host machine. In addition to , it's convenient to have application-dependent module like , which should have functions to write or read some application entities to and from EEPROM. Of course, these application-dependent functions call functions underneath. For example, we might have the following functions to read/write the multiplier of each particular ADC channel: If the application is rather large, there may be tons of functions like that. It is very tedious to test them all separately. Instead, we may think about the most easy mistake to make. For things like the module, it is the copy-paste mistake: when we have lots of similar functions (in fact, they all call the same functions, but for different addresses), it is easy to copy and paste from one function to another, and it is equally easy to forget to adjust the pasted code properly. So, I often use the technique like this: define stub callbacks for functions, which just check if the given area is “clean”, and if it is, then fill this area with some predefined data (make it “dirty”). If the area is already “dirty”, then error is generated. Then, perform “write” test: I call every “write” function from module with all allowed arguments, and after that, the whole working region of EEPROM should be “dirty”, without holes. And, as I said before, each callback also checks whether the region it is going to write is clean. This way, we can easily eliminate these “copy-paste” problems: if some function writes to wrong area, we will end up with overwritten data and “holes”, which will be caught by our tests. And, of course, exactly the same test should be done for “read” functions. It is much more fun (and fast) than test each and every function separately, and in the end we'll have tests that are reliable enough.|||

