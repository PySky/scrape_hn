Microservices architectures have become a ubiquitous industry trend because of their promise of speed, agility and scale. Just like any major paradigm shift, microservices adoption introduces many changes at architectural, technical and organizational levels. It is not uncommon to overlook some considerations in pursuit of microservices based applications. While containers, orchestrations, automation, service definition, etc. take up majority of the mindshare, here we have identified 3 often overlooked but critical considerations based on our customer conversations.

An overarching takeaway is that in a microservices architecture complexity is shifting from being code-based to network-based. Therefore, service-interactions become a much richer source of information for health, performance and security of microservices applications. Netsil has leveraged this key insight and built the Application Operations Center (AOC) using service-interactions as the source of truth. As we explore the considerations mentioned below, we will highlight how the AOC benefits SREs and operations teams in improving reliability and delivering service-level objectives (SLOs) for their microservices based applications.

In microservices architectures, services interact heavily with each other to fulfill transactions. Each of these service-interactions requires a subset of these common functionalities:

In any microservices application, many services will have need for some common functions. Cache, key-value stores, distributed lock managers and service discovery are good examples of such common functions used by multiple services. In the monolithic world, multiple components could simply use shared libraries for such common functions. And with handy techniques such as Docker or Packer, it might be tempting to bundle the shared libraries with all the services that use them. But continuing down the path of shared libraries becomes detrimental for at least 2 reasons:

The paradigm of building and using shared services can be seen in Netflix EVcache, the popularity of redis and etcd for key-value stores, and growing use of products such as Consul for service discovery.

Failure is inevitable in a distributed system. The role of circuit breakers is to contain the failure and avoid propagating isolated failures to the entire application.

Letâ€™s say service A calls service B which in turn calls service C to fulfill a particular transaction. If downstream service C starts experiencing errors and experiences a time-out then service B and eventually service A will both start failing. In real world scenarios when such failures are left unchecked it can have disastrous effect impacting transaction integrity, causing data inconsistency and resulting in widespread outages of multiple services. Instead, if service B implements a circuit breaker paradigm, then the circuit breaker will monitor for failure of service C and when failures exceed specified thresholds it can invoke graceful error handling.

Microservices bring a lot value and a lot of changes. We hope this blog has put the spotlight on the considerations that you will take in to account. Based on your experience, if you have other important considerations then do share them in the comments section below.

Also we have highlighted the value of the Netsil Application Operations Center (AOC) for operations teams responsible for health and performance of microservices applications. You can get started with the AOC in less than 10mins using the nicely packaged single container images. Download the AOC here and we look forward to engaging with you on your microservices efforts.|||

What are some of the critical but often overlooked considerations in microservices architectures of cloud applications? We take a look.