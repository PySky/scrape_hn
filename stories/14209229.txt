In this tutorial, we will walk through the steps of building a simple Rails app called Flipper. It is essentially a simplified version of the demo that allows you to flip a piece of text upside down:

To make things interesting, we will be implementing the core functionality in Rust using Helix. At the end of the tutorial we will also cover deploying this app to Heroku.

Before we begin, we need to install Rust using the rustup installer:

If you already have rustup installed, run this command to ensure you have the latest version of Rust:

First, we’ll need a new rails project. (If you are integrating Helix into an existing Rails project, you may skip this step.)

Since we are not going to need a database for this simple app, we can simplify things by removing Active Record with the flag. To make sure things are working properly, let’s make sure we can run the Rails server:

If you visit http://localhost:3000 in your browser, you should be greeted by a page similar to this:

Once you have verified that everything is working, exit the Rails server by pressing Ctrl+C.

To start using Helix, add the gem to your Gemfile:

Be sure to run afterwards.

Now that we have Helix installed, we can generate a Helix crate:

This will generate a Helix crate called text_transform, located in . A Helix crate is simultaneously a Rust crate and a Ruby gem. This encourages you to structure your Rust code as a self-contained library separate from your application code.

Looking at the boilerplate generated by Helix, we can see that it generated a Rust file for us:

This defines a simple Ruby class with a single class method. To test this out, we can run , which automatically compiles the Rust code and puts us into an irb session:

As you can see, we were able to invoke the method (implemented in Rust) from Ruby. Pretty cool!

Now that we have the boilerplate down, let’s implement the library.

Let’s begin by writing some tests using RSpec.

First we will add as development dependency:

Be sure to run afterwards.

Then we will add our test:

As expected, the tests will fail as we have not implemented the method:

Now that we have some failing tests, let’s implement the missing method (in Rust!):

The method takes a string as input, split it into characters, map each character into its “upside down lookalike” and join them back up into a new string.

Now that we have implemented the method, let’s run the tests again:

Hm, it is not seeing the method we just implemented. This is because since Rust is a compiled-language, we would have to re-compile our code after making any changes:

Now if we run the tests again, everything will work as expected:

To avoid needing to manually recompile, we can wrap this in a rake task and make its dependency:

That way, running will always ensure the Rust code is built (and up-to-date) before running your tests, just like the built-in task.

Now that we have built a library to do the heavily-lifting for us, we wire everything up inside our Rails app.

Then we will create the controller:

After starting the Rails server with the command, you should have a working Flipper app waiting for you at http://localhost:3000:

As you can see, with pretty minimal effort, we were able to crate a Ruby native extension written in Rust using Helix, and integrate it into our Rails app.

Finally, we will deploy our Flipper app to Heroku.

First, you will need to create a Heroku account and install the Heroku CLI tools.

Then, we will need to create a Heroku app:

Since Flipper is both a Ruby and a Rust app, we will need to set up the buildpacks manually:

These commands adds the Rust buildpack, which makes the Rust compiler available, as well as the regular Ruby buildpack that knows how to configure a Rails app.

Finally, we can deploy the app to Heroku:

With that, you should have a working Flipper app – powered by Rust, running instead a Rails app – up and running on the Internet. Congratulations!|||

