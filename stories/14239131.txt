Hackers might want a trigger warning for this one.

Slashdot recently asked: “Should Banks Let Ancient Programming Language COBOL Die?” And what would the canonical answer be? Ding, you are correct, your instinct tells you that you want the plug pulled and all COBOL code ported over to some new sexy language like… the one you thought we were going to name. Of course.

People who work with code for a living, by reflex, tend to be just a bit evangelical on the subject of The Proper Programming Language. Such people, used to regarding code by its aesthetics, will recoil in horror at the mere mention of such ugly, outdated dinosaurs as BASIC, PASCAL, and most especially… COBOL. And rightly so! In a perfect world, everybody would use the current best language. We would also have a cure for cancer.

But there’s the perfect, ideal world the hacker lives in, and then there’s the grubby, rusty, industrial world of the business and government sector. Code must also live here, too, because that’s how code makes money. In talking about the chasm between the two worlds and why they don’t understand each other, we will start with the very first computer bug and end up in the guts of the mainframes that are processing your credit card payments this very second.

Slashdot asserts that Grace Hopper was the grandmother of COBOL, but actually, she was more of the midwife, having served as a technical consultant to the committee that designed COBOL. Grace Hopper is such a legendary figure as the hacker’s own Rosie the Riveter that there’s a few myths about her. For instance, yes, that’s her moth in the Smithsonian, but the word “bug” as in “mechanical malfunction” was well in use before Hopper’s time, and there’s no evidence that anybody referred to the moth-ectomy as “debugging.”

Hopper’s story also represents an aspect now lost to history. Today, it’s common to ask “Where are all the women in computing?” But up until the 1960s, computers were a female-dominated field! At the time, computers only crunched numbers and were bulky, awkward things that required lots of hands-on operation. This was seen at the time as “women’s work.” We’ll dive a little deeper into that history lesson some other time.

In any case, Hopper was an amazing mathematician and computer scientist, as well as having an accomplished military career and further work in the private sector with DEC. But when a Department of Defense committee designs a programming language, “amazing” is the last thing on their minds. They want it simple enough that a monkey could understand it (government and business sector standards being what they are), so robust it could survive the apocalypse, and as feature-poor as possible, so that fancy tricks don’t get in the way of its grubby primary job. COBOL was designed to fit that niche and it’s going to keep fitting it forever.

The present author just so happens to have won the jackpot on this topic: I worked at the central processing headquarters for $MULTINATIONAL_BANK_CORPORATION, one you’ve definitely heard of. During that time, my tasks involved the processing and transfer of payments, mostly by paper check, which were handled on huge special-designed machines with little human interaction. The department ate paper and digested it into data, which was then slinged about the global banking network. Here’s a sales video from an unrelated company just to give a close example.

It is a fact that legacy systems stick like glue in this industry. Now don’t worry, they still use new stuff too. They’ll order 10,000 units of this week’s shiny new computer, and then the engineers will set them up and plug them into the system right next to a Windows NT system… next to an Intel 486 running OS/2 Warp… next to some ancient beige horror with a monochrome Hercules monitor on a box with a turbo button and a key lock… next to a VAX mainframe… and so on down the history of computing museum, all of it working together in one big chugging pile. They’ll add new stuff all the time. But throw something away??? Are you crazy?

Banking is the purest Capitalistic business; it pretty much has to be. So when anything gets done the first time, it’s made from scratch with whatever parts they had at hand at the time, patched with duct tape and spit. Once it’s plugged in and you know what it does, you will get no second chance to build it better. It’s already become part of the system. Since the banking industry works against both negligence and fraud by having your name and ID# attached to everything you touch, nobody wants to be The Person Who Broke It, because when things break, billions of dollars disappear and all anybody cares about is who’s to blame.

So yes, theoretically, you could test out a new replacement part before going live… except there is no test version of the whole big system, no comparable simulation of it, because all of it was built from scratch with whatever parts they had at hand at the time… Field service contracts last for generations in this industry. Everything gets fixed with a hot patch of the first crufty solution that came to mind for whoever was stuck fixing it. Code review, ha ha, what’s that?

Ever since Y2K (which was pinned entirely too much on COBOL), the tech industry has been indignantly waiting for the financial sector to wake up and smell the modern coffee. But I’ve just pointed out why that’s not happening. Sure, you can be the pioneer who brings the light of Ruby On Rails to the dusty banking world, but when you do, the machine your code is running on will just be cabled over to the same old machine running COBOL.

OK, maybe it’s not that happening! But it is true that there’s a layer of COBOL under just about every part of our infrastructure.

COBOL is like a diaper. It is a clumsy, inefficient, ad-hoc solution to a practical, immediate problem which everybody wants solved right away without thinking about it too hard. It’s easy to teach and easy to learn, and most especially easy for middle managers to read. It’s severely limited, but that’s OK because all it has to do is push numbers around.

Oh, if you learn COBOL, you’ll have a job for life alright. But maintaining decades of legacy COBOL code will be a test of your sanity like no other, fishing through years of poorly documented hacks one on top of the other. Your morale and job satisfaction will be a hollow memory of your old dreams. Welcome to Capitalism!|||

Slashdot recently asked: "Should Banks Let Ancient Programming Language COBOL Die?”