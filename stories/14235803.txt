Although the official documentation for Python 3 discourages writing code for both Python 2 and Python 3, in some cases it is desirable. Especially if you can drop support for Python 2.5 and earlier, since Python 2.6 introduces quite a lot of forwards compatibility.

It’s possible to make the same code run under earlier versions of Python as well, but then you start getting into the “contorted” writing style the Python 3 documentation mentions. I’ll take up tricks to do this and the module I mention at the end of this chapter will help a lot. It has been done even for some quite big projects, but I would in general not recommend it for a large project. For small projects or parts of bigger projects, for example bootstrapping scripts, supporting old versions of Python without using is often the best solution.

Python 2.7 has some small improvements on Python 3 compatibility, but it’s likely that if you want to run the same code under both Python 2 and Python 3 you will have to support Python 2.6 for some time to come.

Many of the changes you need will be done by , so to start converting your code you actually want to first run on your code and make your code run under Python 3. It is generally easier, or at least less monotonous, to introduce Python 2 compatibility in Python 3 code, than to introduce Python 3 compatibility in Python 2 code.

Once you have the project running under Python 3, try to run it under Python 2.6. At this stage you may run into syntax errors. They should come from only changes in the statement. Once you have fixed them you can fix the remaining errors and then lastly you do the same for earlier versions of Python, if you need to support them as well.

One of the major causes of syntax errors is the change of from a statement to a function. The simple cases are not problematic, you can simply put parentheses around the text that should be printed. The following will print exactly the same in all versions of Python: "This works in all versions of Python!" This works in all versions of Python! However, if you use any more advanced feature of you either end up with a syntax error or not printing what you intended. Python 2’s trailing comma has in Python 3 become a parameter, so if you use trailing commas to avoid the newline after a print, this will in Python 3 look like which is a syntax error under Python 2. Under Python 2.6 there is a import to make into a function. So to avoid any syntax errors and other differences you should start any file where you use with . The import only works under Python 2.6 and later, so for Python 2.5 and earlier you have two options. You can either convert the more complex to something simpler, or you can use a separate print function that works under both Python 2 and Python 3. Writing your own print function sounds more complicated than it is. The trick is to use and formatting according to the parameters passed in to the function. However, it is even easier to use the function from the module that I will present at the end of this chapter.

If you in your exception handling need access to the exception itself you need to use an exception variable. In Python 2 the syntax for this is: integer division or modulo by zero However, this syntax is confusing when you need to catch more than one exception. You need to have parentheses around the list of exceptions: "You can't divide by zero or by strings!" You can't divide by zero or by strings! If you forget the parentheses only is caught and the raised exception will be stored in a variable named . That’s not what you expect. Therefore, in Python 3, the syntax has changed to use instead of a comma, which avoids this mistake. It will also give you a syntax error if you do not have parentheses when catching more than one exception: The above syntax also works in Python 2.6 where both the old syntax with a comma and the new syntax using works. If you need to support Python versions lower than Python 2.6 and you need access to the exception that was raised, you can get that in all versions through the function: Another difference is that Exceptions are no longer iterable. In Python 2 the arguments to the exception was available by iterating over the exception or subscripting the exception. integer division or modulo by zero integer division or modulo by zero In Python 3 you need to use the exception attribute instead: A attribute was added to the built-in exceptions in Python 2.5. It was however deprecated already in Python 2.6 and removed in Python 3. Python 2.6 and Python 2.7 will warn you about this when using the flag.

One of the big changes is the reorganization of the standard library and as a result the typical errors you will get at this stage are mostly import errors. Getting around it is very easy. You simply try to import from the Python 3 locations and if that fails you import from the Python 2 locations. For modules that have been renamed, you can just import them as the new name. Some of the new modules are mergers of several old modules and in that case the above will not work if you need things from several of the old modules. You can also not do this with modules that have sub-modules. is a syntax error. The and modules have not only been merged, but reorganized into several sub-modules. So there you need to import each name you use separately. This often means you need to make changes to your code as well. In Python 2 retrieving a web page looks like this: After conversion with it will look like this: Yes, urllib.parse will be imported twice and urllib.error imported even though it isn’t used. That’s how this fixer does it and solving that would be a lot of extra effort, so it imports more than is needed. We need to fix up the code to import the names we use directly instead of the modules they are located in, so the version that runs under both Python 2 and Python 3 ends up like this:

There are two big changes in integer handling in Python 3. The first one is that the and the types have been merged. That means that you can’t specify that an integer should be long by adding the suffix any more. is a syntax error in Python 3. If you have to have an integer being a in Python 2 and still be compatible with Python 3, the following code will solve it. It defines up a variable to be the same as the class under Python 3, and it can then be used explicitly to make sure the integer is a . Another change is that the syntax for octal literals has changed. In Python 2 any number starting with a is an octal, which can be confusing if you decide to format your numbers by starting them with zeros. In Python 3 the syntax has instead changed to the less confusing , similar to used for hex numbers. Starting numbers with is a syntax error to prevent you from trying the old octal syntax by mistake. Octal is used almost exclusively when setting permissions under Unix, but that in turn is quite a common task. There is an easy way that works under both Python 2 and Python 3: Use the decimal or hex value and put the octal value in a comment:

It’s no surprise that the trickiest issue we have in supporting Python 2 and Python 3 without is handling binary data, just as it is when using . When we choose not to use the problem is made more tricky by making Unicode an issue as well. When using to support Python 2 and Python 3, will convert any Unicode literals to straight string literals. Without we have no such luxury and since the Unicode literal is gone in Python 3 we need to find a way to say that we want a Unicode string that works in all versions of Python. Here, only supporting Python 3.3 will make things much easier for you, because in Python 3.3, the literal is back! In that case you can mostly ignore this section. But if you need to support Python 3.1 or 3.2, the best way to do this is to make a Unicode string maker function just like the function in Common migration problems but for Unicode strings instead of binary . The natural name for this function is of course . We would then use instead of the literal, and instead of the literal. This will return a unicode object in Python 2: While it will return a string object in Python 3: Here I use the encoding, because other encodings could fail if you save the file with a different encoding than the one specified in the function. Using is a bit more work that just typing in the characters and saving the file but it will be work on different versions of Python as well as different operating system platforms. The encoding will convert all the various ways of entering unicode characters. The syntax, the and even the syntax: If you only need to support Python 2.6 or later there is also . This will turn all string literals in the file into Unicode literals: Both with the import and the function the the binary data type is still called and the text type is still called under Python 2, while under Python 3 they are called and . The best way around this is to define two variables; and , depending on Python version and then we test against that variable. For the handling of binary data you can use the same techniques as discussed in Common migration problems.

Two times three is “six”¶ There are many many more unusual and sometimes subtle differences between Python 2 and Python 3. Although the techniques mentioned here works for most of them, I definitely recommend you to look at Benjamin Petersons module “six” It contains a constant to use when checking for the version of Python, and it contains the above mentioned and functions, although the function doesn’t specify an encoding, so you are restricted to using ASCII characters. It also has many helpful constants like and and a function that works both under Python 2 and Python 3. It also contains imports of much of the reorganized standard library, so instead of the construct from the beginning of this chapter you can import the module from the six module instead. However it notably doesn’t support the reorganization of the urllib and urllib2 modules, so there you still need to use the import technique. The six module even contains helpers for unusual problems, like using metaclasses and the attributes of functions, which also have been renamed. Although it requires Python 2.4 or later you can use many of the techniques in it even under earlier versions of Python, if you need to support them. If you are attempting to support Python 2 and Python 3 without conversion you will definitely find it very helpful.|||

