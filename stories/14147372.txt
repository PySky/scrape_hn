Most of the mach traps are fast-paths for kernel APIs that are also exposed via the standard MACH MIG kernel apis. For example is also a MIG RPC which can be called on a task port.

Mach traps provide a faster interface to these kernel functions by avoiding the serialization and deserialization overheads involved in calling kernel MIG APIs. But without that autogenerated code complex mach traps often have to do lots of manual argument parsing which is tricky to get right.

In iOS 10 a new entry appeared in the

The mach trap entry code will pack the arguments passed to that trap by userspace into this structure:

A pointer to that structure will then be passed to the trap implementation as the first argument. It’s worth noting at this point that adding a new syscall like this means it can be called from every sandboxed process on the system. Up until you reach a mandatory access control hook (and there are none here) the sandbox provides no protection.

on Linux. This copies 4 bytes from the userspace pointer variable on the kernel stack, ensuring that the whole source range really is in userspace and returning an error code if the source range either wasn’t completely mapped or pointed to kernel memory. The attacker now controls

has to be less than or equal to

looks up the mach port name in the calling task’s mach port namespace and checks whether it names an object, returning a reference to the voucher if it does. So we need to provide a valid voucher port as

/* keep small recipes on the stack for speed */

was less than (256) then this allocates a small variable-length-array on the kernel stack and copies in bytes from the userspace pointer in to that VLA. The code then calls the target (which takes its kernel and userspace arguments the other way round to ) to copy the results back to userspace. All looks okay, so let’s take a look at what happens if was too big to let the recipe be “kept on the stack for speed”:

The code continues on but let’s stop here and look really carefully at that snippet. It calls -byte sized allocation on the kernel heap and assigns the address of that allocation to

If you didn’t spot the bug yet, go back up to the start of the code snippets and read through them again. This is a case of a bug that’s so completely wrong that at first glance it actually looks correct!

To explain the bug it’s worth donning our detective hat and trying to work out what happened to cause such code to be written. This is just conjecture but I think it’s quite plausible.

Right above the method in mach_kernelrpc.c there’s the code for

These two functions look very similar. They both have a branch for a small and large input size, with the same /* keep small recipes on the stack for speed */ comment in the small path and they both make a kernel heap allocation in the large path.

It’s pretty clear that the code for has been copy-pasted from then updated to reflect the subtle difference in their prototypes. That difference is that the size argument to is an integer but the size argument to

requires an extra level of indirection; it first needs to the size before it can use it. Even more confusingly the size argument in the original function was called and in the newer function it’s called

Here’s the relevant code from the two functions, the first snippet is fine and the second has the bug:

error: no member named 'recipes_size' in 'struct mach_voucher_extract_attr_recipe_args'; did you mean 'recipe_size'?

Clang assumes that the developer has made a typo and typed an extra ‘s’. Clang doesn’t realize that its suggestion is semantically totally wrong and will introduce a critical memory corruption issue. I think that the developer took clang’s suggestion, removed the ‘s’, rebuilt and the code compiled without errors.

on iOS will fail if the size argument is greater than 0x4000000. Since also needs to be a valid userspace pointer this means we have to be able to map an address that low. From a 64-bit iOS app we can do this by giving the linker option a small value. We can completely control the size of the copy by ensuring that our data is aligned right up to the end of a page and then unmapping the page after it. will fault when the copy reaches unmapped source page and stop.

fails the kalloced buffer will be immediately freed.

Putting all the bits together we can make a kalloc heap allocation of between 256 and 5120 bytes and overflow out of it as much as we want with completely controlled data.

When I’m working on a new exploit I spend a lot of time looking for new primitives; for example objects  allocated on the heap which if I could overflow into it I could cause a chain of interesting things to happen. Generally means if I corrupt it I can use it to build a better primitive. Usually my end goal is to chain these primitives to get an arbitrary, repeatable and reliable memory read/write.

To this end one style of object I’m always on the lookout for is something that contains a length or size field which can be corrupted without having to fully corrupt any pointers. This is usually an interesting target and warrants further investigation.

For anyone who has ever written a browser exploit this will be a familiar construct!

Reading through the XNU code for interesting looking primitives I came across

This is a structure which has a size field that can be corrupted without needing to know any pointer values. How is the

Looking for cross references to in the code we can see it’s only used in a handful of places:

back to the correct kalloc zone. The zone allocator will detect frees to the wrong zone and panic so we’ll have to be careful that we don’t free a corrupted without first fixing up the size.

This macro is used to set the

This macro uses the

That macro is using the field such that the message is aligned to the end of the buffer; this could be interesting.

field to ensure that there’s enough space in the

It looks like if we corrupt the field we’ll be able to make the kernel believe that a message buffer is bigger than it really is which will almost certainly lead to message contents being written out of bounds. But haven’t we just turned a kernel heap overflow into... another kernel heap overflow? The difference this time is that a corrupted might also let me memory out of bounds. This is why corrupting the field could be an interesting thing to investigate.

structures are used to hold in-transit mach messages. When userspace sends a mach message we end up in . If the message is small (less than ) then the code will first look in a cpu-local cache for recently freed structures. If none are found it will allocate a new cacheable message from the dedicated

Larger messages bypass this cache are are directly allocated by , the general purpose kernel heap allocator. After allocating the buffer the structure is immediately initialized using the two macros we saw:

Unless we’re able to corrupt the field in between those two macros the most we’d be able to do is cause the message to be freed to the wrong zone and immediately panic. Not so useful.

is called in one other place:

This function is only used when the kernel sends a real mach message; it’s not used for sending replies to kernel MIG apis for example. The function’s comment explains more:

method from userspace we can allocate a new mach port which has a single preallocated buffer of a controlled size. The intended use-case is to allow userspace to receive critical messages without the kernel having to make a heap allocation. Each time the kernel sends a real mach message it first checks whether the port has one of these preallocated buffers and it’s not currently in-use. We then reach the following code (I’ve removed the locking and 32-bit only code for brevity):

This code checks whether the message would fit (trusting ), marks the preallocated buffer as in-use, calls the such that the message will align to the end the of the buffer and finally calls to copy the message into the

This means that if we can corrupt the and make it appear larger than it is then when the kernel sends a message it will write the message contents off the end of the preallocate message buffer.

is also used in the mach message receive path, so when we dequeue the message it will also read out of bounds. If we could replace whatever was originally after the message buffer with data we want to read we could then read it back as part of the contents of the message.

This new primitive we’re building is more powerful in another way: if we get this right we’ll be able to read and write out of bounds in a repeatable, controlled way without having to trigger a bug each time.

There’s one difficulty with preallocated messages: because they’re only used when the kernel send a message to us we can’t just send a message with controlled data and get it to use the preallocated . Instead we need to persuade the kernel to send us a message with data we control, this is much harder!

There are only and handful of places where the kernel actually sends userspace a mach message. There are various types of notification messages like IODataQueue data-available notifications, IOServiceUserNotifications and no-senders notifications. These usually only contains a small amount of user-controlled data. The only message types sent by the kernel which seem to contain a decent amount of user-controlled data are exception messages.

When a thread faults (for example by accessing unallocated memory or calling a software breakpoint instruction) the kernel will send an exception message to the thread’s registered exception handler port.

If a thread doesn’t have an exception handler port the kernel will try to send the message to the task’s exception handler port and if that also fails the exception message will be delivered to to global host exception port. A thread can normally set its own exception port but setting the host exception port is a privileged action.

This is the MIG definition for should be a send right to the new exception port. lets us restrict the types of exceptions we want to handle. defines what type of exception message we want to receive and lets us specify what kind of process state we want to be included in the message.

means that the kernel will send an message to the exception port we specify whenever the specified thread faults. That message will contain the state of all the ARM64 general purposes registers, and that’s what we’ll use to get controlled data written off the end of the

In our iOS XCode project we can added a new assembly file and define a function

This function takes a pointer to a 240 byte buffer as the first argument then assigns each of the first 30 ARM64 general-purposes registers values from that buffer such that when it triggers a software interrupt via and the kernel sends an exception message that message contains the bytes from the input buffer in the same order.

We’ve now got a way to get controlled data in a message which will be sent to a preallocated port, but what value should we overwrite the with to get the controlled portion of the message to overlap with the start of the following heap object? It’s possible to determine this statically, but it would be much easier if we could just use a kernel debugger and take a look at what happens. However iOS only runs on very locked-down hardware with no supported way to do kernel debugging.

I’m going to build my own kernel debugger (with printfs and hexdumps)

A proper debugger has two main features: breakpoints and memory peek/poke. Implementing breakpoints is a lot of work but we can still build a meaningful kernel debugging environment just using kernel memory access.

The first version of this new exploit was developed inside the mach_portal xcode project so I could reuse all the code. After everything was working I ported it from iOS 10.1.1 to iOS 10.2.

Inside mach_portal I was able to find the address of an preallocated port buffer like this:

was part of the mach_portal exploit and is defined like this:

These code snippets are using the function provided by the mach_portal exploit which reads kernel memory via the kernel task port.

I used this method with some trial and error to determine the correct value to overwrite to be able to align the controlled portion of an exception message with the start of the next heap object.

The final piece of the puzzle is the ability know where controlled data is; rather than write-what-where we want to get where what is.

One way to achieve this in the context of a local privilege escalation exploit is to place this kind of data in userspace but hardware mitigations like SMAP on x86 and the AMCC hardware on iPhone 7 make this harder. Therefore we’ll construct a new primitive to find out where our

Whilst experimenting with the heap behaviour using the introspection techniques described above I noticed that some size classes would actually still give you close to linear allocation behavior (later allocations are contiguous.) It turns out this is due to the lower-level allocator which zalloc gets pages from; by exhausting a particular zone we can force zalloc to fetch new pages and if our allocation size is close to the page size we’ll just get that page back immediately.

This means we can use code like this:

// these will be contiguous now, convenient!

to get a heap layout like this:

This is not completely reliable; for devices with more RAM you’ll need to increase the iteration count for the zone exhaustion loop. It’s not a perfect technique but works perfectly well enough for a research tool.

We can now free the holder port; trigger the overflow which will reuse the slot where holder was and overflow into then grab the slot again with another holder port:

// reallocate the holder and overflow out of it

The overflow has changed the field of the preallocated ipc_kmsg belonging to first port to

structure has been filled in by it will be enqueued into the target port’s queue of pending messages by

If the port has pending messages the form a doubly-linked list of pending messages. But if the port has no pending messages then are both set to point back to itself. The following interleaving of messages sends and receives will allow us use this fact to read back the address of the second

// send a message to the second port

// writing a pointer to itself in the prealloc buffer

// receive on the first port, reading the header of the second:

// this is the address of second port

// start a new thread passing it the buffer and the exception port

// associate the pthread_t with the port

// so that we can join the correct pthread

// when we receive the exception message and it exits:

// wait until the message has actually been sent:

Remember that to get the controlled data into port’s preallocated we need the kernel to send the exception message to it, so actually has to cause that exception. It allocates a which contains a copy of the controlled data we want in the message and the target port then it starts a new thread which will call

copies the controlled data from the structure to a local buffer then sets the target port as this thread’s exception handler. It frees the arguments structure then calls which is the assembler stub that copies the buffer into the first 30 ARM64 general purpose registers and triggers a software breakpoint.

At this point the kernel’s interrupt handler will call which will look up the thread’s exception port and call the method which will serialize the crashing thread’s register state into a which will grab the exception port’s preallocated field and use it to align the sent message to what it believes to be the end of the buffer:

In order to actually read data back we need to receive the exception message. In this case we got the kernel to send a message to the first port which had the effect of writing a valid header over the second port. Why use a memory corruption primitive to overwrite the next message’s header with the same data it already contains?

Note that if we just send the message and immediately receive it we’ll read back what we wrote. In order to read back something interesting we have to change what’s there. We can do that by sending a message to the second port after we’ve sent the message to the first port but before we’ve received it.

We observed before that if a port’s message queue is empty when a message is enqueued the field will point back to the message itself. So by sending a message to (overwriting it’s header with one what makes the still be valid and unused) then reading back the message sent to first port we can determine the address of the second port’s

We’ve turned our single heap overflow into the ability to reliably overwrite and read back the contents of a 240 byte region after the object as often as we want. We also know where that region is in the kernel’s virtual address space. The final step is to turn that into the ability to read and write arbitrary kernel memory.

Whoever developed that exploit had found that the IOKit method is a very neat gadget that lets you turn the ability to call a function with one argument that points to controlled data into the ability to call another controlled function with two completely controlled arguments.

In order to use this we need to be able to call a controlled address passing a pointer to controlled data. We also need to know the address of

and reallocate an IOKit userclient there:

// send another message on first

// free second and get it reallocated as a userclient:

// read back the start of the userclient buffer:

// this is the vtable for AGXCommandQueue

which is an bytes so it will also use the zone and reuse the memory just freed by the

Note that we sent another message with a valid header to ’s header with a valid header. This is so that after is freed and the memory reused for the user client we can dequeue the message from and read back the first 240 bytes of the object. The first qword is a pointer to the ’s vtable, using this we can determine the KASLR slide thus work out the address of

Calling any IOKit MIG method on the userclient will likely result in at least three virtual calls: will be called by for the userclient port. This method also calls

Since these are all C++ virtual methods they will pass the this pointer as the first (implicit) argument meaning that we should be able to fulfil the requirement to be able to use the gadget. Let’s look more closely at exactly how that works:

It’s clearer what’s going on if we look as the disassembly of

LDP  X1, X3, [X0,#0x18] ; load X1 from [X0+0x18] and X3 from [X0+0x20]

Since we have read/write access to the first 240 bytes of the userclient and we know where it is in memory we can replace it with the following fake object which will turn a virtual call to into a call to an arbitrary function pointer with two controlled arguments:

We’ve redirected the vtable pointer to point back to this object so we can interleave the vtable entries we need along with the data. We now just need one more primitive on top of this to turn an arbitrary function call with two controlled arguments into an arbitrary memory read/write.

are the obvious candidates as they will handle any complexities involved in copying across the user/kernel boundary but they both take three arguments: source, destination and size and we can only completely control two.

However since we already have the ability to read and write this fake object from userspace we can actually just copy values to and from this kernel buffer rather than having to copy to and from userspace directly. This means we can expand our search to any memory copying functions like memcpy. Of course memcpy, memmove and bcopy all also take three arguments so what we need is a wrapper around one of those which passes a fixed size.

Looking through the cross-references to those functions we find

This function is just simple wrapper around memmove which always passes a fixed size of 16-bytes. Let’s integrate that final primitive into the serializer gadget:

To make the read into a write we just swap the order of the arguments to copy from an arbitrary address into our fake userclient object then receive the exception message to read the read data.

Every developer makes mistakes and they’re a natural part of the software development process (especially when the compiler is egging you on!). However, brand new kernel code on the 1B+ devices running XNU deserves special attention. In my opinion this bug was a clear failure of the code review processes in place at Apple and I hope bugs and writeups like these are taken seriously and some lessons are learnt from them.

Perhaps most importantly: I think this bug would have been caught in development if the code had any tests. As well as having a critical security bug the code just doesn’t work at all for a recipe with a size greater than 256. On MacOS such a test would immediately kernel panic. I find it consistently surprising that the coding standards for such critical codebases don’t enforce the development of even basic regression tests.|||

