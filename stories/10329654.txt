It depends on where you are. Also, the average salary of functional programming engineers isthan the industry average. What is true, however, is that such engineers earn less than equivalently-capable engineers in the unloved, traditional languages (C++, Java, VB). An average Clojure engineer outearns anJava engineer, but the average Clojure engineer would be 95th-percentile (at least) among corporate Java engineers, and is only getting "short-changed" relative to that standard. This is because the 95th-percentile Java engineer is being offered management every time he takes a piss.I bash this topic to death in this essay:. To be fair, "can't make any money" is being used in a "first-world problems" sense of it. I mean that we can't make any money by MBA/manager standards. You can do fine slinging Haskell, but you won't be flying first class on your annual family vacation.However, what I also think is at play is this: most of the highest-paying software jobs ($200,000 and up) involve management or large-program architectural responsibilities. MBAs aren't comfortable paying more that kind of money to an individual contributor until they're over a barrel (and shelling out $500/hour for a consultant, whose job is usually to salvage borked legacy code, and that kind of work will also not be in Haskell or Clojure).A team of 5 Haskell developers can outcode 75 CommodityJavaGrunts, but from an MBA perspective, the manager of the latter, larger, team is more impressive and will justify higher pay. If the only thing you want to do is make money in software, the best strategy seems to be to learn the. While that political game is soul-deadening and most would prefer programming, playing it is just slightly more fun than dealing with borked legacy code (which is what happens to you if you fail, politically, in a typical corporate job.)|||

