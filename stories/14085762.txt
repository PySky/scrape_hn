Being Java nerds, we are always interested in obscure details that may not be of direct use but teach us more about Java and the JVM. That’s why I decided to publish this great article that Lukas Eder originally wrote on jooq.org.

So, you’ve been working with Java since the very beginning? Remember the days when it was called “Oak”, when OO was still a hot topic, when C++ folks thought that Java had no chance, when Applets were still a thing?

I bet that you didn’t know at least half of the following things. Let’s start this week with some great surprises about the inner workings of Java.

That’s right! The JVM doesn’t know any such thing, only the Java language does.

Today, everyone agrees that checked exceptions were a mistake. As Bruce Eckel said on his closing keynote at GeeCON, Prague, no other language after Java has engaged in using checked exceptions, and even Java 8 does no longer embrace them in the new Streams API (which can actually be a bit of a pain, when your lambdas use IO or JDBC).

Do you want proof that the JVM doesn’t know such a thing? Try the following code:

Not only does this compile, this also actually throws the , you don’t even need Lombok’s for that.

More details about the above can be found in this article here, or here, on Stack Overflow.

Right. The Java language doesn’t allow for two methods to be “override-equivalent” within the same class, regardless of their potentially differing clauses or types.

But wait a second. Check out the Javadoc of . It reads:

Wow, yes that makes sense. In fact, that’s pretty much what happens when you write the following:

Check out the generated byte code in :

So, is really just in byte code. That’s well understood.

The synthetic bridge method is actually generated by the compiler because the return type of the signature may be expected to at certain call sites. Adding generics without such bridge methods would not have been possible in a binary compatible way. So, changing the JVM to allow for this feature was the lesser pain (which also allows covariant overriding as a side-effect…) Clever, huh?

Are you into language specifics and internals? Then find some more very interesting details here.

Yes, it’s true. Even if your mental parser might not immediately understand the return type of the above methods, they are all the same! Similar to the following piece of code:

You think that’s crazy? Imagine using JSR-308 / Java 8 type annotations on the above. The number of syntactic possibilities explodes!

Or in other words:

I let the actual exercise of finding a use-case for any of the above to you.

So, you thought you knew it all when it comes to using the conditional expression? Let me tell you, you didn’t. Most of you will think that the below two snippets are equivalent:

… the same as this?

Yep! The conditional operator will implement numeric type promotion, if “needed”, with a very very very strong set of quotation marks on that “needed”. Because, would you expect this programme to throw a ?

More information about the above can be found here.

Quirky enough? Let’s consider the following two pieces of code:

Intuitively, they should be equivalent, right? But guess what. They aren’t! The JLS specifies:

This is so beautiful, I would like to cite Peter Lawrey‘s answer to this Stack Overflow question:

Now, how incredibly useful is that? I’m going to cast/multiply chars right there in my application. Because, you know…

Now, this is more of a puzzler. Don’t read the solution yet. See if you can find this one out yourself. When I run the following programme:

… then “sometimes”, I get the following output:

How is that even possible??

OK, the solution is here (https://blog.jooq.org/2013/10/17/add-some-entropy-to-your-jvm/) and has to do with overriding the JDK’s cache via reflection, and then using auto-boxing and auto-unboxing. Don’t do this at home! Or in other words, let’s think about it this way, once more

This is one of my favourite. Java has GOTO! Type it…

This will result in:

This is because is an unused keyword, just in case…

But that’s not the exciting part. The exciting part is that you can actually implement goto with , and labelled blocks:

In other languages (e.g. Ceylon), we can define type aliases very easily:

A type constructed in such a way can then be used interchangably with :

In Java, we can’t define type aliases at a top level. But we can do so for the scope of a class, or a method. Let’s consider that we’re unhappy with the namings of , etc, we want shorter names: and . Easy:

In the above programme, is “aliased” to for the scope of the class, whereas is “aliased” to for the scope of the method. We can then call the above method like this:

This technique is of course not to be taken seriously. In this case, and are both final types, which means that the types and are effectively aliases (almost. assignment-compatibility only goes one way). If we had used non-final types (e.g. ), then we’d be really using ordinary generics.

Enough of these silly tricks. Now for something truly remarkable!

OK, this will now get really funky, so take a cup of coffee and concentrate. Consider the following two types:

Now, what do the types and even mean?

They are somewhat recursive, in a similar (yet subtly different) way that is recursive. Consider:

With the above specification, an actual implementation is just mere syntactic sugar:

With this in mind, let’s get back to our two types. Does the following compile?

Hard question, and Ross Tate has an answer to it. The question is in fact undecidable:

Is C a subtype of Type<? super C>?

Try compiling the above in your Eclipse, it’ll crash! (don’t worry. I’ve filed a bug)

If you’re interested in more details about this peculiar Java quirk, read Ross Tate’s paper “Taming Wildcards in Java’s Type System” (co-authored with Alan Leung and Sorin Lerner), or also our own musings on correlating subtype polymorphism with generic polymorphism

Java has a very peculiar feature called type intersections. You can declare a (generic) type that is in fact the intersection of two types. For instance:

The generic type parameter that you’re binding to instances of the class must implement both and . For instance, is not a possible bound, but is:

This feature has seen reuse in Java 8, where you can now cast types to ad-hoc type intersections. How is this useful? Almost not at all, but if you want to coerce a lambda expression into such a type, there’s no other way. Let’s assume you have this crazy type constraint on your method:

You want a that is also just in case you’d like to execute it somewhere else and send it over the wire. Lambdas and serialisation are a bit of a quirk.

But even if that’s true, they do not automatically implement the marker interface. To coerce them to that type, you must cast. But when you cast only to …

… then the lambda will no longer be Runnable.

Cast it to both types:

I usually say this only about SQL, but it’s about time to conclude an article with the following:|||

Learn more about Java and the JVM: 10 obscure details you didn't know they could do. Did you know, for example, that checked exceptions are a fiction?