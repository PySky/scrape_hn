This project is aimed to help the user further study LINQ with a test-driven approach. Each unit contains an annotated tutorial and a platform where you can test your understanding of the topic.

- Adds query capabilities to the language syntax of C#. - LINQ introduces standard, easy to learn patterns for querying and updating data, which can be extended to support potentially any kind of data store. - There are two ways of writing LINQ Queries: - Uses the declarative form to invoke the LINQ Operators [TestMethod] () { = ProgrammingLanguageRepository.GetProgrammingLanguages(); // A query expression operates on one or more data sources by applying one or more query operators // The syntax contains SQL-like operators: 'from', 'where', and 'select' // from: defines the source of the data // programmingLanguages: defines the data source (it must implement IEnumerable) // where: it is used to define the filter // select: projects each element of the resulting sequence into a new form = programmingLanguage programmingLanguages programmingLanguage.Name == ; // The First() method returns the first element of the sequence = query.First(); - LINQ uses deferred execution, this means that the 'query' statement only defines the LINQ statement - The LINQ query is not executed until its result is required - Calling an operator on the query will cause the query to execute. In this case, it is the First() method. Assert.IsNotNull(csharp); Assert.IsTrue(csharp.Name == ); } [TestMethod] () { = ProgrammingLanguageRepository.GetProgrammingLanguages(); // The extension methods extend any Type that implements the IEnumerable interface - Returns the first element of the sequence - The First() method will throw an exception if no match is found The First() method has two overloads: - The first overload method passes no parameters and returns the first element of a sequence - The second overload allows defining criteria, it returns the first element in a sequence that satisfies a specific condition // It is an in-line(defined in the extension method parameter) anonymous function // programmingLanguage: represents the parameter. In other words, it represents each programming language as the sequence is iterated // => : represents the Lambda operator, it separates the parameters from the expression itself // programmingLanguage.Name == "C#": represents the body of the function // when the condition is met, the Lambda fuction returns 'true' and 'First()' returns the object = programmingLanguages.First(programmingLanguage => programmingLanguage.Name == ); Assert.IsNotNull(csharp); Assert.IsTrue(csharp.Name == ); } [TestMethod] () { = ProgrammingLanguageRepository.GetProgrammingLanguages(); // Finds the first entry on the list, but if no entry is found, it returns the default value of the list object, which in most reference Types is 'null' = programmingLanguages.FirstOrDefault(programmingLanguage => programmingLanguage.Name == ); Assert.IsNull(cplusplus); } [TestMethod] () { = ProgrammingLanguageRepository.GetProgrammingLanguages(); // Where is the extension method that is used to find multiple entries // It also recieves a Lambda expression as a parameter = programmingLanguages.Where( // It is a good practice to cache the query result by simply adding a ToList() or ToArray() after LINQ so that the query result is saved(cached) // Otherwise, you will enumerate the collection every time you execute a LINQ statement on 'programmingLanguages' programmingLanguage => programmingLanguage.Name == || programmingLanguage.Name == ).ToList(); Assert.AreEqual(foundLanguages.First().Name, ); // Chaining: Extension methods can be chained together // Skip() - allows to fluently(via chaining) skip one entry Assert.AreEqual(foundLanguages.Skip( ).First().Name, ); }|||

LINQ: Test-Driven Learning