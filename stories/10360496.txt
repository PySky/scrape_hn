If you can’t explain something to a six-year-old, you really don’t understand it yourself.

I just had lunch with a really smart person. There are people I’m lucky enough to spend time with who are really clever and others who are really talented but this guy is seriously smart.

Afterwards I was trying to work out just why this was the case. And then I realised it was because he was able to discuss non-trivial concepts in very simple terms and still convey his point. You and I might think of the differences between programming languages in terms of syntax, or perhaps style, but he started explaining them in terms of a Lego set; a Lego pirate ship and a Lego medieval castle are quite different to eachother but they’re ultimately built from the same little blocks. Obviously after this he related the Lego to his recent research into the applicability of using functional programming concepts when running multi-threaded processes on Nvidia’s new GPU (I told you he was smart), but because by that point we’d discussed such a complex topic in such simple terms it really didn’t feel like we were doing a whole lot of heavy lifting in the cognitive department.

This got me thinking - we really need to be more that way in how we design our software. People are constantly having to pick up software designed by others and the concepts underlying it should be easy to understand. In the spirit of our opening misattributed quote from Einstein I have a pretty simple test which I run by myself when I’m writing code which goes something like this:

(you get to choose the drink here - I think Tequila should be the default, but hey, get creative).

Grandmas have a couple of characteristics going for them - they typically don’t know a whole lot about software design, and they can also see through bullshit. Because of this you’re forced to explain concepts to them in terms which are not only simple, but also honest. Doing some nasty nasty hack because you are so deep in technical debt that you can’t see straight and are cutting corners? Best of luck explaining that one. Overengineering the heck out of something for no particular reason? Not gonna fly with Gran.

I know this all sounds a bit crazy but I’m serious about this test. I really think you should be able to explain your design choices to someone who knows nothing about computers or code. If you can’t then you probably need to revisit what you’re doing and gain a better understanding of it.

So next time you’re thinking of making some crazy new hash-map-bag-tree-red-black-heap-treap data structure of your own which saves a couple of cycles which you probably will never need anyway - just don’t. (Unless you can explain pretty convincingly to your nan why you’re doing it that way).|||

