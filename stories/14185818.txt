The median U.S. worker is 42. However, StackOverflow’s survey on age shows that there are just about 13% of developers after 40. Where are the others? Were they fired or moved up to a managerial role? Is software development really a dead end job after 40? Let’s listen to the stories of top software developers after 40, 50 and 60 who turned down managerial positions and still practice programming for a living.

“I've been coding for a living for almost 16 years now. Spent several years as an independent contractor & at 42 I'm joining Netflix as a senior engineer.

A lot also depends on your attitude. Don't be the old guy who is down on any new technology and sneers at anyone that uses anything newer than Emacs and C++. Use your experience to make informed decisions about what technology choices to make. If that means sticking with older, proven technologies fine, but do it because it's the right choice not because you want to protect the rapidly obsoleting expertise you spent years building up or because you're scared of some snotty kid with his Node JS and his Go taking your job".

Specialties: Developing real-time embedded software, managing software configuration, building test suites (system and unit tests). Broad experience in writing and documenting software for embedded real-time systems, for Linux and for Windows including .NET. Proficient in C, C++, Python, C# and Pascal.

“I got a BSEE in electrical power systems in 1980 and have developed software for a living since I got my first job. Getting that job did take almost a year because I had the wrong degree. But ever since then, I have worked as a software engineer.

I write code on most days and I have absolutely no managerial tasks. In fact, I realized long ago that if I accepted such a role I would have reached my level of incompetence.

I have only two colleagues who are older than me, the rest (including the managers) are younger. My direct manager is in the lower forties and he is one of the best managers I have ever had. I was 58 when I applied for and got the job. And I didn't become the oldest employee - two of my new colleagues were older than me. They are both still employed in the company.

There are days or even weeks where you don't learn anything and there are hours where you learn more than enough to make for that "lost" time.  What is important is that you are always looking for chances to learn and are always ready to grab the opportunity when it comes up.”

"I like solving problems and (possibly, more importantly) I like finding new ways to solve problems. Because of that, I seem to have skills that are always in demand.

I keep reasonably up-to-date with the rest of the ecosystem - I've used IntelliJ and Eclipse and Sublime and Emacs and Vi over the years, and I'm comfortable with all of them for solving different problems.   I started with CVS, learned Subversion and more recently worked with git.  I've worked with AWS as well.  I've been a certified ScrumMaster, a product owner and a developer. I've written lots of automated unit tests (test-first development is one of my favorite intellectual challenges when I'm architecting and building a system).

I'm not afraid to pick something up, learn it, and put it away - I've written web apps in Ruby on Rails and Grails, and solved business problems with apps written in Perl, PHP and Python. I've worked with SOAP and AOP.

I try to be a full-stack developer - I understand UNIX well and regularly write shell scripts.  I'm comfortable with deploying apps, servers and tools, both for development and production purposes. I know SQL and NoSQL and understand when each is better. I'm comfortable with TCP/IP - I know the basics of routing & DHCP and various types of proxies. I've built MVC apps, message-based apps and EJB and Spring services.  I've worked with JavaScript and CSS on the front end.  I'm not ever going to be an award-winning UX developer, but I can at least get the basics done.

I'm planning on working for another 21 years.  If we switch away from web-based development to building everything with D-wave servers, I may get left behind.  If functional programming finally takes over, I may get left behind.  But until then, I'm going to continue to be hopeful".

"I started learning Engineering and then Computer Science on my way to becoming a lawyer (if you can imagine that).... Today, my bread-and-butter (these days anyways) is gotten by writing tons of (hopefully) well-documented and functional Java code.

My latest job is the very first one where I got to basically design the whole system from scratch.  I'm struggling a bit now to get back up to speed with web and mobile programming, but I'm far from a "dead end" so far, in spite of being 60. I have been offered "manager" jobs over the years and have consistently refused them, since I prefer to program over managing people.... But, I know colleagues who have been laid off, and are my age (or older) who are having trouble finding work ("too much experience"!?), so I see how you could get the impression that there is no future after a certain age. But, as others have noted, I think the key is to continue to provide VALUE for whoever you're working for.

 I'm currently the PMC Chair for the Apache Pivot project at the Apache Software Foundation. As a Java developer (and Apache committer working on Java-based projects). I hope Java NEVER goes away.  Or at least not until there is something better and I am given enough time to port all my code.... "

Specialties: Designing and implementing frameworks, parsers, modeling, graphics and database sub-systems, database design (SQL, DML, DDL, and LINQ), XML design, Single Sign-on (SSO), Internet applications, Windows applications, and animation.

“I have 34+ years as a programmer and my resume is one page. Everything older than about five years is succinctly summed up.  I have a second page that lists all of the languages I've used professionally as well as the development tools, databases, animation systems, etc. with which they can expect me to be familiar. I only provide this second page when asked.

In a large company (at least for me) it was common culture that as you got older as a programmer you would move into management.  The whole time I was there I was pushed to seek a management path, which a) I'm not good at, and b) I like being a programmer/architect/toolsmith.

I find that my memory just isn't as good as it once was and I can’t hold larger system models completely in my head anymore. However, in general, I find that my extensive experience tends to be more valuable and offsets the other.

You will need to be resigned to the fact that you will be in a constant state of training throughout your career, the state of the art just changes too quickly; if you rest on your laurels it will pass you by before you even notice it.

Specialities: proprietary filesystem/database internals, persistent data structures, directory and index search techniques, server administration, DASD I/O drivers, machine code generation/cross-architecture transcoding, object persistence, client-server interfaces, multi-tenancy, distributed caching, and large-scale authorization (enforcement, administration, and logging). Currently doing research, design and programming for the Cloud Analytics Services core engine for the new SAS Viya platform.

"The average age on my current team is 50 and everyone has been a “heavy” systems software developer for 20+ years.

Myself and software developers I work with spend most of our time coding, debugging, testing, and answering questions about the system architecture that we are responsible for. Some of us are also involved in evaluating hardware technologies, presenting at conferences, and also working with Open Source communities, etc.

For the past two years, I've been on one of the most elite teams in a software company that has a lot of really excellent software engineers, many with advanced degrees in computer science, applied math, etc.  Before that, I spent over a decade as one of the key members of another, smaller development team where we designed and programmed a multithreaded clustered metadata object server from the ground up.

My closest colleagues on that team are actually 5–6 years older than I am. I earned 4 US Patents during that time … all well after turning 40.

I doubt the technology that I work with today will see me to the end of my career if I plan to work till I'm 70. Since beginning my career in 1983, I have survived through four major computing paradigms:

Although I'm currently involved with 4 and it might get me to retirement, it is more likely that I will grow my expertise toward machine learning, in the coming years.

There is some likelihood that within 10 years there will be a lot less need for mediocre programmers. If a person really enjoys computer technology yet cannot seem to achieve good proficiency in programming, perhaps it's best to become a highly skilled system admin. There will probably always be some work in configuring, deploying, and maintaining systems".

Specialties: Embedded, multi-threading, multi-processing, drivers, communications stacks, C/C++, Java, Python, hardware specific. Software Architect/Engineer specializing in software very close to the hardware, particularly hardware under development. Works with hardware engineers to achieve maximum synergy between the two disciplines.

"While I am, at 62, the oldest developer in my company, there are plenty in their forties and early fifties.

I think my youngest colleague is in the late twenties, so about 35 years age difference is not a problem.

As to technology, take it as it comes. The world is very different today than from when I started (FORTRAN on punched tape), but the changes unrolled over time. On the other hand, the problems are much the same, how do I convert this human requirement into something a computer can do? And how do I avoid making mistakes, and then find the mistakes I inevitably make? Languages, development environments, toolkits, APIs etc. are just means to an end. You learn them when you need them.

I started out on paper tape. Even when we got disk files, it was still easiest to read programs on line printer printouts. Then I had plain text editors. Now I use syntax-aware IDE.

I do not think it is possible that software developers will not be needed in 10–20 years. I see a software developer as someone who takes a customer requirement and converts it into precise instructions for a computer. And that job is never going to go away. There will always be a need for people who understand, an order of magnitude better than the general public, what computers can and cannot do, and have a knowledge of a large number of tools (libraries, APIs, interfaces, whatever) which can be used to make that happen.

My field, Embedded, seems much more resilient to fads and fashions than application programming. The Applications world gets a New great Thing every few years. Some burn out almost immediately, some last better but still have peaks and then fade. Embedded is still soldiering on - C, with a sprinkling of C++. On the other hand, the hardware keeps changing, keeping up the interest".

Specialties: Programming in Python, Linux, C/C++, .NET. Database expertise in MS Access, MySQL and all SQL-based systems other environments, TCP/IP, enterprise system automation, and distributed computing. The publisher at LHPress.com having produced more than 100 books in print in the past 13 years.

"Architecture track is parallel to a management track. Companies with more than 250 developers will often have this alternate path to keep technical people interested.

 Do you enjoy what you do? Then keep doing it. A few extra dollars an hour to give up what you like in favor of becoming a meeting and email-jockey might make you even less satisfied than you are today.

Specialties: Windows, Linux/UNIX, embedded; algorithm design, C++, C, multi-threaded and distributed, telecom, security, sockets networking, standards committees, product planning and concept formation; TQM, ISO 9000, agile and traditional development methodologies.

"Software development is still a young field, so that tools and techniques are still changing very rapidly. A software developer who does not continuously learn new skills becomes obsolete in much less than 20 years, such that a 40-year old developer can easily find themselves out of work and with limited prospects.

The very best developers will keep on learning and achieving until they reach retirement age; your Ken Thompsons and your Bjarne Stroustrups. But most of us will eventually realize (typically around 40 years old) that we are not those famous giants of the industry.

Code is easy to work with. It does exactly what you tell it to. It is dependable and reliable. Code never has good days and bad days, but only the days you bring to your interaction with it. Code can be a harsh taskmaster, requiring great attention to detail and a degree of mental formality that is hard to sustain.

People are the polar opposite of code, slippery, infinitely variable, and ultimately, impossible to wield as tools. You don’t tell people what to do; you influence them so that they want to do what you need. People don’t respond directly to your input, but indirectly, to praise, and to a sense of accomplishment and belonging that you must provide. Although people are susceptible to reward and punishment, managing them through this means is not very effective. People can be managed casually, by the same comfortable interactions you have with family, friends, and peers. If you like people, you will like managing people. If you don’t like people, you will not be a successful manager.

The best paid manager makes more than the best paid programmer, but they also are ridiculous high achievers with multiple degrees from prestigious schools, carefully cultivated networks of useful friends and political allies, and a degree of ruthlessness to frighten most people. Coding doesn’t require ruthlessness. It’s one of the best things about coding. It’s creative, and not manipulative.

So you have to ask yourself, which kind of interaction do you prize, the certainty and inner beauty of code, or the camaraderie and leadership of people. It’s OK to like code. There are senior architects and CTOs too. You’ll make plenty".

Specialties: Object-Oriented Software Design, Test Driven Development (C, C++, Java, C#), Embedded Software, Refactoring, Extreme Programming, Scrum, Agile Development, Release Planning, Incremental Planning. One of the key contributors to the CppUTest test framework for unit testing C and C++. Speaks at the Embedded Systems Conferences and Agile Conferences. One of the original authors of the Agile Manifesto.

"Keep learning. I'm still programming at 62, and loving it.

I spent some time in management. It was very valuable to me. I also decided to stay on top of what I loved, programming and software design. Once I learned what I did from my time in management, I decided to go back to what I loved.

Getting stuff to work is great, but not good enough. You have to make the products and code you create have a long and useful life. You have to know how to work as part of a team. Just getting it to work is not enough for a long, fulfilling and profitable career".

The way to get startup ideas is not to try to think of startup ideas. It's to look for problems, preferably problems you have yourself. Solving the problem that frustrates you - may be one of the best ways of finding an idea for your startup. Look at these software developers who acted accordingly before they found success.|||

Is software development really a dead end job after 40? Let’s listen to the stories of top software developers after 40, 50 and 60 who turned down managerial positions and still practice programming for a living.