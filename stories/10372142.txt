Perl 6 is finally slated to be ready by Christmas 2015. However, it's worth bearing in mind that successful languages tend to take 2 to 3 years before they get widespread enough acceptance that getting paid to work with them is a serious possibility. So when you ask if you should be "interested" in the language, I have to ask what you mean by "interested." Since I can't know that, I'll just pitch a few things at you.In many programming languages, you have stuff like this (Perl 6 code) which people complain about on stackoverflow (In Perl 6, that will print "yes", but for most programming languages you're familiar with, that will probably print "no", even though "no" is clearly not the right answer. That's because floating point math creates approximations of numbers, but Perl 6 will generally default to rational numbers, giving you the exact answer and wiping out an entire class of errors.Or here's something which is a "divide by zero" exception in Perl 6 (as it should be), but not in most other languages:Or consider the recursive Fibonacci function. Recursive functions typically have three types of errorsHere's a recursive Perl 6 function which computes the "nth" Fibonacci number:I could make that cleaner still, but it's dead easy to understand (read "*" as "whatever I got") and it trivially avoids all three major failings we see in recursive functions.What if you want to haveof functions taking an integer which must be zero or greater? Make your own type on the fly:That's right: that's how easy it is to create your own types in Perl 6. Types which match whatneed, not what the computer needs. And yes, they can be much more complicated than the above, if need be.Or consider this beauty:Because a Num (a floating point number) isn't an Int, that will fail at compile-time. In a dynamic language! That's right: compile time type failures in a dynamic language.If you like dynamic languages and don't want type annotations, don't declare them. Declaring your types is. However, if you want to, you can add them later. This is calledand because Perl 6 has it baked into the language, it can optimize heavily on this, if present, something many other gradual type systems don't allow.Since concurrency is important, it's baked directly into Perl 6 at a far higher level of abstraction than threads or forks (they're discouraged, but you can use them, too).Â  See "" for some trivial examples. What this means is that Perl 6 stands a great chance of being thepopular dynamic language with a working concurrency model (of course, there are plenty of targets for "under the hood" concurrency for performance improvements, such as junctions, hyperoperators, native shaped arrays, and so on, but I digress).But wait, you say, I like objects! I'm object-oriented (OO) programmer! I want OO.That's fine. Perl 6 has what is possibly the richest, most powerful OO system you're going to find. For example, consider the following trivial class:That allows you to create a mutable X,Y point, with each point constrained from -10 to 10. In my "Perl 6 for Mere Mortals" talk, I show how to implement the above four lines of code in various other languages, and all of them are much more verbose and harder to read.

However, here's a dirty little secret I don't point out in the talk: the X,Y points havesince they're declared using rational numbers and not floating point numbers (the slides in the above talk aren't quite updated to show that. Oops). Thus, calculating the distance between points israther than approximate (assuming you don't use numbers so huge you're forced into overflow and fall back to floating point numbers).Why is this a big deal? Ask anyone who's written any accounting-related software what they think about floating point numbers. The answer may not be suitable for small children or delicate personalities.Of if you really want to go down the rabbit hole:. That paper is my explanation of why "roles" (Smalltalk "traits") are a superior solution to multiple inheritance. Mixins are OK, but trivial to break. Java-style interfaces are just awful if that's all you have. Aspect-oriented programming (AOP) formalizes action at a distance with all the horror that implies (which is awkward because I'm good friends with one of the creators of AOP). Roles areto Perl 6 and they are probably the single most important advance in object oriented programming in five decades. People have been swinging and missing at the problem of MI in OOP since the 60s but roles solve almost all of the problems because instead of guessing how to solve the problem, a bunch of computer scientists researched the problem, the failure modes of different solutions, and came up with a dead-simple and safe way to solve the underlying issue. I've taken numerous complex OO systems and made them much, much easier to use by converting inheritance to roles and I wish more languages would follow this path.I could go on and on about the many wonderful things in Perl 6, but it's all going to come down to people just digging in and trying the language. It's simply to learn the basics, but it's also a large language (something which didn't stop C++ from succeeding).The above is all from a technical perspective. From a business perspective, I wouldn't be too interested in Perl 6 ... yet. But ...Moore's Law is ending (). Thus, to get further improvements in software performance, we need to drop to lower-level languages (thus killing developer performance), or we need to go concurrent. There is currently no popular dynamic language with a strong concurrency model. For example, thein Python and Ruby means that they can be concurrent, but not parallel (). Thus, your lovely multi-core machines won't do much for you.If you want the programmer performance of a dynamic language but the machine performance of a parallel one, Perl 6 is a great choice. It's easy to learn, leveraging the traditional Algol-style syntax most developers are already familiar with, makes it easy to declare new types that map directly to your business needs, and lets you choose between type safety and ease-of-use, depending on what your company's needs are. In short, Perl 6 isn't just a developer's dream, it's a business dream, too.And for you academic types: imagine teaching procedural, object-oriented, and functional programming all within the same language!|||

