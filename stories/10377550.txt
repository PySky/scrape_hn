This document will contain advice to avoid writing code that will perform significantly worse than expected. Specifically those patterns that cause V8 (relevant to Node.JS, Opera, Chromium...) to refuse to optimize the affected function.

vhf is also working on a similar project that tries to list every killers in V8 Crankshaft Engine: V8 Bailout Reasons.

In V8 there is no interpreter but there are 2 different compilers: generic and optimizing. That means your JavaScript is always compiled and run directly as native code. That means it's fast, right? Wrong. Code being compiled to native code by itself isn't hugely significant for performance. It just removes interpreter overhead but the code will still be slow if not optimized.

For example in generic compiler will become something like this:

In other words it just calls a runtime function. If and will always be integers, then something like this:

would perform massively faster than the call figuring out complex JavaScript addition semantics at runtime.

In general you will get the former kind of code from the generic compiler and the latter kind of code from the optimizing compiler. Code compiled by the optimizing compiler can easily be, say, 100x faster than the code generated by the generic compiler. But there is a catch, you can't just write any kind of JavaScript and have it be optimized. There is a lot of patterns, some even idiomatic, in JS that the optimizing compiler refuses to touch (it "bails out").

It is important to note that patterns that cause optimization bailouts affect the entire containing function. Code is optimized 1 function at a time, without knowledge of what other code is doing (unless that code is being inlined in the function that is being currently optimized).

This guide will cover most patterns that cause the containing function go to "deoptimization hell". They will be subject to change and suggested work-arounds may become unnecessary when the optimizing compiler is updated to recognize more and more patterns.

You should be able to use node.js with some V8 flags to verify how patterns affect optimization. Generally you will make a function that contains the pattern, call it with all possible types to feed in the types and then call internal V8 functions to optimize and inspect it:

To see it's working, comment out the statement and re-run:

It is important to use the tooling to verify that the workarounds are working and necessary.

Some constructs are flat out not supported in the optimizing compiler and using such syntax will make the containing function unoptimizable.

It is important to note that even if the construct is unreachable or not run, these constructs still cause a function to be unoptimizable.

For example this does not help:

The above will punish the entire containing function even if the debugger statement is never reached.

Just to be clear on the last point: the entire containing function is unavailable for optimization, when you do any of this:

Direct and deserve a special mention here because they cause everything in their path to be dynamically scoped, thus possibly corrupting many other functions too as it became impossible to lexically tell to what variables are bound to.

Some of these statements cannot be avoided in production code such as and . To use such statements with minimal impact, they must be isolated to a minimal function so that the main code is not affected:

There are numerous ways to use in a way that causes the function to be unoptimizable. One must be extremely careful when using .

Workaround is to save the parameter to a new variable:

If this was the only use case for in the function, it can often be replaced with a check:

If it's likely that the function will later introduce then maintenance could easily forget to leave the re-assignent there though.

The object must not be passed or leaked anywhere.

Workaround for proxying is to create array in-line:

It takes a lot of code and is annoying so it might be worth to analyze if it's really worth it. Then again optimizing always takes a lot of code when more code means more explicitly nailed down semantics.

However, if you have a build-step, this can also be achieved with a macro that doesn't necessitate the use of source maps and lets the source code stay valid JavaScript:

The above technique is used in bluebird and the result is expanded into this in the build step:

This is actually possible in sloppy mode:

Workaround: there is no need to write such idiotic code. In strict mode, it throws an exception anyway.

And note that the FUD about mentioning causing an allocation of the arguments object is untrue when you use it in the mentioned safe ways.

Previously, a switch-case statement could only have up to 128 case-clauses, more than that and the function containing the switch statement was not optimizable

You had to keep case clause count of switch cases at or below 128 by using array of functions or if-else.

This limit has since been lifted, see this comment.

For-in statements can prevent the entire function from being optimized in a few cases.

All of these give the reason "ForIn is not fast case" or similar.

So the key cannot be from upper scope and neither can it be referenced from lower scope. It must be a pure local variable.

An object will go into hash table mode for example when you add too many properties dynamically (outside constructor), properties, use properties that cannot be valid identifiers and so on. In other words, when you use an object as if it was a hash table, it will be turned into a hash table. Passing such an object to is a no no. You can tell if an object is in hash table mode by calling when the flag is enabled in Node.JS.

Doing the above puts an enumerable property into the prototype chain of all objects (except objects). Any function that contains a statement is therefore not optimizable (unless if they only iterate over objects).

You can create non-enumerable properties with (not recommended to call at runtime but fine for defining effectively static things like prototype properties).

Whether a property is an array index is defined in the ecmascript specification:

Typically these will be arrays but normal objects can have array indices as well:

So not only is iterating over array using slower than a for loop, the entire function containing such a for-in statement will not be optimized.

If you pass a object to that is not a simple enumerable it will punish the entire containing function.

Workaround: Always use and iterate over the array with for loop. If you truly need all properties from entire prototype chain, make an isolated helper function:

Sometimes you're writing code, you know you need a loop but you don't know what the code inside is going to be like. So you drop a or and later placing a break condition inside the loop and move on, eventually forgetting about it. Refactoring time comes around and the function is slow or you're seeing a deoptimization - this could be a culprit.

Refactoring the loop to position the exit condition within the conditional part of the loop statement can be non-trivial. If the code has the exit condition as part of an if statement at the end of the loop and the code must be run at least once, refactor the loop to a . If the exit condition is at the beginning of the loop, place it in the conditional part of the loop body. If the exit condition is in the middle, you could try "rolling" the code: every time you move a piece of code from the top line to the bottom, you also leave a copy of the line above the loop. Once the exit condition can be checked within the conditional or at least with a shallow logic test, the loop should no longer be deoptimized.|||

bluebird - :bird: :zap: Bluebird is a full featured promise library with unmatched performance.