So many answers doing half the work. Yes, could be read as "the truthiness of X [represented as a boolean]". But isn't, practically speaking, so important for figuring out whether a single variable is (or even if many variables are) truthy or falsy. is the same as just . Comparing to a "real" boolean isn't really useful. What you gain with is the ability to check the truthiness of multiple variables against each other in a repeatable, standardized (and JSLint friendly) fashion. The above's not so useful. gives you the same results as . I can't think of a good case for casting a variable to boolean and then comparing to a "true" boolean. See "== and !=" from JSLint's directions (note: Crockford is moving his site around a bit; that link is liable to die at some point) for a little on why: The == and != operators do type coercion before comparing. This is bad because it causes ' \t\r

' == 0 to be true. This can mask type errors. JSLint cannot reliably determine if == is being used correctly, so it is best to not use == and != at all and to always use the more reliable === and !== operators instead. If you only care that a value is truthy or falsy, then use the short form. Instead of

 Note that there are some unintuitive cases where a boolean will be cast to a number ( is cast to and to ) when comparing a boolean to a number. In this case, might be mentally useful. Though, again, these are cases where you're comparing a non-boolean to a hard-typed boolean, which is, imo, a serious mistake. is still the way to go here. ╔═══════════════════════════════════════╦═══════════════════╦═══════════╗ ║ Original ║ Equivalent ║ Result ║ ╠═══════════════════════════════════════╬═══════════════════╬═══════════╣ ║ if (-1 == true) console.log("spam") ║ if (-1 == 1) ║ undefined ║ ║ if (-1 == false) console.log("spam") ║ if (-1 == 0) ║ undefined ║ ║ Order doesn't matter... ║ ║ ║ ║ if (true == -1) console.log("spam") ║ if (1 == -1) ║ undefined ║ ╠═══════════════════════════════════════╬═══════════════════╬═══════════╣ ║ if (!!-1 == true) console.log("spam") ║ if (true == true) ║ spam ║ better ╠═══════════════════════════════════════╬═══════════════════╬═══════════╣ ║ if (-1) console.log("spam") ║ if (truthy) ║ spam ║ still best ╚═══════════════════════════════════════╩═══════════════════╩═══════════╝ And things get even crazier depending on your engine. WScript, for instance, wins the prize. Because of some historical Windows jive, that'll output -1 in a message box! Try it in a cmd.exe prompt and see! But still gives you 0, or WScript's . Look away. It's hideous. But what if I have two values I need to check for equal truthi/falsi-ness? Pretend we have and . is and is obviously false. is and is true! Same truthiness! (In this case, both "have a truthiness of falsy".) So the only place you'd really need to use "boolean-cast variables" would be if you had a situation where you're checking if both variables have the same truthiness, right? That is, use if you need to see if two vars are both truthy or both falsy (or not), that is, of equal (or not) truthiness. I can't think of a great, non-contrived use case for that offhand. Maybe you have "linked" fields in a form? if (!!customerInput.spouseName !== !!customerInput.spouseAge ) { errorObjects.spouse = "Please either enter a valid name AND age " + "for your spouse or leave all spouse fields blank."; } So now if you have a truthy for both or a falsy for both spouse name and age, you can continue. Otherwise you've only got one field with a value (or a very early arranged marriage) and need to create an extra error on your collection. Or, admittedly, in some cases, you gain increased readability, as in the lib here: We're not interested in when we deal with later. We just want to lossily retain truthiness. That said, operationally, we could have left out the and had the same thing happen. One example:|||

