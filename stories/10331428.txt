A walk-through several less known C++ features

C++ is not the language you learn in 12 lesson in one week. With the C++ standard spanning 1300 pages, you can still have things to learn after years of experience. Iâ€™d argue you could hardly count on your fingers the people that know everything the standard says.

In this article I will walk through several language features that are probably less known to many C++ developers. Some of them are more useful than other, some could only confuse fellow developers and should not be used in real code.

A try-catch statement can appear anywhere a statement can appear. However, it is also possible to have a try-catch statement at a function level.

Probably an example that makes more sense could look like this:

However, this is no different than the usual that one would write:

The function try-catch syntax makes sense and was introduced for constructors. The problem with constructors is that if a constructor throws the object is not fully constructor (since the constructor did not successfully finished execution) and the destructor for the object is not called. As a result memory/resource leaks may occur.

To correctly destroy the foo object you must try-catch the constructor initializer list.

The new program will print:

An alternative to this solution is to use smart pointers instead of naked pointers. In this case the function try-catch is no longer necessary. The following implementation produces the same output:

Namespaces are declarative regions that provide a scope to the identifiers it contains. Everybody is probably familiar with named namespaces, nested namespaces or the C++ 11 inline namespaces, but not everybody knows about unnamed (or anonymous namespaces). As the name imply these are declared without a name and are used to make identifiers local to a translation unit.

The above namespace is the equivalent to the following code:

The code in the namespace and the namespace itself is not visible outside the translation unit. This makes unnamed namespaces useful to avoid name collisions from different translation units.

Consider the following situation when two source files contain a function with the same name.

When you try to build this you get a linking error. In VC++ the errors are:

You can easily solve this problem by putting the duplicate identifier/function in an unnamed namespace in one (or all) of the source files. Since one of the duplicate names is now fully qualified with a unique namespace name (generated by the compiler) the linkage error no longer occurs.

The presence of a pure virtual function in a class declaration makes the class abstract (unlike other programming languages where you have to explicitly use a keyword for that). That means the class cannot be instantiated, and a derived class from that class must implement the pure virtual function, otherwise it is also considered abstract.

A pure virtual function is declared with at the end.

It is little known though that a pure virtual function can actually have a body:

In VC++ the definition can be put in the declaration, but this is not allowed by the C++ standard (see paragraph 10.4)

Pure virtual functions with a body are not often seen in practice, but there are a couple of cases when they are useful or mandatory:

The conditional operator allows you to write shorter conditional code.

That is basically equivalent to

However, the conditional operator can also be used as an l-value on the left side of an assignment operation.

And you can very well have something like this:

Indexing an array is routine for everyone and is basically the same for all programming languages. However, in C++ you can swap the array and index and have code like this:

This is because the expression is equivalent to and that is the same as , which translates back to .

This is emphasized in the standard in paragraph 5.2.1 (Subscripting):

and also clarified in paragraph 8.3.4.6:

This commutativity does not apply to classes that have overloaded the subscript , such as .

The C++ standard defines alternative tokens for some operators and punctuators (some of them for the compatibility with the C++ standard).

That code is direct equivalent to the following:

Take notice that the Visual C++ compiler only supports punctuation digraphs if compiled with (aka Disable language extensions), though in practice none of the VC++ compilers that I have seem to support that. On the other hand you need to include the header to have the alternative operator tokens.

There is also a set of alternative tokens of three characters called trigraphs. These are however due to be removed in C++17.

Learn more about these topics in these article:|||

