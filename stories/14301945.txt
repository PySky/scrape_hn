tl;dr: Snipster is a solution for dealing with the headaches of snippets management. It defines a simple, declarative format for snippets and lets you publish all of your snippets to all of your text editors with one command.

Text editor snippets are a powerful way to speed development and avoid time spent looking up syntax and formatting. In theory, they’re a nice concept: identify the things you type a lot or forget a lot, put them in a snippet, and then use that snippet’s magic keyword to type them faster and remember them better. In practice, however, snippets never seem to be worth the hassle. They’re relegated to the worlds of 1) the power user, who knows exactly how she works and how to optimize her productivity, and 2) the procrastinator, who is constantly distracted tweaking her perfect development environment. For all others, thinking about and writing snippets is a daunting task that takes a seat at the bottom half of the ‘To Do Eventually’ list.

We recognize that we retype things over and over again, or look things up over and over again, but the cognitive effort involved in adding a snippet to our text editor(s) is too high for all but the most useful snippets - those with the highest potential ROI, like a lengthy doctype html template or a difficult to remember combination of css styles. But snippets might be exceptionally more useful if we used lots of them. If we had a snippet for almost everything we do, from for loops to if statements to css styles to a framework’s methods - our development process might be completely transformed. One could think of this development experience like a new, personal, generalized programming language that compiles down to normal, industry-standard code. Type and it compiles down to a standard for loop - and this for loop command would change depending on which language you’re writing. If you have a snippet for every language you write, specific to that language scope, you need only remember those three letters to type a perfectly formatted for loop in any language.

This might be neat to think about, but it’s just naive musing at this point. No one has the time to write that many snippets to simply try out a development experience like this. The risk of wasting time is too high. Even to get marginal development gains from a small number of snippets, the risk is too high. If the process of writing and trying out a snippet is anything more than trivial, it is too costly. And in reality, managing snippets is far, far from trivial - it’s closer to painful.

Let’s look at the process of adding four snippets to our text editor(s) in 2017. We have four chunks of common code that we use repeatedly: a lorem ipsum markdown snippet (of the hipster variety), a javascript for loop, a doctype HTML5 template, and some CSS background-image styles. Having these available in our arsenal with only a few keystrokes would be pretty neat.

We can’t decide which editor we like most - Atom, VS Code, Sublime, something else? Commitment is hard. We like Atom, but we’ve heard VS Code is pretty cool so we’ve recently switched to that. However, it would really be nice to have the option to use Atom and Sublime too. We are constantly adjusting our development environment, trying to reach development nirvana. This means we need to add each of these snippets to each of our editors. If we don’t now, then we will have to do it eventually when we switch editors - or forfeit all of our snippets.

(Sidenote): This is not to say that the average developer bounces between three or more text editors regularly and writes snippets for each one every time they add one. That would be madness. It's just an example to illustrate each editor's process for adding snippets. Most developers pick an editor and stick with it for awhile, slowly adding their snippets, if at all. Still, it's not unreasonable to think that the average developer will change editors at least once in their career, sometimes more than once. The fact that there are so many editors, and new ones coming out regularly, means that snippets often aren't even used at all, out of fear of getting locked in to an editor or having a heck of a time migrating them to a new editor later. Even if you use only one editor, and are pretty happy with it thank you very much, bear with me. There are still headaches that we can fix. Okay, as you were...

Okay. It looks like VS Code groups snippets by language, each with its own JSON file. So we need to find the JSON file for each language - Markdown, Javascript, HTML, and CSS. We find these files via VS Code menu > Preferences > User Snippets. Wait, we also want our CSS snippet to be available to us when we write Sass or LESS - does that mean we have to write it to three different files? We’ll figure that out later. Okay, let’s write the javascript for loop first. We open up our javascript snippet file for VSCode and are greeted with something like this:

For the beginning programmer, it might not be entirely clear what we’re supposed to do here. After some googling, we understand that this is a file that represents all of our javascript snippets in VSCode - each snippet being a key-value property in this JSON object. Normally comments aren’t allowed in JSON, but VSCode must be ignoring them. We start writing our for loop according to their example. Looks like we need to break the body of our snippet into an array of strings for each line.

Woosh, that felt kind of gross. So many quotations and curlies and commas and brackets and colons! There is definitely a lot of room for syntax error here. Good thing we’re not writing a larger snippet, like a React component outline or a jQuery ajax function. This is a simple 3-line snippet! Even with this minefield of potential syntax errors, VSCode doesn’t warn us when our JSON syntax is wrong. Sigh.

(Sidenote): If you don't recognize the syntax, those are tab stops and placeholders, the most powerful feature of snippets. When you use the snippet, every time you press 'tab' your cursor jumps to the next number. The optional placeholder lets you know what you might type there, or you can use it as a default value. So in this for loop, we start at $1 by supplying an 'index' variable, then jump to $2 to supply a conditional telling the for loop when to stop, then jump to $3 for the body of our for loop.

We add our lorem ipsum, doctype, and background-image snippets similarly. Open up the markdown.json, html.json, and css.json files, respectively, and type in our JSON to represent the snippets, careful not to produce any formatting errors. Maybe 5, 10 minutes later - we’re done. With VSCode.

Yikes, that one was particularly ugly. Don’t forget to escape those quotation marks!

Great! We now have a few snippets we can use in VSCode. But let’s add them to Atom as well. Atom uses a single snippets file for all of your snippets. We open it by going to the Atom menu > Snippets. This file looks different from the VSCode. Upon closer inspection (and perhaps more googling), we understand this to be a CSON file, which is just a coffeescript version of JSON. Okay. Since all of our snippets for Atom are in this single file, it groups snippets by language scope (just like VSCode did using separate files) as objects in the top-level CSON object. I don’t have the original contents of this file, but it probably looks something like this:

The names of each language object (the properties of the top-level object) appear to be some sort of special scoping syntax. We google. For javascript, we need to use a property name of . Makes sense. Maybe it’s just the word source followed by a period and the name of the language file extension? But wait - for HTML, it is . Maybe the source keyword is for programming languages, and text is for markup languages? Nope - for Markdown, we need to write . WTF. Oh, ‘github flavored markdown’. Okay, I guess. CSS is . This language scoping syntax and CSON format has been the source of much confusion.

Now that we’ve found all of this information, we write our CSON. CSON is prettier than JSON, but it’s a bummer we can’t simply copy/paste our JSON from VSCode in. We avoid the potential punctuation syntax errors that we had in JSON, but now we have to be careful about whitespace errors. Tabs are important. At least Atom warns us when the CSON file is invalid.

We write our snippets, giving each a prefix, a description, and a body, carefully checking that the whitespace and the language scopes and all of the formatting is correct. We’ve written just four snippets, and already our file is almost 50 lines long. What if we want to add lots of snippets? This file quickly becomes a nightmare.

I’ll spare us the tedious walkthrough of Sublime. You get the idea. Writing and managing snippets is annoying. Sublime is arguably even more difficult than VSCode and Atom, and uses yet another data format - our old friend XML. And other text editors use still more formats to manage snippets. Some have GUIs, some are file-based; some use their own format only they understand, some use industry-standard formats like JSON and XML.

The point is, there is wild variability between how text editors handle snippets, and none of them are very user-friendly. All have the same essential idea: type a short piece of magical text, press tab, expand to more complex, perfectly-formatted code, profit. Some editors offer some powerful features on top of this, but the essential idea of snippets is not complicated.

What about our CSS snippet? We wanted that available in SCSS and LESS as well, since the syntax is the same. Will we be safe using that snippet in our preprocessor files? In Atom, yes - SCSS and LESS are sub-scopes of CSS, so they work. In VSCode, no - SCSS and LESS have their own respective snippet files. Crap. We need to copy our CSS snippet into each, again careful of the syntax pitfalls of hand-editing a JSON file.

How about our hipster ipsum snippet? That could theoretically be useful in any language. In Atom, we could give it a scope of to apply the snippet to all contexts. Similar functionality is available in Sublime. Not so in VSCode though - we would need to add the snippet to each language we want to use it in.

We shouldn’t need to hand-write JSON, CSON, or XML files, much less all three. We shouldn’t need to worry about how editors implement snippets. There is no problem with text editors using these formats - to the contrary, it’s fantastic that they do. But normally when we work with these formats, computers are writing and reading them automatically; not humans manually.

Snipster radically simplifies the snippet management process by introducing a simple wysiwyg format for snippets and generating each editor’s snippets file(s) automatically. Here are the snippets we wrote earlier according to Snipster:

With Snipster, each snippet is a file contained within a single snippets repository ( problems #6 and #7).

Each of these snippet files has a generalized, easy-to-understand, declarative format:

No whitespace weirdness. No converting the content to an array of strings. No writing each snippet n times in n different formats. Write once, let the computer do the dirty work ( problem #1). And each snippet is small, self-contained, and obvious ( problem #3)

When you’re ready to use your snippets, head to the command line and type . This will publish all of your snippets to all of your text editors ( problem #2). Under the hood, all Snipster is doing is creating a map of all the snippet files you created, and dealing with them appropriately for each editor. Editors work the same as they always did - Snipster simply generated the snippet files for them.

You can organize your snippets in your repository however you’d like. Arrange by language, by project, by type, alphabetically, etc. Create subfolders and sub-subfolders and sub-sub-subfolders. Make your snippets repo look like the Sierpinski triangle. Live your wildest snippet dreams ( problem #5).

If you want a snippet to be available to multiple language scopes within an editor, add them all to the file extension separated by '+'s. So is a snippet under the HTML and Javascript scopes. is available under HTML, Markdown, Javascript, and Ruby. There are also a few special named extensions. sends ‘lorem’ to all scopes. sends ‘cover-bg’ to CSS, SCSS, and LESS ( problem #4).

Just use yarn or npm to install, then get set up with :

Snipster will ask you where you want to house your snippets (either by using a directory you’ve already set up or by creating one) and which editors you want to use. It will transfer your pre-existing snippets in each of these editors to your directory and you’re good to go. Whenever you add new snippets to your directory, publish them to all of your editors, all at once:

Snipster is young. I haven’t tested it thoroughly on machines and environments other than my own. It currently works with VSCode, Atom, and Sublime Text. It’s pretty harmless, but it’s worth copying/backing up your snippets if you haven’t already before running , just in case (but I shouldn’t have to tell you that - after all that work crafting your perfect snippets you haven’t backed that ish up!?).

Please help Snipster by submitting issues, pull requests, and feature requests! I really want to hear what people think about this and whether they find it useful. It seems incredible that something like this doesn’t exist already (I couldn’t find anything besides Atomizr, which doesn’t seem like a particularly great solution). Is no one using snippets? Has everyone resorted to hand-writing data files? Am I missing something?

I have some ideas on where to take Snipster in the future, but I want to hear from you. Support for more text editors, languages, and operating systems is obviously priority number one in the short-term. If you have suggestions for what to work on first - or better yet, want to help me add support - let me know in the github repo or by email. I’m pretty excited about where this could go.

If you find value in Snipster but don’t have time to contribute, please consider buying me a ☕ .|||

tl;dr: Snipster is a solution for dealing with the headaches of snippets management. It defines a simple, declarative format for snippets and lets you publish all of your snippets to all of your text editors with one command.