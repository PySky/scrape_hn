I love enums, for me they’re the coding equivalent to strumming a ukulele, eating pizza, and all the other things I love. But all joking aside, I’ve had a deep respect for this tool since I was coding small homebrew demos in C for the Gameboy Advance handheld console. Back then, they were a great tool that allowed us to have cleaner code and avoid issues when using constant values by assigning names to them. Since then, Apple has improved enumerators in Swift, by giving us the chance to store values (great for creating our own ADTs - Algebraic Data Types) and to include methods within them. These factors combined with the power of Swift’s pattern matching gives us an expansive field to explore and create new patterns for use in our apps.

One method that we’ve recently experimented with was using enums to describe data needed by UITableViews. As you’re probably aware, when we need to display table views in our apps, which is the majority of the time, we implement the and protocols. Using these with our tables tells the app what data to display and how to draw it. Delegate patterns are useful and have deep foundations set on the iOS SDK, but personally, I’ve never been happy with how the information and the code itself are organized inside this method. So, why not try to use the new all-powerful Swift enums to tidy everything up?

We’ve set up an approach on how to better organize code to create a table view containing several cell types. In our example, the table will hold the information about pizza (dough type and thickness, sauce type, and ingredients), that will be represented by controls like sliders, picker views and switches. This type of table would have complex code in the delegate methods to distinguish between the different cell types, where to obtain the data to draw them, and how their changes affect our model. We’re going to move all those methods to enums that depict our data.

All the code examples in this post come from a project we’ve set up in this open repository. Don’t hesitate to check it out!

We’ll represent each set of section rows as an enum containing several methods that we’ll call from our delegate methods. We’ll have another enum represent the entire set of sections themselves. We need two sections in our app, one to set our pizza’s dough settings and another to choose its ingredients. We’re even giving our users the ability to choose bacon as a topping! We wouldn’t want to live in a world with bacon-less pizzas, but maybe this is the wrong time to think about that scenario. Instead, let’s list the structure of both of our table sections like this:

For each section, we need a title, number of rows, and each row’s enum representations. That’s what we have here. Our Section enum holds its internal cases in an array we can use to count them (Swift’s enum can’t count its cases yet), and also implements two methods so we can ask it for its title and each section’s row enums. Less relevant are the last two methods, that help our table know how to draw each section’s header. As you’ve probably noticed, we have two new types here, SectionDoughRows and SectionIngredientsRows, that will hold our data for each row in each section. The problem is that Swift is so strictly typed that each enum will be treated as a different type even if they contain the same group of methods. To fix this, we need to create a protocol which every enum representing a row will need to conform to Row. Take a look at it:

As you can see, if every row’s enum conforms to this protocol, we’ll have everything our table needs to know how to draw itself. This will also allow us to respond to our user’s interaction to modify our model. Let’s see how to conform to this protocol by looking at the first of our rows, the one that represents the pizza’s dough:

Most of these methods are fairly self-explanatory, they simply redirect our table’s delegate methods to their much-craved data: their title, cell identifiers, functions to configure their visuals, value to represent. The last method (assignValue) is a little bit more complex. It needs to connect the user’s interaction with the controls inside our rows (i.e.: moving a slider to select a new dough thickness) to changes in our view controller’s model. Notice our use of optional casting to handle several possible types of values (thickness is represented as a Float, but the chance of cheeseborderness is depicted using Bool).

So how do our table’s delegate methods look? Thinner! In fact, now they’re mostly proxies to our enum methods:

Again, nothing complicated. When our table asks our view controller for the number of sections available, the number of rows of one of them, or information to draw a cell, we just call the methods in our enums. The only thing that may need a little bit of attention is the way we get each row’s enum case, by using the caseForRow method. You may notice that we’re not paying attention to the types here, and we don’t need to. We have the Row protocol we can rely on to access the methods we need, and by using optional unwrapping we know that we’ll always get a valid row result no matter what happens.

Now we should take a look at how we’re going to configure our cells:

Our configureCellForIdentifier will dequeue our cell and call the corresponding configuration function to customize each kind of cell. One example of these functions is configureSliderCell that sets title, value, and our reference as the delegate for the dough thickness slider cell. Lastly, let’s see how to assign values from our cell’s interactions to our model:

Here we have a common method to the functions that assign values from our cell row cases like we had with the cell configuration functions. In this example, we see how the method that handles value change in the slider can call assignValueForRowAtIndexPath, which will then access the corresponding row’s assignValue function as defined in the Row protocol.

There’s a bit more code involved here, but this example covers the basics of our approach to the problem. Our goal is to have all of our cell’s needs organized by our model data and table organization, not the other way around. Swift’s powerful enumerations, together with optionals and first-class functions, allow us to tidy our tableView delegate methods up in a cleaner and more elegant way. You can find the rest of the code in this repo. As always, if you have questions or comments about this idea, don’t hesitate to let us know through Facebook, Twitter or the comments section below.

And please, don’t switch off the bacon button. You shouldn’t do that to a pizza.|||

