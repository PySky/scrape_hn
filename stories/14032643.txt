Python‚Äôs decorators allow you to extend and modify the behavior of a callable (functions, methods, and classes) without permanently modifying the callable itself. Any sufficiently generic functionality you can ‚Äútack on‚Äù to an existing class or function‚Äôs behavior makes a great use case for decoration. This includes:

Why Should I Master Decorators in Python? That‚Äôs a fair question. After all, what I just mentioned sounded quite abstract and it might be difficult to see how decorators can benefit you in your day-to-day work as a Python developer. Here‚Äôs an example: Imagine you‚Äôve got 30 functions with business logic in your report-generating program. One rainy Monday morning your boss walks up to your desk and says: ‚ÄúHappy Monday! Remember those TPS reports? I need you to add input/output logging to each step in the report generator. XYZ Corp needs it for auditing purposes. Oh, and I told them we can ship this by Wednesday.‚Äù Depending on whether or not you‚Äôve got a solid grasp on Python‚Äôs decorators, this request request will either send your blood pressure spiking‚Äîor leave you relatively calm. Without decorators you might be spending the next three days scrambling to modify each of those 30 functions and clutter them up with manual logging calls. Fun times. If you do know your decorators, you‚Äôll calmly smile at your boss and say: ‚ÄúDon‚Äôt worry Jim, I‚Äôll get it done by 2pm today.‚Äù Right after that you‚Äôll type the code for a generic decorator (that‚Äôs only about 10 lines long) and quickly paste it in front of each function definition. Then you‚Äôll commit your code and grab another cup of coffee. I‚Äôm dramatizing here. But only a little. Decorators can be that powerful üôÇ I‚Äôd go as far as to say that understanding decorators is a milestone for any serious Python programmer. They require a solid grasp of several advanced concepts in the language‚Äîincluding the properties of first-class functions.

The payoff for understanding how decorators work in Python is huge. Sure, decorators are relatively complicated to wrap your head around for the first time‚Äîbut they‚Äôre a highly useful feature that you‚Äôll often encounter in third-party frameworks and the Python standard library. Explaining decorators is also a make or break moment for any good Python tutorial. I‚Äôll do my best here to introduce you to them step by step. Before you dive in, now would be an excellent moment to refresh your memory on the properties of first-class functions in Python. I wrote a tutorial on them here on dbader.org and I would encourage you to take a few minutes to review it. The most important ‚Äúfirst-class functions‚Äù takeaways for understanding decorators are: Functions are objects‚Äîthey can be assigned to variables and passed to and returned from other functions; and Functions can be defined inside other functions‚Äîand a child function can capture the parent function‚Äôs local state (lexical closures.) Alright, ready to do this? Let‚Äôs start with some:

Now, what are decorators really? They ‚Äúdecorate‚Äù or ‚Äúwrap‚Äù another function and let you execute code before and after the wrapped function runs. Decorators allow you to define reusable building blocks that can change or extend the behavior of other functions. And they let you do that without permanently modifying the wrapped function itself. The function‚Äôs behavior changes only when it‚Äôs decorated. Now what does the implementation of a simple decorator look like? In basic terms, a decorator is a callable that takes a callable as input and returns another callable. The following function has that property and could be considered the simplest decorator one could possibly write: As you can see, is a callable (it‚Äôs a function), it takes another callable as its input, and it returns the same input callable without modifying it. Let‚Äôs use it to decorate (or wrap) another function: In this example I‚Äôve defined a function and then immediately decorated it by running it through the function. I know this doesn‚Äôt look very useful yet (I mean we specifically designed the null decorator to be useless, right?) but in a moment it‚Äôll clarify how Python‚Äôs decorator syntax works. Instead of explicitly calling on and then reassigning the variable, you can use Python‚Äôs syntax for decorating a function in one step: Putting an line in front of the function definition is the same as defining the function first and then running through the decorator. Using the syntax is just syntactic sugar, and a shortcut for this commonly used pattern. Note that using the syntax decorates the function immediately at definition time. This makes it difficult to access the undecorated original without brittle hacks. Therefore you might choose to decorate some functions manually in order to retain the ability to call the undecorated function as well. So far, so good. Let‚Äôs see how:

Now that you‚Äôre a little more familiar with the decorator syntax, let‚Äôs write another decorator that actually does something and modifies the behavior of the decorated function. Here‚Äôs a slightly more complex decorator which converts the result of the decorated function to uppercase letters: Instead of simply returning the input function like the null decorator did, this decorator defines a new function on the fly (a closure) and uses it to wrap the input function in order to modify its behavior at call time. The closure has access to the undecorated input function and it is free to execute additional code before and after calling the input function. (Technically, it doesn‚Äôt even need to call the input function at all.) Note how up until now the decorated function has never been executed. Actually calling the input function at this point wouldn‚Äôt make any sense‚Äîyou‚Äôll want the decorator to be able to modify the behavior of its input function when it gets called eventually. Time to see the decorator in action. What happens if you decorate the original function with it? I hope this was the result you expected. Let‚Äôs take a closer look at what just happened here. Unlike , our decorator returns a different function object when it decorates a function: And as you saw earlier, it needs to do that in order to modify the behavior of the decorated function when it finally gets called. The decorator is a function itself. And the only way to influence the ‚Äúfuture behavior‚Äù of an input function it decorates is to replace (or wrap) the input function with a closure. That‚Äôs why defines and returns another function (the closure) that can then be called at a later time, run the original input function, and modify its result. Decorators modify the behavior of a callable through a wrapper so you don‚Äôt have to permanently modify the original. The callable isn‚Äôt permanently modified‚Äîits behavior changes only when decorated. This let‚Äôs you ‚Äútack on‚Äù reusable building blocks, like logging and other instrumentation, to existing functions and classes. It‚Äôs what makes decorators such a powerful feature in Python that‚Äôs frequently used in the standard library and in third-party packages.

Perhaps not surprisingly, you can apply more than one decorator to a function. This accumulates their effects and it‚Äôs what makes decorators so helpful as reusable building blocks. Here‚Äôs an example. The following two decorators wrap the output string of the decorated function in HTML tags. By looking at how the tags are nested you can see which order Python uses to apply multiple decorators: Now let‚Äôs take these two decorators and apply them to our function at the same time. You can use the regular syntax for that and just ‚Äústack‚Äù multiple decorators on top of a single function: What output do you expect to see if you run the decorated function? Will the decorator add its tag first or does have precedence? Here‚Äôs what happens when you call the decorated function: This clearly shows in what order the decorators were applied: from bottom to top. First, the input function was wrapped by the decorator, and then the resulting (decorated) function got wrapped again by the decorator. To help me remember this bottom to top order I like to call this behavior decorator stacking. You start building the stack at the bottom and then keep adding new blocks on top to work your way upwards. If you break down the above example and avoid the syntax to apply the decorators, the chain of decorator function calls looks like this: Again you can see here that the decorator is applied first and then the resulting wrapped function is wrapped again by the decorator. This also means that deep levels of decorator stacking will have an effect on performance eventually because they keep adding nested function calls. Usually this won‚Äôt be a problem in practice, but it‚Äôs something to keep in mind if you‚Äôre working on performance intensive code.

All examples so far only decorated a simple nullary function that didn‚Äôt take any arguments whatsoever. So the decorators you saw here up until now didn‚Äôt have to deal with forwarding arguments to the input function. If you try to apply one of these decorators to a function that takes arguments it will not work correctly. How do you decorate a function that takes arbitrary arguments? This is where Python‚Äôs and feature for dealing with variable numbers of arguments comes in handy. The following decorator takes advantage of that: There are two notable things going on with this decorator: It uses the and operators in the closure definition to collect all positional and keyword arguments and stores them in variables ( and ). The closure then forwards the collected arguments to the original input function using the and ‚Äúargument unpacking‚Äù operators. Let‚Äôs expand the technique laid out by the decorator into a more useful practical example. Here‚Äôs a decorator that logs function arguments and results during execution time: Decorating a function with and then calling it will print the arguments passed to the decorated function and its return value. This is still somewhat of a toy example‚Äîbut in a pinch it makes a great debugging aid: 'TRACE: calling say() with ("Jane", "Hello, World"), {}' Speaking of debugging‚Äîthere are some things you should keep in mind when debugging decorators:

When you use a decorator, really what you‚Äôre doing is replacing one function with another. One downside of this process is that it ‚Äúhides‚Äù some of the metadata attached to the original (undecorated) function. For example, the original function name, its docstring, and parameter list are hidden by the wrapper closure: If you try to access any of that function metadata you‚Äôll see the wrapper closure‚Äôs metadata instead: This makes debugging and working with the Python interpreter awkward and challenging. Thankfully there‚Äôs a quick fix for this: the decorator included in Python‚Äôs standard library. You can use in your own decorators to copy over the lost metadata from the undecorated function to the decorator closure. Here‚Äôs an example: Applying to the wrapper closure returned by the decorator carries over the docstring and other metadata of the input function: As a best practice I‚Äôd recommend that you use in all of the decorators you write yourself. It doesn‚Äôt take much time and it will save you (and others) debugging headaches down the road.|||

Understanding decorators is a milestone for any serious Python programmer. Here‚Äôs your step-by-step guide to how decorators can help you become a more efficient and productive Python developer.