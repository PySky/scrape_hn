Recently I read an article titled Tempted to Abandon React Native for Native Android. The impetus for this article was performance issues the author encountered while trying to get images working with his app on an older device: “To support adding images to the projects, I integrated an image picker component. Sometimes when adding an image, the user interface would turn white for a few seconds and then reload, but not on the page I added the image from. I suspect this is due to memory issues. That particular device has about 512 MB of RAM. On devices with at least 1 GB, this is not a problem.” Performance problems like the ones described in the linked article are not specific to React Native. Dealing with a sluggish app that has to handle one or more large images is something that any mobile developer should be able to troubleshoot. The purpose of this article is to walk you through how you can use Native tools to track down and fix performance issues in your React Native app. In order to illustrate my point I created an app consisting of a scrollable list of images from Flickr. I’ll talk through my thought process and provide links to pull requests and performance data as I perform various simple optimizations on the app. The source code for the app can be found here and you can see a gif of it in action below. Performance is a broad topic so for this article I will be focusing on the following: overdraw and GPU rendering performance. Every measurement in this analysis is done by scrolling the list of images from top to bottom slowly. All measurements were taken via an emulated Nexus 4 running Android 4.4 and a Nexus 6 phone running Android 5.1.1. “Overdraw refers to the system’s drawing a pixel on the screen multiple times in a single frame of rendering. For example, if we have a bunch of stacked UI cards, each card hides a portion of the one below it. However, the system still needs to draw even the hidden portions of the cards in the stack. This is because stacked cards are rendered according to the painter’s algorithm: that is, in back-to-front order. This sequence of rendering allows the system to apply proper alpha blending to translucent objects such as shadows.” All applications will have some amount of overdraw but too much of it can cause performance problems. How much Overdraw should our app have? According to the following case study by prominent Android developer Romain Guy: “The amount of overdraw you can reasonably afford varies from device to device. A good rule of thumb is to aim for a maximum overdraw of 2x; this means you can draw the screen once, then draw twice again on top, painting each pixel 3 times total.” Google gives you two easy ways to tell how much overdraw your app has. This can be seen on a device by displaying either a numeric counter or a colored overlay highlighting parts of the UI that are overdrawn. To see the colored overlay, in the emulator (or your device), enable developer options then go into developer settings and select Debug GPU Overdraw, then select show Overdraw areas: The example apps screen is now overlaid with various colors that correspond to overdraw. According to the overdraw developer docs: “The colors are hinting at the amount of overdraw on your screen for each pixel, as follows: Red: Overdrawn four or more time” To enable the overdraw counter go back into developer settings and select show overdraw counter. The counter now shows that the app has an overdraw of 3.56. Lets see if we can figure out how to reduce this number. If you go back to the colored overlay of the app you will notice that part of the background is red. Lets try commenting out the background component and see what happens. All I’m doing at this point is swapping the BgView component I created for a standard View: Doing this causes the overdraw number to go from 3.56 to 1.81 and seems to suggest that this issue might be being caused by our background component.

The background component used in the example app looks like this: One thing that immediately stands out to me is the use of a transparent background color and the image file name bg_transparent.png. The bg_transparent.png is a transparent background image with some shapes on top. The needless use of transparent colors and backgrounds in an app’s design can often cause performance issues. Lets see what happens when we replace this transparent background with one that keeps the shapes but uses a solid color. This will allow us to get rid of all the transparent background colors being used. A pull request with these changes can be viewed here. As you can see below the overdraw number goes from 3.56 to 2.57. A significant improvement for just changing your background. Another handy tool to measure drawing performance is the Profile GPU rendering option in developer options. Go into this menu and select: This option allows you to issue the following command from your terminal and get detailed stats on your apps drawing performance: According to the Android developer docs: “the command prints out timing information for the most recent 120 frames, broken into a few different categories with tab-separated-values. This data can be useful for indicating which parts of the drawing pipeline may be slow at a high level.” A graphed example of the unoptimized app’s performance running on a Nexus 6 can be seen here. As noted in the methodology section, these figures were collected by slowly scrolling the app then running dumpsys. Raw data for the overdraw fix can be seen here. A before and after comparison can be seen below in screenshot form. The Y axis of the chart is the time in milliseconds, the different colored Bars correspond to Process, Execute and Draw time.

What do these figures mean? According to the Android developer docs: Represents the time used to create and update the view’s display lists. If this part of the bar is tall, there may be a lot of custom view drawing, or a lot of work in onDraw methods. Represents the time the CPU is waiting for the GPU to finish its work. If this bar gets tall, it means the app is doing too much work on the GPU. Represents the time spent by Android’s 2D renderer issuing commands to OpenGL to draw and redraw display lists. The height of this bar is directly proportional to the sum of the time it takes each display list to execute — more display lists equals a taller red bar.” To render smoothly at 60 fps, each frame must take less than 16 ms to complete. Lets see if we can improve these perf numbers. How are we rendering this list of images? A common use case for mobile apps is to display long lists of items, as such native platforms have dedicated components for doing this efficiently. An example of this can be seen with UICollectionView for iOS and RecyclerView for Android. As you can see below the performance example app renders all of its images at once inside of a ScrollView. This is bad because it means that we are rendering all of the images including the ones that are not visible to the user on screen. On a mobile device with limited memory this will result in poor performance. Also the app will simply not work if the list of images exceeds the devices available memory. To illustrate this point, lets go into Android Studio and look at the layout inspector while the app is running. The layout inspector allows you to see the hierarchy of views being displayed at any given time. This is what it looks like for our ScrollView implementation: All of the views are being displayed, even the ones not visible to the user. To illustrate this point further here is a screenshot of the memory monitor from Android studio. As you can see the app starts out with over 7 megs of memory allocated: So what’s a more efficient way to display a list of items with React Native? The answer is to use a ListView. According to the React Native developer docs: ListView works well for long lists of data, where the number of items might change over time. Unlike the more generic ScrollView, the ListView only renders elements that are currently showing on the screen, not all the elements at once.” Okay, that sounds promising, lets see what happens when we rewrite our performance example to use a ListView. The pull request with all of the changes I made can be seen here. This is what the ListView implementation looks like in layout inspector. As you can see only three images are rendered as opposed to the entire list: This is what the initial memory footprint of the app looks like after switching to using a ListView, 5.69 MB’s allocated as opposed to 7.20 MB’s with the ScrollView: So what does the profile GPU rendering perf data look like after these changes? Here’s a before and after screenshot, as you can see this looks better:

The raw perf data for all these changes can be seen here. What about doing this in native code? Okay so what if we we implemented our scrolling list of images in native code? What kind of performance gains would we see? I decided to test this by wrapping a native Android RecyclerView and comparing its performance to the React Native ListView. A pull request with my changes can be seen here. Under the hood React Native uses the Fresco library to load images on Android so this is what I used in my native implementation. What’s are the differences between React Native’s ListView and its native counterparts? One big difference is that the React Native ListView is implemented entirely in Javascript and does not depend on any native code. This is very handy as it makes ListView quite flexible right out of the box. Adding additional text or images to a row item in a purely native implementation can not be done purely in Javascript and would have to be implemented for each platform supported. Another big difference is that both UICollectionView for iOS and RecyclerView for Android use view recycling. This is as opposed to the React Native ListView which renders items lazily just when they are about to appear. The React Native ListView does not recycle the underlying view container like UICollectionView or RecyclerView. This results in more freeing and allocating of rows as the user scrolls, which is very CPU-intensive. As an aside Tal Kol as a wonderful article on this topic which explains the trade offs when using a native implementation over a ListView, you can read it here. So how does the ListView compare to the native RecyclerView? As you can see from the Perf data below, the comparison between the ListView and the RecyclerView is not as dramatic as between the ListView and the ScrollView:

Once again the raw perf data for all these changes can be seen here This initial memory footprint and view hierarchy of the app look basically the same for both the React Native ListView implementation and the RecyclerView. So do you ever need to write native code? Yes. The performance example app I created was deliberately simplified to illustrate various points about performance. In the real world you might need to create an app with an infinite scrolling list of images pulled from a paginated API. Such an app might employ complex multi gesture interfaces, animations and other computationally intense effects. In this case you most likely would write quite a bit of native code. Tal Kol also has a great article on the subject of overcoming React Native animation related performance limitations, with great practical examples which you can read here. Other use cases where you might need to write native code is if you need to perform long running operations in the background or use native API’s not exposed by React Native yet. Apple and Google provide fantastic developer tools to help profile mobile apps. These tools are quite familiar to native developers like myself but might be new to React Native developers who are often coming from a web background. These tools really aren’t that hard to use and can make a big difference in your app’s performance. If you enjoyed reading this article and would like to read more React Native content from a native developers perspective please follow me. Thanks.|||

Recently I read an article titled Tempted to Abandon React Native for Native Android. The impetus for this article was performance issues the author encountered while trying to get images working…