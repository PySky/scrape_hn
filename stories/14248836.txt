APIs have three primary dimensions and it’s important to understand all three. The first dimension is how the API is created and defined. Essential to this process is the design and craftsmanship that goes into the creation of APIs.

The instance of your API is the second dimension. Together, the instance and definition of an API exist in multiple environments such as: staging, testing and production.

In order to fully understand APIs, we need to dig a little deeper to the third dimension – Time.

“The term “3D” refers to the fact that an API’s definition and instance go through a lifecycle within a span of time.”

In the past, you heard me go on and on about the API lifecycle. I believe that his concept is important to the work we do. As developers, managing the API Lifestyle is key to our success. It goes something like this – you publish a feature. Then, there is a shift in user behavior. These shifts create an urgent need for changes. At the most basic level, this represents the lifecycle . This is true for any developer, regardless of your area of discipline.

The ability to rapidly iterate and scale to meet the needs of users, can make or break an app.  In highly competitive markets, the winners win big and the losers go home empty handed.

What is an API exponential accelerator?

An API exponential accelerator is, at it’s most basic level, the business case for accelerating through the API Lifecycle. It is the bi-product of a hyper competitive environment. In some cases, healthy competition can create opportunities.

For the purposes of this post, we’ll focus on Apple. Apple disrupted the mobile industry with the iPhone.  The global App economy was born almost overnight. After the iPhone,  Apple released the iPad with a brand new form factor.  In response to market demands, the Apple Watch was born.

In sum,  each form factor and new user experience model broadened capabilities while simultaneously increasing demand for interoperability within the App economy.

Think about it – Do you know of any apps that  aren’t tethered to a backend?  Or, for that matter, multiple backends?

Cloud services are anchored by companies such as Apple in the case of Apple iTunes. They are held hostage by their launch partners (ex. Google Maps versus Apple Maps). In reality, users benefit when the backend of an app works nicely with the backend of all of the other apps in the ecosystem.

For example, user want to track their exercise, weight and biometrics from a single device. Apps like MyFitnessPal, Withings, and Garmin Connect collect and aggregate this data. In this example, the apps provide value by giving contextualized data to the user.

But, how do these Apps enable their powerful interactions? You guessed it -APIs.

In order to meet growing demands in the market, developers need better tools to be able to iterate faster. What does this actually mean? Developers need to be able to complete the API Lifecycle in less time.

How can we achieve a higher rate of velocity in the API Lifecycle?

Historically, the systems development lifecycle (SDLC), created silos of information and data. Silos of data prevent apps from working together. In order to build functionality, developers relied on extensions to the primary tools.

With the next generation of tools, developers need more built-in functionality. For instance, new innovative approaches to traditional tools sets such as: source code management, configuration injection and versioning, testing and automated deployment are on the horizon.

Developers benefit from easy to use platforms. This holds true even with the evolution of architecture. In some cases, Microservices may provide a few answers.

In case you need a refresher, Microservices is where you design an app as if it were a collection of interconnected services. The goal is to create independently deployable lightweight services. When we look at other styles, common characteristics are more obvious.

For instance, representational state transfer (REST) architecture and microservices are focused on the key concept of interoperability.  However, when it comes to implementation, developers are left to their own devices to figure it out.

In order to take full advantage of the microservices style, a critical part of that process is understanding next generation tooling AND runtime components. As developers, we can include these concepts in the design of our APIs as they are shaped from beginning to end.|||

APIs have three important dimensions and understanding these dimensions and new evolutions in next generation tooling can influence API creation and design.