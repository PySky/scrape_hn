Provides Lua hooks into various portions of the httpd request processing This module allows the server to be extended with scripts written in the Lua programming language. The extension points (hooks) available with include many of the hooks available to natively compiled Apache HTTP Server modules, such as mapping requests to files, generating dynamic responses, access control, authentication, and authorization More information on the Lua programming language can be found at the the Lua website. is still in experimental state. Until it is declared stable, usage and behavior may change at any time, even between stable releases of the 2.4.x series. Be sure to check the CHANGES file before upgrading. This module holds a great deal of power over httpd, which is both a strength and a potential security risk. It is not recommended that you use this module on a server that is shared with users you do not trust, as it can be abused to change the internal workings of httpd.

In the Apache HTTP Server API, the handler is a specific kind of hook responsible for generating the response. Examples of modules that include a handler are , , and . always looks to invoke a Lua function for the handler, rather than just evaluating a script body CGI style. A handler function looks something like this: example.lua

 -- example handler require "string" --[[ This is the default method name for Lua handlers, see the optional function-name in the LuaMapHandler directive to choose a different entry point. --]] function handle(r) r.content_type = "text/plain" if r.method == 'GET' then r:puts("Hello Lua World!

") for k, v in pairs( r:parseargs() ) do r:puts( string.format("%s: %s

", k, v) ) end elseif r.method == 'POST' then r:puts("Hello Lua World!

") for k, v in pairs( r:parsebody() ) do r:puts( string.format("%s: %s

", k, v) ) end elseif r.method == 'PUT' then -- use our own Error contents r:puts("Unsupported HTTP method " .. r.method) r.status = 405 return apache2.OK else -- use the ErrorDocument return 501 end return apache2.OK end This handler function just prints out the uri or form encoded arguments to a plaintext page. This means (and in fact encourages) that you can have multiple handlers (or hooks, or filters) in the same script.

provides a high-level interface to authorization that is much easier to use than using into the relevant hooks directly. The first argument to the directive gives the name of the responsible authorization provider. For any line, will call the authorization provider of the given name, passing the rest of the line as parameters. The provider will then check authorization and pass the result as return value. The authz provider is normally called before authentication. If it needs to know the authenticated user name (or if the user will be authenticated at all), the provider must return . This will cause authentication to proceed and the authz provider to be called a second time. The following authz provider function takes two arguments, one ip address and one user name. It will allow access from the given ip address without authentication, or if the authenticated user matches the second argument: authz_provider.lua

 require 'apache2' function authz_check_foo(r, ip, user) if r.useragent_ip == ip then return apache2.AUTHZ_GRANTED elseif r.user == nil then return apache2.AUTHZ_DENIED_NO_USER elseif r.user == user then return apache2.AUTHZ_GRANTED else return apache2.AUTHZ_DENIED end end The following configuration registers this function as provider and configures it for URL :

Hook functions are how modules (and Lua scripts) participate in the processing of requests. Each type of hook exposed by the server exists for a specific purpose, such as mapping requests to the file system, performing access control, or setting mime types: This is the first hook that will be called after a request has been mapped to a host or virtual host This phase translates the requested URI into a filename on the system. Modules such as and operate in this phase. This phase maps files to their physical, cached or external/proxied storage. It can be used by proxy or caching modules This phase checks whether a client has access to a resource. This phase is run before the user is authenticated, so beware. This phase it used to check the negotiated user ID This phase authorizes a user based on the negotiated credentials, such as user ID, client certificate etc. This phase checks the requested file and assigns a content type and a handler to it This is the final "fix anything" phase before the content handlers are run. Any last-minute changes to the request should be made here. This is where the content is handled. Files are read, parsed, some are run, and the result is sent to the client Once a request has been handled, it enters several logging phases, which logs the request in either the error or access log. Mod_lua is able to hook into the start of this and control logging output. Hook functions are passed the request object as their only argument (except for LuaAuthzProvider, which also gets passed the arguments from the Require directive). They can return any value, depending on the hook, but most commonly they'll return OK, DONE, or DECLINED, which you can write in Lua as , , or , or else an HTTP status code. translate_name.lua

 -- example hook that rewrites the URI to a filesystem path. require 'apache2' function translate_name(r) if r.uri == "/translate-name" then r.filename = r.document_root .. "/find_me.txt" return apache2.OK end -- we don't care about this URL, give another module a chance return apache2.DECLINED end translate_name2.lua

 --[[ example hook that rewrites one URI to another URI. It returns a apache2.DECLINED to give other URL mappers a chance to work on the substitution, including the core translate_name hook which maps based on the DocumentRoot. Note: Use the early/late flags in the directive to make it run before or after mod_alias. --]] require 'apache2' function translate_name(r) if r.uri == "/translate-name" then r.uri = "/find_me.txt" return apache2.DECLINED end return apache2.DECLINED end

The request_rec object has (at least) the following methods: r:flush() -- flushes the output buffer. -- Returns true if the flush was successful, false otherwise. while we_have_stuff_to_send do r:puts("Bla bla bla

") -- print something to client r:flush() -- flush the buffer (send to client) r.usleep(500000) -- fake processing time for 0.5 sec. and repeat end r:addoutputfilter(name|function) -- add an output filter: r:addoutputfilter("fooFilter") -- add the fooFilter to the output stream r:sendfile(filename) -- sends an entire file to the client, using sendfile if supported by the current platform: if use_sendfile_thing then r:sendfile("/var/www/large_file.img") end r:parseargs() -- returns two tables; one standard key/value table for regular GET data, -- and one for multi-value data (fx. foo=1&foo=2&foo=3): local GET, GETMULTI = r:parseargs() r:puts("Your name is: " .. GET['name'] or "Unknown") r:parsebody([sizeLimit]) -- parse the request body as a POST and return two lua tables, -- just like r:parseargs(). -- An optional number may be passed to specify the maximum number -- of bytes to parse. Default is 8192 bytes: local POST, POSTMULTI = r:parsebody(1024*1024) r:puts("Your name is: " .. POST['name'] or "Unknown") r:base64_encode(string) -- Encodes a string using the Base64 encoding standard: local encoded = r:base64_encode("This is a test") -- returns VGhpcyBpcyBhIHRlc3Q= r:md5(string) -- Calculates and returns the MD5 digest of a string (binary safe): local hash = r:md5("This is a test") -- returns ce114e4501d2f4e2dcea3e17b546f339 r:sha1(string) -- Calculates and returns the SHA1 digest of a string (binary safe): local hash = r:sha1("This is a test") -- returns a54d88e06612d820bc3be72877c74f257b561b19 r:construct_url(string) -- Constructs an URL from an URI local url = r:construct_url(r.uri) r.mpm_query(number) -- Queries the server for MPM information using ap_mpm_query: local mpm = r.mpm_query(14) if mpm == 1 then r:puts("This server uses the Event MPM") end r:expr(string) -- Evaluates an expr string. if r:expr("%{HTTP_HOST} =~ /^www/") then r:puts("This host name starts with www") end r:scoreboard_process(a) -- Queries the server for information about the process at position : local process = r:scoreboard_process(1) r:puts("Server 1 has PID " .. process.pid) r:scoreboard_worker(a, b) -- Queries for information about the worker thread, , in process : local thread = r:scoreboard_worker(1, 1) r:puts("Server 1's thread 1 has thread ID " .. thread.tid .. " and is in " .. thread.status .. " status") r:requestbody(filename) -- Reads and returns the request body of a request. -- If 'filename' is specified, it instead saves the -- contents to that file: local input = r:requestbody() r:puts("You sent the following request body to me:

") r:puts(input) r.module_info(module_name) -- Queries the server for information about a module local mod = r.module_info("mod_lua.c") if mod then for k, v in pairs(mod.commands) do r:puts( ("%s: %s

"):format(k,v)) -- print out all directives accepted by this module end end r:loaded_modules() -- Returns a list of modules loaded by httpd: for k, module in pairs(r:loaded_modules()) do r:puts("I have loaded module " .. module .. "

") end r:runtime_dir_relative(filename) -- Compute the name of a run-time file (e.g., shared memory "file") -- relative to the appropriate run-time directory. r:server_info() -- Returns a table containing server information, such as -- the name of the httpd executable file, mpm used etc. r:set_document_root(file_path) -- Sets the document root for the request to file_path r:set_context_info(prefix, docroot) -- Sets the context prefix and context document root for a request r:os_escape_path(file_path) -- Converts an OS path to a URL in an OS dependent way r.strcmp_match(string, pattern) -- Checks if 'string' matches 'pattern' using strcmp_match (globs). -- fx. whether 'www.example.com' matches '*.example.com': local match = r.strcmp_match("foobar.com", "foo*.com") if match then r:puts("foobar.com matches foo*.com") end r:set_keepalive() -- Sets the keepalive status for a request. Returns true if possible, false otherwise. r:make_etag() -- Constructs and returns the etag for the current request. r:send_interim_response(clear) -- Sends an interim (1xx) response to the client. -- if 'clear' is true, available headers will be sent and cleared. r:custom_response(status_code, string) -- Construct and set a custom response for a given status code. -- This works much like the ErrorDocument directive: r:custom_response(404, "Baleted!") r.exists_config_define(string) -- Checks whether a configuration definition exists or not: if r.exists_config_define("FOO") then r:puts("httpd was probably run with -DFOO, or it was defined in the configuration") end r:stat(filename [,wanted]) -- Runs stat() on a file, and returns a table with file information: local info = r:stat("/var/www/foo.txt") if info then r:puts("This file exists and was last modified at: " .. info.modified) end r:regex(string, pattern [,flags]) -- Runs a regular expression match on a string, returning captures if matched: local matches = r:regex("foo bar baz", [[foo (\w+) (\S*)]]) if matches then r:puts("The regex matched, and the last word captured ($2) was: " .. matches[2]) end -- Example ignoring case sensitivity: local matches = r:regex("FOO bar BAz", [[(foo) bar]], 1) -- Flags can be a bitwise combination of: -- 0x01: Ignore case -- 0x02: Multiline search r.usleep(number_of_microseconds) -- Puts the script to sleep for a given number of microseconds. r:dbacquire(dbType[, dbParams]) -- Acquires a connection to a database and returns a database class. -- See 'Database connectivity' for details. r:ivm_set("key", value) -- Set an Inter-VM variable to hold a specific value. -- These values persist even though the VM is gone or not being used, -- and so should only be used if MaxConnectionsPerChild is > 0 -- Values can be numbers, strings and booleans, and are stored on a -- per process basis (so they won't do much good with a prefork mpm) r:ivm_get("key") -- Fetches a variable set by ivm_set. Returns the contents of the variable -- if it exists or nil if no such variable exists. -- An example getter/setter that saves a global variable outside the VM: function handle(r) -- First VM to call this will get no value, and will have to create it local foo = r:ivm_get("cached_data") if not foo then foo = do_some_calcs() -- fake some return value r:ivm_set("cached_data", foo) -- set it globally end r:puts("Cached data is: ", foo) end r:htpassword(string [,algorithm [,cost]]) -- Creates a password hash from a string. -- algorithm: 0 = APMD5 (default), 1 = SHA, 2 = BCRYPT, 3 = CRYPT. -- cost: only valid with BCRYPT algorithm (default = 5). r:touch(file [,mtime]) -- Sets the file modification time to current time or to optional mtime msec value. r:get_direntries(dir) -- Returns a table with all directory entries. function handle(r) local dir = r.context_document_root for _, f in ipairs(r:get_direntries(dir)) do local info = r:stat(dir .. "/" .. f) if info then local mtime = os.date(fmt, info.mtime / 1000000) local ftype = (info.filetype == 2) and "[dir] " or "[file]" r:puts( ("%s %s %10i %s

"):format(ftype, mtime, info.size, f) ) end end end r:setcookie{ key = [key], value = [value], expires = [expiry], secure = [boolean], httponly = [boolean], path = [path], domain = [domain] } -- Sets a HTTP cookie, for instance: r:setcookie{ key = "cookie1", value = "HDHfa9eyffh396rt", expires = os.time() + 86400, secure = true } r:wsupgrade() -- Upgrades a connection to WebSockets if possible (and requested): if r:wsupgrade() then -- if we can upgrade: r:wswrite("Welcome to websockets!") -- write something to the client r:wsclose() -- goodbye! end r:wsread() -- Reads a WebSocket frame from a WebSocket upgraded connection (see above): local line, isFinal = r:wsread() -- isFinal denotes whether this is the final frame. -- If it isn't, then more frames can be read r:wswrite("You wrote: " .. line) r:wsclose() -- Closes a WebSocket request and terminates it for httpd: if r:wsupgrade() then r:wswrite("Write something: ") local line = r:wsread() or "nothing" r:wswrite("You wrote: " .. line); r:wswrite("Goodbye!") r:wsclose() end

Filter functions implemented via or are designed as three-stage non-blocking functions using coroutines to suspend and resume a function as buckets are sent down the filter chain. The core structure of such a function is: function filter(r) -- Our first yield is to signal that we are ready to receive buckets. -- Before this yield, we can set up our environment, check for conditions, -- and, if we deem it necessary, decline filtering a request alltogether: if something_bad then return -- This would skip this filter. end -- Regardless of whether we have data to prepend, a yield MUST be called here. -- Note that only output filters can prepend data. Input filters must use the -- final stage to append data to the content. coroutine.yield([optional header to be prepended to the content]) -- After we have yielded, buckets will be sent to us, one by one, and we can -- do whatever we want with them and then pass on the result. -- Buckets are stored in the global variable 'bucket', so we create a loop -- that checks if 'bucket' is not nil: while bucket ~= nil do local output = mangle(bucket) -- Do some stuff to the content coroutine.yield(output) -- Return our new content to the filter chain end -- Once the buckets are gone, 'bucket' is set to nil, which will exit the -- loop and land us here. Anything extra we want to append to the content -- can be done by doing a final yield here. Both input and output filters -- can append data to the content in this phase. coroutine.yield([optional footer to be appended to the content]) end

Mod_lua implements a simple database feature for querying and running commands on the most popular database engines (mySQL, PostgreSQL, FreeTDS, ODBC, SQLite, Oracle) as well as mod_dbd. The example below shows how to acquire a database handle and return information from a table: function handle(r) -- Acquire a database handle local database, err = r:dbacquire("mysql", "server=localhost,user=someuser,pass=somepass,dbname=mydb") if not err then -- Select some information from it local results, err = database:select(r, "SELECT `name`, `age` FROM `people` WHERE 1") if not err then local rows = results(0) -- fetch all rows synchronously for k, row in pairs(rows) do r:puts( string.format("Name: %s, Age: %s<br/>", row[1], row[2]) ) end else r:puts("Database query error: " .. err) end database:close() else r:puts("Could not connect to the database: " .. err) end end To utilize , specify as the database type, or leave the field blank: The database object returned by has the following methods: -- Run a statement and return the number of rows affected: local affected, errmsg = database:query(r, "DELETE FROM `tbl` WHERE 1") -- Run a statement and return a result set that can be used synchronously or async: local result, errmsg = database:select(r, "SELECT * FROM `people` WHERE 1") -- Create and run a prepared statement: local statement, errmsg = database:prepare(r, "DELETE FROM `tbl` WHERE `age` > %u") if not errmsg then local result, errmsg = statement:query(20) -- run the statement with age > 20 end -- Fetch a prepared statement from a DBDPrepareSQL directive: local statement, errmsg = database:prepared(r, "someTag") if not errmsg then local result, errmsg = statement:select("John Doe", 123) -- inject the values "John Doe" and 123 into the statement end -- Escape a value for use in a statement: local escaped = database:escape(r, [["'|blabla]]) -- Close a database connection and free up handles: database:close() -- Check whether a database connection is up and running: local connected = database:active() The result set returned by or by the prepared statement functions created through can be used to fetch rows synchronously or asynchronously, depending on the row number specified:

 fetches all rows in a synchronous manner, returning a table of rows.

 fetches the next available row in the set, asynchronously.

 fetches row number , asynchronously: -- fetch a result set using a regular query: local result, err = db:select(r, "SELECT * FROM `tbl` WHERE 1") local rows = result(0) -- Fetch ALL rows synchronously local row = result(-1) -- Fetch the next available row, asynchronously local row = result(1234) -- Fetch row number 1234, asynchronously local row = result(-1, true) -- Fetch the next available row, using row names as key indexes. One can construct a function that returns an iterative function to iterate over all rows in a synchronous or asynchronous way, depending on the async argument: function rows(resultset, async) local a = 0 local function getnext() a = a + 1 local row = resultset(-1) return row and a or nil, row end if not async then return pairs(resultset(0)) else return getnext, self end end local statement, err = db:prepare(r, "SELECT * FROM `tbl` WHERE `age` > %u") if not err then -- fetch rows asynchronously: local result, err = statement:select(20) if not err then for index, row in rows(result, true) do .... end end -- fetch rows synchronously: local result, err = statement:select(20) if not err then for index, row in rows(result, false) do .... end end end Database handles should be closed using when they are no longer needed. If you do not close them manually, they will eventually be garbage collected and closed by mod_lua, but you may end up having too many unused connections to the database if you leave the closing up to mod_lua. Essentially, the following two measures are the same: -- Method 1: Manually close a handle local database = r:dbacquire("mod_dbd") database:close() -- All done -- Method 2: Letting the garbage collector close it local database = r:dbacquire("mod_dbd") database = nil -- throw away the reference collectgarbage() -- close the handle via GC Although the standard and functions are freely available, it is recommended that you use prepared statements whenever possible, to both optimize performance (if your db handle lives on for a long time) and to minimize the risk of SQL injection attacks. and should only be used when there are no variables inserted into a statement (a static statement). When using dynamic statements, use or .

Provides a means of adding a Lua function as an output filter. As with input filters, output filters work as coroutines, first yielding before buffers are sent, then yielding whenever a bucket needs to be passed down the chain, and finally (optionally) yielding anything that needs to be appended to the input data. The global variable holds the buckets as they are passed onto the Lua script: --[[ Example output filter that escapes all HTML entities in the output ]]-- function output_filter(r) coroutine.yield("(Handled by myOutputFilter)<br/>

") -- Prepend some data to the output, -- yield and wait for buckets. while bucket do -- For each bucket, do... local output = r:escape_html(bucket) -- Escape all output coroutine.yield(output) -- Send converted data down the chain end -- No more buckets available. end As with the input filter, the output filter supports denying/skipping a filter if it is deemed unwanted: function output_filter(r) if not r.content_type:match("text/html") then return -- Simply deny filtering, passing on the original content instead end coroutine.yield() -- wait for buckets ... -- insert filter stuff here end When a Lua filter is used as the underlying provider via the directive, filtering will only work when the is identical to the . See "Modifying contents with Lua filters" for more information.|||

