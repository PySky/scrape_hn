Object Orientation and Functional aren't mutually exclusive concepts, so you don't really have to choose one or the other. In fact, they're very much complementary. OOP techniques can be used for organising programs into modular components, and combining these components with each other, whereas FP techniques can be used for modelling data structures and transforming them. Erlang is a good example of this, where pure functions are used inside a module, and components are expressed as actors that are combined by message passing.Given that, I'll try explaining a bit of both sides, and how you can combine the two in JavaScript, to take advantage of them. Note, however, that the only thing you should really be interested in is "techniques," rather than buying into a narrow philosophy of how programs should be written. You can switch between techniques and choose the one that feels most adequate for a particular situation, you can't switch philosophies as easily. The more techniques you know, the more powerful and natural combinations you'll be able to come up with for all problems you want to solve.Functional Programming is a model of computation where computations are exclusively expressed by the combination of (mathematical) functions. Mathematical functions are required to be pure, that is, they must not have any kind of side-effect (no mutation, no writing files, no talking to databases, no nothing). An increasing number of programs said to be functional are, of course, not functional at all, they just happen to incorporate functionalLanguages are called "functional" when they encourage, and have a good support for expressing your programs in the functional model. JavaScript is not a functional language, however you can apply functional techniques to programs written in it. Haskell is a functional language, but programs written in Haskell will not necessarily be functional.The major benefits from buying into the functional philosophy are correctness, compositionality, and static reasoning, which helps with testing, debugging, and similar tasks. Incorporating techniques from functional programming will give you varying levels of these benefits.Programs manipulate data. And it is easier to make these manipulations correct if the data you're manipulating fully encodes all of its possibilities in your application's model. In order to do so, it's important to understandData types aren't a concept of functional programming, nor are ADTs, but the latter is mostly used in functional contexts. ADTs allow one to properly encode the possibilities of the data in your program by giving you powerful tools for modelling compound data structures (product types), and one-of data structures (sum types).While, in theory,, in practice this doesn't really matter, as you still get the benefits of properly modelling your data structures into sums and products, rather than just using products, as commonly done in JS.While it's very easy to encode products in JS (objects are naturally products), the language doesn't have a natural support for sums. You can still encode sums structurally:Functional languages support pattern matching, a feature that allows one to tear apart complex data structures in a correct way.Compare:With:The Haskell code, which uses pattern matching, is much clearer on the intent of the code. Furthermore, the JavaScript snippet defines implicit relationships that can be easily violated. What if an object has the property `isBranch` set to true, but has only a `left` property, or has instead of left/right, a `value` property? It also assumes that anything doesn't have `isBranch` set to true is going to be a Leaf node, which might not be true either.While JavaScript does not support pattern matching, short of using something likewith Sweet.js macros, it's possible to have a limited form of it by using dynamic dispatch on objects, which solves the above problem:Functional programming is all about pure functions. While in JS you don't get the compiler to enforce purity, or optimise for it in a lot of cases, besides inlining, pure functions help with testing and debugging, by reducing the amount of state you need to care about for any particular part of your program.Pure functions are lovely. Use them whenever possible.A lot of algorithms are naturally expressed through recursion. And transforming data structures is very natural with structural recursion, as exemplified by the function inverting binary trees above.Given this, a good understanding of, in particular, helps a lot with implementing these transformations in terms of operations that are already available to you in the standard library, or common libraries, such as LoDash or Ramda.Object Oriented Programming is a model of computation where computations are exclusively expressed by communicating objects. Objects, in this context, are. Most of the programs said to be Object Oriented are, of course, not Object Oriented at all, they just happen to incorporate Object Oriented Programming techniques.Again, we call languages "Object Oriented" when they encourage, and have good support for writing programs in the OOP model., however you can apply Object Oriented techniques to programs written in it. Smalltalk is an Object Oriented language, but programs written in Smalltalk will not necessarily be Object Oriented.The major benefits from buying into the Object Oriented philosophy are discoverability (given a reflective environment), modularity, and polymorphism¹, which helps organising programs into logical units, and composing them. Incorporating techniques from Object Oriented programming will give you varying levels of these benefits.Dynamic dispatching is the most important thing in Object Oriented programming. Basically, this means that computations are selected at runtime, depending on the values, rather than statically, depending on the types, static scope, or syntactical structure.This particular feature allows writing generic code on top of an interface, rather than the shape of a particular value. This is very important when you consider modular units of code. For example, suppose you want to write a function that filters any kind of collection. Collections have the most varying forms of storing their values, so it's not possible to write a parametric polymorphic function to handle this case. With Dynamic Dispatching, you can, instead, write several different computations, one for each value, and select between them depending on the value of the collection.In JavaScript, the dispatch is limited to a single value, and it happens when you project a particular property from an object (object.property, or object['property']). This allows us to come up with the following:More powerful techniques, such as multi-methods, multi-dispatching, and predicate dispatching can be easily encoded in JavaScript, although it's harder to optimise them.Another very important technique in Object Orientation is modules. Modules are implementations of a particular interface (for example, Array could be a module if we define an interface for it). The good thing about modules is that they have well-defined interactions and dependencies (even better if you have a structural type system to encode these constraints), and they allow one to just replace implementations of modules without affecting any other part of the code.Ironically,, although the work on Newspeak is also very interesting.In JavaScript, objects are naturally modules, and it's easy to write code for a particular interface, as demonstrated above in the Dynamic Dispatching section. Furthermore, since JavaScript uses a prototype-based OO model, where you only have objects, and objects define their own set of behaviours, encoding more powerful things like (generative) parametric modules is very natural: just write a function that takes in the dependencies for the module and returns an object that uses those dependencies.This allows, for example, avoiding tying your program to a particular implementation, or worse, tying your program to a very specific external system, making it very hard to test.Compare:With:The second code only depends on a module that fulfills the interface "{ readFileSync: (pathname, encoding) -> String }", not on the actual file system. Testing this module, then, becomes trivial: you just pass an object that generates random strings, rather than reading things from the file system directly. Doing an integration test is just as trivial: just pass the correct file system module. Supporting different platforms also becomes trivial: pass a file system module for that particular platform, rather than Node's built-in one.Unfortunately, ES6 modules are second class, and do not have a natural support for (generative) parametric modules, although it would be possible for them to (ML modules are second class, after all). I've stopped following the ES discussions, so I'm not sure if parametric modules are planned. None the less, they are trivial to encode with objects.While Functional programming and Object Oriented programming,, may be incompatible, the techniques used by them aren't. JavaScript does not really optimise for one or the other, so it's possible to mix-and-match the two without many problems.You'll not get all of the benefits of Functional languages by using functional techniques in JS, and you'll not get all of the benefits of Object Oriented languages by using OO techniques in JS, but you'll get a lot of the benefits here, and you can mix-and-match different techniques to avoid problems that only occur in one of the models (such as).¹: There are many forms of polymorphism. Functional programming tends to, usually, use a lot of parametric polymorphism, whereas Object Oriented programming tends to use a lot of subtyping polymorphism and ad-hoc polymorphism. I didn't know how to contrast the two here, but mostly I meant that OO helps making ad-hoc polymorphism (specially when you consider open classes, or things like protocols) less of a hassle.|||

