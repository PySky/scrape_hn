The default stack size on Windows using MS compilers is 1 MiB. You put on the stack several arrays that hold millions of integers and doubles. You said you increased stack size to 4GB. In that case, the following becomes relevant: The reserved memory size represents the total stack allocation in virtual memory. As such, the reserved size is limited to the virtual address range. The initially committed pages do not utilize physical memory until they are referenced; however, they do remove pages from the system total commit limit, which is the size of the page file plus the size of the physical memory. The system commits additional pages from the reserved stack memory as they are needed, until either the stack reaches the reserved size minus one page (which is used as a guard page to prevent stack overflow) or the system is so low on memory that the operation fails. (emphasis mine) Given these definitions, the following lists the limits on 32-bit and 64-bit variants of Windows: Stack data - 1GB (the stack size is set by the linker, the default is 1MB. This can be increased using the Linker property System > Stack Reserve Size) Stack data - 1GB (the stack size is set by the linker, the default is 1MB. This can be increased using the Linker property System > Stack Reserve Size) Note that the limit on static and stack data is the same in both 32-bit and 64-bit variants. This is due to the format of the Windows Portable Executable (PE) file type, which is used to describe EXEs and DLLs as laid out by the linker. It has 32-bit fields for image section offsets and lengths and was not extended for 64-bit variants of Windows. As on 32-bit Windows, static data and stack share the same first 2GB of address space. (emphasis mine) Finally, look closely at the instruction in the beginning of your post: But the error continues to stop at at this line To look more closely at this, I wrote a small program which would generate the same effect as yours (it only "worked" with a 32-bit buildâ€”I am not sure what needs to be done to cause a 64-bit executable to crash): I set the stack size in the linker options to and then ran the program under the debugger. It crashed with a stack overflow, and broke at the same instruction you observed. Scrolling up in the stack checking code, I noted the following comments: ; Handle allocation size that results in wraparound. ; Wraparound will result in StackOverflow exception. As far as I can figure out, the routine is trying to move the top-of-stack down by at a time to reserve the applicable stack size. So, trying to set the stack size to 4 GB seems to be the root cause of your immediate problem. You can try setting it to 1 GB which might solve that problem. Indeed, I changed the stack size for the program above to ( ), and I did not get a stack overflow. I think the fact that does not at the very least warn about an invalid stack size value is a bug. Indeed, looking at the hexdump of an executable built with and comparing it to one built with highlights the problem: Note that is 1,000,000,000 in hex. Looking at the header format, those refer to the entry. That is, when you set stack size to 4 GB (actually, anything above , that has the effect of setting it to zero. While setting a stack size to larger but still unsupported sizes does result in a positive value being set in the executable header, e.g.: the resulting executable cannot be run: C:\...> main Not enough storage is available to process this command. However even though setting the stack to a smaller but still large size may enable your program to run, relying on a huge stack is not necessarily a good idea. The immediate alternative is to allocate those arrays on the heap using malloc and remembering to free them. you need declare and then allocate memory for the array using Enod = malloc(8 * sizeof(*Enod) * 1024 * 1024); /* remember to check that Enod is not NULL */ Answers to this question discuss why the stack is much more constrained. In addition, your code would benefit from replacing arbitrary looking numbers with meaningful mnemonics using defines.|||

