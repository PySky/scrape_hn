Information is ubiquitous, and so is its representation: data. The amount of data produced and necessitated by information technology has seen an explosion in the last few years. Underlying the highly fashionable, even more vague, and, quite often, bullshitty keywords of “Big Data”, “Machine Learning”, “Hadoop” and “MapReduce” is an honest, desperate need for better data management and data processing technologies so that we can keep up with all our smart fridges’ log files, gradually piling up on terabyte-sized SSDs.

Of course, one of the central challenges is still the classic one: storing that data in a sufficiently structured and efficient manner so that computations are easy to perform correctly and quickly. Databases have become increasingly sophisticated and diverse, but due to the nature of human perception of information, one piece of good old technology still possesses the key role: the relational model.

Humans tend to love categories, classes, groups, partitions, clusters and lumps. (And the author of this post apparently loves Thesaurus, too.) I guess it’s because it is easier for us to understand related pieces of information as coarse-grained sets of data — there are simply fewer things to remember. This, and the fact that we are usually not only interested in the raw data itself, but also in the connections between various kinds of data, naturally give rise to the relational model, as it allows one to group related pieces of data into relations (tables), and express further connections between tables by means of keys.

The usual implementation of the relational model in RDBMSs is based on the notion of primary keys and foreign keys. Primary keys uniquely identify a record/row within its own table, while foreign keys ought to represent connections between records across tables. Conceptually, this is the right thing, except that it is strongly coupled with an implementation detail. But let’s not get ahead of ourselves — let me tell you a little story first.

I have always had a bad feeling about database management. In elementary school, this was justified to some extent by the fact that we were forced^W expected to use Microsoft Access. (Because, you know, what else would you indoctrinate future IT people for, from the very beginning of their life, if not the unconditional use of platform-specific, black-box, proprietary technologies? But that’s another story.) Needless to say, I’ve discovered SQL early on and fiddled with it instead of trying to understand the stupid convoluted GUI offered by almighty Access. Then, during university, we were taught proper relational database theory, which was orders of magnitude more professional, a lot more flexible and expressive, and, unsurprisingly, appeared to be a way more appropriate tool.

Still, I didn’t like it. I didn’t enjoy it. I found it to be disturbingly inconvenient, often. My brain felt turned inside-out more than it did when I tried Haskell for the first time, and that kind of thing doesn’t happen frequently to me. And for this very reason, it just struck me as wrong. I knew that something as fundamental as a relational database just Can’t Be Bad™.

For some time, I thought that maybe NoSQL was the answer. Not because of SQL itself, although SQL is ugly. But I tried to imagine what SQL would look like if it had a decent syntax, and I quickly realized it was something in the underlying semantics that I detest. But I couldn’t tell exactly which part of it was the culprit.

After my involvement with building applications on top of NoSQL stores (mostly MongoDB), it came to me that I still badly needed relational modeling in most of the cases, and a simple document store wasn’t quite up to the task. So the problem wasn’t the relational model itself, it wasn’t the appearance of SQL, it wasn’t the APIs provided by databases. Then what was it?

For me, writing SQL is like writing machine code: both languages are designed for immediate, close interaction with their respective systems, the RDBMS and the CPU. However, for higher-level, everyday needs, they are tedious to write by hand and hard to maintain. Similarly, using an ORM that maps almost isomorphically to an RDBMS is like writing assembly by hand. In assembly, we get easier-to-read mnemonics rather than raw binary or hex opcodes. In ORMs, we get pretty objects, strings, numbers and arrays, maybe even in a (statically) typed manner, rather than raw records. But still, we have to think about how the underlying database implements relations. For example, the popular Hibernate framework ships with its own query language, HQL. The designers thereof aren’t even hiding the fact that there’s little abstraction going on when it comes to writing queries: the language is advertised as being heavily inspired by SQL, and it features explicit JOINs. And that is where my gut tells me it’s just not the right level of abstraction.

Why, you might ask. Well, here’s the thing: JOINs are backwards. Or at least they are backwards when used in conjunction with the usual foreign key model.

Nowadays, programmers tend to think about data in terms of objects. Some objects have identity, others only have value, and they usually contain scalars, other objects as values, and references or pointers to other objects. It is these references and pointers that describe relations between objects. We are used to reasoning about graphs of objects built up with pointers, and it is a very natural way of organizing data. Unfortunately, the representation based on foreign keys doesn’t quite match this mindset.

Conversely, foreign keys are like backwards pointers. It tends to be hard to represent arrays in RDBMSs, and thus one-to-many relations are usually implemented by having the “children” (the “many” side of the relation) contain a foreign key to the “parent” record. You might have noticed that I used terminology that’s closely related to trees, and that is not accidental: trees arise in many practical applications; in fact, they are the most common type of object graph in my experience. Consequently, those who think top-down rather than bottom-up (and I must admit, I’m guilty of this myself) will quickly find themselves in distress as they are trying to traverse such an inside-out tree starting with the root.

Many-to-many relations are even worse: the canonical solution for representing them is creating a so-called junction table which is in a one-to-many relation with both sides of the original relation. It should be quite obvious how error-prone and painful it is to query and modify the structure of such a relation when things get nontrivial. While I am certainly able to wrap my head around a query relating several junction tables, I’d rather not have to.

So, what I would like to work with is a query language that is to SQL as C++ or Rust is to machine code. A query language that lets me manipulate records as if they were collections, arrays or sets of objects, with pointers or sets and arrays of pointers going out of instances wherever relevant. Ideally, the language should have a limited set of LINQ-style core operators, augmented with functional-algebraic and object-oriented data types, on which one could build functions that would be optimized and translated to whatever target query language is desired.

While we are at data types, let me mention another problem with high-level modeling in contemporary database systems. Tables (in the case of relational engines) and documents (in the case of document stores) are rarely statically or strictly typed, and even the static typing we do get is often loose and in fact unsound. It’s enough to just have a look at some popular SQL dialects and their implementations, for instance. Nullable-by-default is the norm, despite being proven wrong by modern (primarily functional) languages. Many queries compile that should not in fact compile, so corresponding structural errors are only apparent if ever we attempt to execute such an erroneous query. Many useful, higher-level types are also omitted from most query languages. A prime example is , or the algebraic sum type. Database engineers typically resort to stringly-typing their columns that really should have been enums. At least, SQL-based databases could technically implement an enum type, but what about engines that tie their interface to a particular format, e.g. JSON? The JSON specification doesn’t provide a way of defining enums, which is great, because JSON was merely meant to be a data interchange format, not a database. But then a significant amount of abstraction and safety is lost, and a typo in any string literal that is semantically an enum case can have catastrophic consequences.

One piece of software that comes quite close to fulfilling my expectations is the famous Core Data framework by Apple. It still has certain characteristics that I find undesirable nonetheless. First of all, it’s not cross-platform. But more importantly, it’s not primarily a database or a database wrapper; what it really, truly is is an in-memory object graph manager, meaning that one has to load all objects into memory in order to be able to work with them. Billions of records? Forget it. My wish is something that abstracts over the so-called Object-Relational Impedance mismatch, so that it looks and feels like I’m operating on in-memory objects, but when backed by an RDBMS, it’s not actually the case (until I request the final result set of a query). Core Data is also strongly coupled to its Objective-C interface, and it doesn’t have its own statically-typed query language — queries are constructed dynamically, at run time. Furthermore, partly because of the lack of strictly-enforced static typing, partly due to some design decisions in its API, it’s easy to use it incorrectly. And albeit its programming model is not particularly hard to learn, I still would like to have my queries double checked by a compiler at build time rather than have my app crash with a mysterious message about things that were null but should not have been so.

So what do I do now? If you know me, you perhaps guessed it. I’m trying to design and implement a data abstraction layer that tries to transform memory-oriented query operations into whatever is relevant for one’s choice of database. I will see how it all works out. Wish me luck.|||

