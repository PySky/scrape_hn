Beta-quality. See the last section of this README.

Bootsnap is a library that plugs into a number of Ruby and (optionally) and methods to optimize and cache expensive computations. See the How Does This Work section for more information.

Next, add this to your boot setup immediately after (i.e. as early as possible: the sooner this is loaded, the sooner it can start optimizing things)

Protip: You can replace with using this trick. This will help optimize boot time further if you have an extremely large .

Bootsnap is a library that plugs into a number of Ruby and (optionally) and methods. These methods are modified to cache results of expensive computations, and can be grouped into two broad categories:

(This work is a minor evolution of bootscale).

Upon initialization of bootsnap or modification of the path (e.g. ), will fetch a list of requirable entries from a cache, or, if necessary, perform a full scan and cache the result.

Later, when we run (e.g.) , ruby would iterate through every item on our , looking for , , and so on. Bootsnap instead looks at all the cached requirables for each entry and substitutes the full expanded path of the match ruby would have eventually chosen.

If you look at the syscalls generated by this behaviour, the net effect is that what would previously look like this:

Exactly the same strategy is employed for methods that traverse if the option is given to .

The following diagram flowcharts the overrides that make the features work.

Bootsnap classifies path entries into two categories: stable and volatile. Volatile entries are scanned each time the application boots, and their caches are only valid for 30 seconds. Stable entries do not expire -- once their contents has been scanned, it is assumed to never change.

The only directories considered "stable" are things under the Ruby install prefix ( , e.g. or ), and things under the (e.g. ). Everything else is considered "volatile".

In addition to the source, this diagram may help clarify how entry resolution works:

It's also important to note how expensive s can be. If ruby invokes , but that file isn't on , it takes filesystem accesses to determine that. Bootsnap caches this result too, raising a without touching the filesystem at all.

(A simpler implementation of this concept can be found in yomikomu).

Ruby has complex grammar and parsing it is not a particularly cheap operation. Since 1.9, Ruby has translated ruby source to an internal bytecode format, which is then executed by the Ruby VM. Since 2.2, Ruby exposes an API that allows caching that bytecode. This allows us to bypass the relatively-expensive compilation step on subsequent loads of the same file.

We also noticed that we spend a lot of time loading YAML documents during our application boot, and that MessagePack and Marshal are much faster at deserialization than YAML, even with a fast implementation. We use the same strategy of compilation caching for YAML documents, with the equivalent of Ruby's "bytecode" format being a MessagePack document (or, in the case of YAML documents with types unsupported by MessagePack, a Marshal stream).

These compilation results are stored using s on the source files. This is likely to change in the future, as it has some limitations (notably precluding Linux support except where the user feels like changing mount flags). However, this is a very performant implementation.

Whereas before, the sequence of syscalls generated to a file would look like:

With bootsnap, we get:

Bootsnap writes two attached to each file read:

If the key is valid, the result is loaded from the value. Otherwise, it is regenerated and clobbers the current cache.

This diagram may help illustrate how it works:

Imagine we have this file structure:

When we call without bootsnap, Ruby would generate this sequence of syscalls:

With bootsnap, we get:

If we call without bootsnap, we get:

...and if we call with bootsnap, we get...

We use the features in production and haven't experienced any issues in a long time.

The features work well for us in development on macOS, but probably don't work on Linux at all.

should be completely safe, but we don't really use it because some people like to use tools that make use of instructions.|||

bootsnap - Boot large ruby/rails apps faster