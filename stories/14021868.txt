webpack bits: Getting the most out of the CommonsChunkPlugin() From time to time, the webpack core team loves to get the community involved on Twitter, and share bits and pieces of knowledge in a fun and informative way. This time, the ‚Äúrules to the game‚Äù were simple. Install , generate a fancy colorful image of all of your bundles, and share it with me. In return, the webpack team offered to help identify any potential issues we could spot! The most common theme was code duplication: Libraries, components, code was duplicated across multiple [sync or async] bundles! Case One: Many vendor bundles with duplicate code This is a specimen example. Thank you Swizec for letting me share it. Swizec Teller was kind enough to share one of his builds (which in fact is built for over 8‚Äì9 standalone single-page applications ). I chose this example out of all of them because there so many great techniques we can identify from it. So lets look at this in more detail:

We can infer quite a few things from this (without looking at the actual configuration). Each single-page app is using a that targets just that entry point, and its vendor code. This creates a bundle with only modules that come from node_modules folder, and another bundle with just application code. The configuration portion was even provided: The variable most likely represents each of the individual entry points. Below are a few areas that I circled that could use some improvement. What we see above is many large libraries like momentjs, lodash, and jquery being used across 6 or more vendor bundles. The strategy for adding all vendors into a separate bundle is good, but we should also apply that same strategy across all vendor bundles. I suggested that Swizec add the following at the end of his plugins array: What we are telling webpack is the following: Hey webpack, look across all chunks (including the vendor ones that were generated) and move any modules that occur in at least 6 chunks to a separate file. In this case it looks like the file was named ‚Äúmanifest.js‚Äù? As you can see now, all of those modules were extracted into a separate file, and on top of that, Swizec reported that this decreased overall application sizes by 17%! This is, in fact, a very impressive use of code splitting. And look at all the pretty colors üíì So this amount of duplication wasn‚Äôt as severe in terms of overall code size, however, when you look at the full size image below, you can see the exact same 3 modules across every async chunk.

As you can see above, the same 2‚Äì3 components are used across all 40‚Äì50 async bundles. So how do we solve this with The technique will be very similar to the first, however we will need to set the property in the configuration option, to as seen below: In the same way‚Ää‚Äî‚Ääwebpack will scan all chunks and look for common modules. Since , only code split bundles will be scanned. Because we did not specify the value defaults to 3. So what webpack is being told is: Hey webpack, look through all normal [aka lazy loaded] chunks, and if you find the same module that appears across 3 or more chunks, then separate it out into a separate async commons chunk. Here is what the result was: There is likely room to even play with a larger minChunks value here to result in a smaller commonlazy.js bundle. Now the async chunks are extremely tiny, and all of that code has been aggregated into one file called ¬†. Since these bundle were already pretty tiny, the size impact wasn‚Äôt very noticeable until second visit. Now there is far less data being shipped per code split bundle and we are saving users load time and data consumption by placing those common modules into a separate cacheable chunk. So what if you want to have more control? There are scenarios where you don‚Äôt want to have a single shared bundle because not every lazy/entry chunk may use it. The property also takes a function!! This can be your ‚Äúfiltering predicate‚Äù for what modules are added to your newly created bundle. Below are examples of Yo webpack, when you come across a module whos absolute path matches lodash or momentjs, and occurs across 3 separate entries/chunks, then extract those modules into a separate bundle. You could apply this same behavior to async bundles by setting `async: true` also! With this you can create smaller subsets of cacheable vendors for specific entries and bundles. In the end, you may wind up with something that looks like this: EDIT (April 1st): I stated that you could use filename with minChunks, but we prevent this now as of webpack 2.3.2+. There is no silver¬†bullet! may be powerful, but keep in mind that each one of these examples is tailored to the application it is applied to. So before you copy-pasta these snippets in, take advice from Sam Saccone and Paul Irish and MPDIA first to make sure you apply the right solution.|||

From time to time, the webpack core team loves to get the community involved on Twitter, and share bits and pieces of knowledge in a fun and informative way. This time we talk CommonsChunkPlugin()