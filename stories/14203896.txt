This page enumerates various oddities of the x86/x64.

Most are implemented and tested in my CoST (Corkami Standard Test) file.

this topic was presented in 2011 at Hashdays (video available) and BerlinSides (screencasts available)

An instruction is limited to 15 bytes on recent CPUs (it changed over time): for example, while a preceded by 14 useless prefixes is valid,

adding one more prefix will reach the limit and trigger an exception:

However, it's possible to almost reach that limit with legitimate operations:

VirtualPC has been known to be incorrectly ignoring the 15 bytes limit.

refers to two different instructions:

MMX and FPU registers are overlapping, but in opposite directions: 0, 1,2,3... mapped to 7,6,5...

Thus, a single FPU operation on will modify , , but also (and , under XP).

On 32bit Windows, GS is not saved in the execution context: when the OS switches from an application to another, the content of GS is lost. This can be used as an anti-emulator or an anti-stepping: after some time of execution, GS will eventually be reset:

At any defined point of execution (!EntryPoint, !DllMain, TLS...), registers might have different values, depending on the OS.

And, at any point of execution:

These values are currently being collected in the [InitialValues Initial Values page].

is an alias mnemonic of (which does nothing, as no flag are affected by ): the whole 90-97 range is actually .

However, has another encoding, which is not considered a . And, on 64 bits, it clears the upper 32 bits of . So, not all are nops.

Hopefully, 90 is truly a , even in 64 bits.

, are opcodes that affect both source and target operands (like ).

Moreover, they can operate on different parts of the same register, which has the potential to break trivial logic analyzers:

is officially defined to use only 10/0Ah as a default operand, but can just use any other operand.

it makes it the first Add and Multiply opcode, as .

is officially undefined on WORDS. In reality, it just clears the register, unexpectedly.

to effectively swap contents, one can use

The opcode implements the full algorithm with a single operation, however, it's not the commonly used CRC32 (used in Zip), but actually the CRC-32C (Castagnoli CRC-32), which uses a different polynomial.

While it's technically the same algorithm as the 'common' CRC32, it uses a different seed, so it returns different results, thus it's useless for Zip, and all the countless applications of the deflate algorithm.

It's still usable independently as a checksum, and is actually used in network protocols such as iSCSI, SCTP; it's actually more efficient than the standard CRC32 (when used for recovery purposes), but it's just incompatible.

by the usual standards, it should have been decoded as instead, which would be invalid.

Even though selectors are WORDS-sized registers, like standard registers such as AX, they're not pushed on the stack the same way.

no other word is changed.

are undefined when its source is 0. In practice, the target register is not modified.

(Leading Zero CouNT) is an opcode created in 2007, only supported by AMD in their Barcelona architecture and later (it's planned in Intel Haswell for 2013, along with its counterpart ).

Recent opcodes would usually trigger an exception when executed on a CPU not supporting them.

However, this one is mapped on (Bit Scan Reverse) with an prefix, so it will not trigger any exception on a CPU that doesn't support it:

if is supported by the CPU:

It makes an odd exception-less AMD detector (for now): besides, with a null source, will return a null value, while will leave the target unmodified.

Shift Arithmetic Left (the opcode with modRM 110) is identical to SHL (opcode with modRM 100), and is usually encoded directly as SHL: this means that assemblers always generates the SHL opcode, so SAL is sometimes totally ignored by disassemblers/emulators/...

It's informally called SAL, because it's technically a different opcode (in hex), but functionally, it's the same as SHL.

and on the following opcodes:

Windows 7 just avoids the problem altogether by triggering an ILLEGAL INSTRUCTION on all invalid opcodes, no matter what, including invalid use of LOCK: prefix. No parsing, no mistake !

On the other hand, is wrongly handled by Windows 7. It's an illegal instruction, and while it triggers correctly an INVALID LOCK SEQUENCE exception on XP, it doesn't trigger any exception under Windows 7. It's invalid, so can't be executed, yet triggers no exception, so it just hangs, like an infinite loop, but without crashing.

even more exceptional, the OS patches the opcode: executing turns it into .

Like , they work on DWORD or WORD on registers, but only on WORD in memory.

it's the same for .

has an alternate encoding that is sometimes forgotten, as it's never generated by compilers or assemblers.

is a recent opcode that just returns the usual result to eax/edx, and also changes ECX: it's loaded with the low-order 32-bits of IA32_TSC_AUX MSR ... which means most of the time, 0.

There are many opcodes that are never (or in extreme cases) generated by compilers nowadays, that still fully work under modern CPUs. The list is long: xadd, aaa, daa, aas, das, aad, aam, l*s, bound, arpl, xlatb, lar, verr*, cmpxchg*, lsl...

For example, Here is some code, fully working under a modern CPU, but obfuscated by its obsolescence:

Intel Haswell will introduce very useful opcodes (on general registers) such as:

which is functionally equivalent to 8086 instructions (from 1978):

In 64 bits, opcodes are zero-extending on 32 bits registers.

all do what you would expect.

but on the other hand,

On a 64 bits CPU, the cpu can just change from/to 32b mode by jumping to a properly defined selector. In short, changing the number of bits just mean jumping to a different value of CS.

For example, in a 64b version of windows, selector 33h is for 64b. Jumping to it from a 32b process, then jumping back, will switch to 64b, then back to 32b. It's as simple as that.

Since there are some opcodes specific to 32 bits mode (arpl, ...), and others specific to 64 bits mode (movsxd, ...), the same hex data can lead to completely different disassembly, just because CS is different at the start.|||

docs - documentations, slides decks...