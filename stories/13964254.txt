Schema migrations are without doubt the most cumbersome and annoying part of working with SQL databases. So much so that some people think that schemas themselves are bad!

But schemas are actually good. Enforcing data consistency and structure is a good thing. It’s the migration tooling that is bad, because it’s harder to use than it should be. is an attempt to change that, and make migrations easy, safe, and reliable instead of something to dread.

Think of as a diff tool for schemas¶ Suppose database A and database B have similar but slightly different schemas. will detect the differences and output the SQL needed to transform A to B. This includes changes to tables, views, functions, indexes, constraints, enums, sequences, and installed extensions. You can use as a library to build your own migration scripts, tools, etc. Installing migra also installs the command, so you can use it as follows: If b is the target schema, then a new column and constraint needs to be applied to a to make it match b‘s schema. Once we’ve reviewed the autogenerated SQL and we’re happy with it, we can apply these changes as easily as: $ migra --unsafe postgresql:///a postgresql:///b > migration_script.sql # Then after careful review (obviously)... $ psql a --single-transaction -f migration_script.sql

Migrations can never be fully automatic. As noted above ALWAYS REVIEW MIGRATION SCRIPTS CAREFULLY, ESPECIALLY WHEN DROPPING TABLES IS INVOLVED. Best practice is to run your migrations against a copy of your production database first. This helps verify correctness and spot any performance issues before they cause interruptions and downtime on your production database. will deliberately throw an error if any generated statements feature the word “drop”. This safety feature is by no means idiot-proof, but might prevent a few obvious blunders. If you want to generate “drop ...” statements, you need to use the flag if using the command, or if using the python package directly, to false on your object.

Here’s how the migra command is implemented under the hood (with a few irrelevant lines removed). As you can see, it’s pretty simple ( here is a context manager that creates a database session from a database URL). Here the code just opens connections to both databases for the Migration object to analyse. generates the SQL statements for the changes required, and adds to the migration object’s list of pending changes. The necessary SQL is now available as a property.

plays nicely with extensions. Schema contents belonging to extensions will be ignored and left to the extension to manage. Only SQL/PLPGSQL functions are confirmed to work so far. ignores functions that use other languages.

Assuming you have pip installed, all you need to do is install as follows: If you don’t have psycopg2 (the PostgreSQL driver) installed yet, you can install this at the same time with:|||

