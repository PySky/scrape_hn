The OpenZFS Intent Log (ZIL) is used to ensure POSIX compliance of certain system calls (that modify the state of a ZFS dataset), and protect against data loss in the face of failure scenarios such as: an operating system crash, power loss, etc. Specifically, it’s used as a performance optimization so that applications can be assured that their given system call, and any “user data” associated with it, will not be “lost”, without having to wait for an entire transaction group (TXG) to be synced out (which can take on the order of seconds, on a moderately loaded system).

So how does this process work? How are these system calls tracked? This post will attempt to explain how the system calls enter the ZIL, and how they’re tracked by the in-memory portion of the ZIL. What isn’t covered in this post is how the in-memory representation of the system calls get written to disk, nor how the on-disk ZIL is used to “replay” the system calls after a failure event.

Much like how ZFS’s DMU layer operates on the notion of “transactions”, so does the ZIL. For each system call that modifies a dataset’s state, a ZIL transaction is created; referred to as an in the code and this document. It’s important to note, these ’s are created for “synchronous” system calls, as well as “asynchronous” ones. For example, an will be generated by an application calling on a ZFS dataset, whether the flag is used or not. Additionally, all system calls that modify a dataset will cause an to be generated; e.g. , , , etc. all will generate an unique to that system call.

Each is composed of an , as well as a system call specific component. The portion looks like this:

And for a system call, the structure would be tacked onto the end of the ; this structure looks like this:

Thus, the in-memory representation for a actually looks like the following (assuming a small amount of data is being written):

The portion of the structure that’s common to all types starts at offset 0, the write specific portion immediately follows the , and then finally the user-data that is being written.

Since the last structure depicted in the previous section doesn’t actually exist, it’s important to understand how the code is able to determine which structure follows the portion of an ; since it could be any one of the many options (e.g. , , , etc).

The contained within the is used for this purpose. It contains an field, which can be used to determine the ’s type. For example, if the was for a , would equal , and the could be obtained like so:

Now that we have a brief understanding of what an is, lets look at how these are generated and added to the ZIL; we’ll be using as the example code path.

The first line of code within that pertains to the ZIL’s machinery is this:

In order to manipulate the ZIL, a pointer to the ZIL structure (i.e. the ) is needed. This is obtained using the (passed in as a parameter to ) to extract a pointer to the corresponding ; the field of the holds a pointer to the . Once we have the for this specific file, it’s trivial to use its field to access the , and then the field to access the . It’s worth noting that the is shared across all files in the same dataset (i.e. there’s a single ZIL per ZFS dataset).

Once the structure is obtained, the next line within pertaining to the ZIL is this one:

The function is used to create new s, as well as insert them into one of the ZIL’s list of transactions.

Inside of , the function is used to allocate one or more structures to represent the system within the in-memory portion of the ZIL. That can be seen here:

Where simply allocates and initializes the in-memory structure:

Thus, for a single (and single call to ), 1 or more s will be created to represent the system call.

At this point, the s representing the will have been allocated and initialized, but they’re not yet part of the ZIL. In order to add the s to the ZIL, the function is used. Expanding the previous code snippet from , we can see that is called immediately after the individual s are created and initialized:

The purpose of is to insert the new into one of the ZIL’s list of transactions; the details of that process is covered next (it’s complicated enough to warrant a new section).

In order to fully understand how a given gets inserted into the in memory representation of the ZIL (via ), one has to understand a few things about the :

Below is a diagram that attempts to illustrate this (it’s not as complicated as the above explanation might sound):

So, when is called in the context of , the will be inserted into one of ’s lists described in the previous section. The following logic/criteria is used to decide which list to use, when inserting the new :

Once the has been assigned to either the or one of the lists (contained in the ), the work of is finished. This specific system call has been recorded and inserted into the in-memory representation of the ZIL, but this record will still be lost if a power loss were to happen at this point.

In order for the record of the to persist in the event of a power loss (or an equivalent operating system crash), the s need to be written to the on-disk representation of the ZIL. Notes on that process will be left for another post.|||

