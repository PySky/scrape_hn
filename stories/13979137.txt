The comparison will follow the flow of the HIC.

Compilers often provide features beyond those defined in the Standard, and unrestricted usage of such features will likely hamper code portability. To this end code should be routinely parsed with a separate compiler or code analysis tool apart from the compiler used for production purposes.

Compilers often provide features beyond those defined in the Standard, and unrestricted usage of such features will likely hamper code portability. To this end Ada compilers provide the Ada profile No_Implementation_Extensions, which enforces the restriction to Standard Ada in a standard way. The only thing not caught by this profile is the use of implementation-defined library packages, such as the GNAT packages for the GNAT compiler. Those packages can be caught by adding the No_Dependence profile.

For the purposes of this rule, missing else and default clauses are considered also.

If a statement cannot be reached for any combination of function inputs (e.g. function arguments, global variables, volatile objects), it can be eliminated.

While Ada contains the same rule, Ada compilers perform reachability analysis and report compilation errors when code is not reachable.

Ada compilers identify missing others clauses in case statements when all possible values are not explicitly included in a case statement.

An expression statement with no side effects can be removed or replaced with a null statement without effecting behavior of the program.

Similarly, it is sometimes possible to simplify an expression by removing operands that do not change the resulting value of the expression, for example by multiplying by 1 or 0.

Redundant code causes unnecessary maintenance overhead and may be a symptom of a poor design.

The corresponding Ada rule would be identical. This rule applies to any programming language.

Incrementing an object of type bool results in its value being set to true. This feature was deprecated in the 1998 C++ Language Standard and thus may be withdrawn in a later version.

Prefer to use an explicit assignment to true.

The Ada Boolean type is an enumerated type with the values of (False, True). Ada does not allow arithmetic operations on enumerated types. Furthermore, Ada does not provide an increment operator.

Most compilers ignore the register keyword, and perform their own register assignments. Moreover, this feature was deprecated in the 2011 Language Standard and thus may be removed in a later version.

Ada does not provide any equivalent to the register keyword in C++.

The C standard library headers are included in C++ for compatibility. However, their inclusion was deprecated in the 1998 C++ Language Standard and thus may be withdrawn in a later version.

Ada does not provide a preprocessor and does not interface with C or C++ programs at the source code level.

The following STL features were deprecated in the 2011 C++ Language Standard and thus may be withdrawn in a later version:

Of particular note is std::auto_ptr as it has been suggested that a search and replace of this type to std::unique_ptr may uncover latent bugs to the incorrect use of std::auto_ptr.

Avoid the use of the language features listed in Appendix J of the Ada 2012 Language Reference Manual. Use Ada 2012 aspect specifications instead. Avoiding Annex J features can be enforced through the use of the profile No_Obsolescent_Features.

Specifying an exception specification using throw( type-id-list ) has been deprecated in the 2011 C++ Language Standard and thus may be removed in a future version.

The new syntax is to use noexcept or noexcept( expr).

Ada does not have an equivalent to either noexcept or noexcept(expr). In C++ the noexcept keyword verifies that no exception is thrown in a specified function. The noexcept(expr) declares that a function may throw exceptions for some types but not other types. Both forms of noexcept return a Boolean result.

The SPARK subset of Ada prohibits exceptions and is able to prove that a subprogram will not raise an exception. Exceptions are prohibited because of the difficulty in formally proving the correctness of a program which raises exceptions.

Tab width is not consistent across all editors or tools. Code indentation can be especially confusing when tabs and spaces are used interchangeably. This may easily happen where code is maintained in different editors.

In string and character literals \t should be used in preference to a direct tab character.

Use of tabs in Ada source code is subject to the same editor and tool variations as use of a tab in C++ source code.

Insertion of a tab character in a string or character literal or variable should be use Ada.Characters.Latin_1.HT.

Trigraphs are special three character sequences, beginning with two question marks and followed by one other character. They are translated into specific single characters, e.g. \ or ^. Digraphs are special two character sequences that are similarly translated.

Ada does not provide digraph or trigraph sequences.

The scope of C++ comments is clearer; until the end of a logical source line (taking line splicing into account). Errors can result from the use of C comments.

Ada does not allow the use of C comments.

Source code should always be under version control. Therefore keeping old code in comments is unnecessary. It can make browsing,  searching, and refactoring the source code more difficult.

The same rule should apply to any programming language.

Similarity of identifiers impairs readability, can cause confusion and may lead to mistakes.

Names should not differ only in case (foo/Foo) or in the use of underscores(foobar/foo_bar). Additionally, certain combinations of characters look very similar.

Note: This rule does not require that an identifier cannot be reused.

Ada identifiers are case-insensitive, thus (foo/Foo) are treated as the same identifier.

Ada compilers identify duplicate definition of identifier within the same scope.

The C++ Standard permits string literals with the following encoding prefixes: u, U, u8, L. A program that concatenates a pair of string literals with u8 and L prefixes is ill-formed.

The result of the remaining prefix combinations are all implementation defined. For this reason encoding sequences should not be mixed.

Ada provides multiple character encoding sequences. Each sequence is a distinct type and therefore each string type is unique. Ada does not allow mixing data types within a single array.

Octal constants are specified with a leading digit 0; therefore, literal 0 is technically an octal constant.

Do not use any other octal literals, as based on unfamiliarity, this could be confusing and error prone.

Ada allows the use of any number base from 2 through 16. A literal of a particular number base is expressed as base#digits#  (e.g 2#111# is the binary equivalent of 7 base 10) except for base 10, which is implied by simply expressing the digits. Therefore, 11 and 011 are interpreted as 11 base 10.

The 2011 C++ Language Standard introduced the nullptr keyword do denote a null pointer constant.

The NULL macro and constant expression 0 can be used in both pointer contexts and integral contexts. nullptr, however, is only valid for use in pointer contexts and so cannot be unexpectedly used as an integral value.

Ada access types are functionally equivalent to pointers but are not pointers. Ada access types can be set to null, which is not a numerical value and cannot be confused as an integral value. The address of a variable can be set using with address aspect of a variable declaration:

Reusing the same identifier for different declarations is confusing and difficult to maintain. If the hiding declaration is later removed, or the identifier is renamed, a compilation error may not be generated, as the declaration that was previously hidden will now be found.

While hidden namespace scope identifiers can still be accessed with a fully qualified name, hidden block scope identifiers will not be accessible.

In C++ it is possible for the same identifier to refer to both a type and an object or a function. In this case the object or function will hide the type.

Use of an identifier in a local scope that matches a visible identifier in a dependent package will result in a compiler error. Use of an identifier in an inner block will hide the use of the same identifier an enclosing block.

Ada does not allow an identifier to refer to both a type and an object or a function within the same or enclosing scopes.

A declaration for a function should not be common to its definition, any redeclarations, and any calls to it.

To ensure that the same type is used in all declarations, functions should always be declared at namespace scope(See Rules 7.4.3: “Ensure that an object or a function used from multiple translation units is declared in a single header file” and 7.4.1: “Ensure that any objects, functions, or types to be used from a single translation unit are defined in an unnamed namespace in the main source file”).

Ada provides the package construct to enforce name space and encapsulation. Any type, object, subprogram, or task used by more than one compilation unit must be declared within a package. Ada provides no other means to share declarations between compilation units.

Ada does allow a single subprogram or task to define types, objects, subprograms or tasks to be used only within the defining subprogram or task.

Variables with linkage (and hence static storage duration), commonly referred to as global variables, can be accessed and modified from anywhere in the translation unit if they have internal linkage, and anywhere in the program if they have external linkage. This can lead to uncontrollable relationships between functions and modules.

Additionally, certain aspects of the order of initialization of global variables are unspecified and implementation defined in the C++ Language Standard. This can lead to unpredictable results for global variables that are initialized at run-time (dynamic initialization).

This rule does not prohibit the use of a const object with linkage, so long as:

It is initialized through static initialization

The object is no ODR used

The order of initialization of block scope objects with static storage is well defined. However, the lifetime of such an object ends at program termination, which may be incompatible with future uses of the code, e.g. as a shared library. It is preferable to use objects with dynamic storage duration to represent program state, allocated from the heap or a memory pool.

The only way to share variables across compilation units in Ada is by declaring those variables within a package. The order of initialization of constants is controlled by package elaboration rules. While Ada does provide default elaboration rules, it also provides elaboration pragmas allowing the programmer to specify elaboration order for packages.

The lifetime of a variable with automatic storage duration ends on exiting the enclosing block. If a reference or a pointer to such a variable is returned from a function, the lifetime of the variable will have ended before the caller can access it through the returned handle, resulting in undefined behavior.

When an object is destroyed in Ada, whether the object was created through allocation from a storage pool, or on the program stack, the Finalize procedure for that object is called. There are no exceptions in Ada.

The C++ Standard defines 4 kinds of storage duration:

The lifetime of objects with the first 3 kinds of storage duration is fixed, respectively:

Therefore, undefined behavior will likely occur if an address of a variable with automatic storage duration is assigned to a pointer with static storage duration, or one defined in an outer block. Similarly, for a thread_local  variable aliased to a pointer with static storage duration.

If using high_integrity::thread, then references or pointers with local storage duration should not be passed into threads that have the high_integrity::DETACH property.

Objects with non-trivial destructors and automatic storage duration have their destructors called implicitly when they go out of scope. The destructor will be called for both normal control flow and when an exception is thrown.

The same principle does not apply for a raw handle to a resource, e.g. a pointer to allocated memory. By using a manager class, the lifetime of the resource can be correctly controlled, specifically by releasing it in the destructor.

This idiom is known as Resource Allocation Is Initialization (RAII) and the C++ Language Standard provides RAII wrappers for many resources, such as:

The Ada language provides the package Ada.Finalization, which defines two data types:

Controlled  – which provides the procedures:

Limited_Controlled  - which provides the following procedures

Avoid C++ constructs and practices that are likely to make your code non-portable:

A union provides a way to alter the type ascribed to a value without changing its representation. This reduces type safety and is usually unnecessary. In general it is possible to create a safe abstraction using polymorphic types.

Integer types other than signed / unsigned char have implementation defined size. Do not use integer types directly, instead use size specified typedefs, defined in a common header file, which can be easily adjusted to match a particular platform.

Do not mix bitwise arithmetic operations on the same variable, as this it likely to be non-portable between big and little endian architectures.

Do not assume the layout of objects in memory, e.g. by comparing pointers to different objects with relational operators, using the offsetof macro, or performing pointer arithmetic with unspecified or implementation defined layout.

Ada also has predefined types. In the case of the predefined integer and floating point types it is advised that the programmer define types or subtypes which better meet their needs. Ada allows the programmer to specify the valid range of values for numeric types, along with specific memory characteristics.

Ada allows the programmer to define the size of an object or a subtype in bits. The size may of an integer, for instance, may not exceed the size of the largest integer representation allowed on the target hardware. The size of a component of a compound type may be specified, and the specific memory layout of record components may be specified. Record components can be less than a word in size, or their size may extend across multiple words.

The size of an object can be interrogate at run time. For example, a packed array of Boolean values will represent each array element in one bit. Each bit can be individually indexed through the standard Ada array indexing notation.

When an array is bound to a function parameter of pointer type the array is implicitly converted to a pointer to the first element of the array.

In order to retain the array dimension, the parameter should be changed to a reference type or changed to a user defined type such as std::array.

Ada does not provide array to pointer conversion. An array is a first class type. The dimension and index values of the array are available wherever the array object is visible.

If a literal is used to initialize a variable of unsigned type, or with an operand of unsigned type in a binary operation, the U suffix should be appended to the literal to circumvent an implicit conversion, and make the intent explicit.

Ada does not provide implicit conversions between data types.  An unsigned type in Ada is known as a modular type. All integer literals in Ada are of the type Universal Integer. A value of type Universal Integer will be implicitly converted to the target type during assignment or in an arithmetic operation. Ada will raise a compile-time error if the literal is not within the range of the target type during an assignment. Ada will raise a run time exception if the result of the arithmetic operation is not within the range of the target type.

The programmer is allowed to define unique numeric data types. There are no implicit conversions between programmer defined data types, even when they two types share the same memory layout. Ada is strongly typed.

Data loss can occur in a number of contexts:

If possible, integral type conversions should be avoided altogether, by performing operations in a uniform type matched to the execution environment.

Where data storage is a concern, type conversions should be localized with appropriate guards (e.g. assertions) to detect data loss.

Similar techniques can be used to guard shift and arithmetic operations, especially where the data is tainted in a security sense, i.e.  a malicious user can trigger data loss with appropriately crafted input data.

Data loss may also occur if high order bits are lost in a left shift operation, or the right hand operator of a shift operator is so large that the resulting value is always 0 or undefined regardless of the value of the left hand operand.

Therefore, appropriate safeguards should be coded explicitly (or instrumented by a tool) to ensure that data loss does not occur in shift operations.

For the purposes of this rule integral to bool conversions are considered to result in data loss as well. It is preferable to use equality or relational operators to replace such type conversions. The C++ Language Standard states that unless the condition of an if, for, while, or do statement had a Boolean type, it will implicitly converted to bool.

Note: An implicit conversion using an operator bool declared as explicit does not violate this rule.

All integral data operations in Ada are protected by range checks. Any violation of a range specification at run time will result in the exception Constraint_Error.

Ada only allows bit shifting operations on unsigned types.

The Ada Boolean type is not numeric, and therefore does not undergo conversion to an integral type. All conditions of an if, for, or while statement must result in a Boolean value.

The C++ Standard provides 3 floating point types: float, double, long double that, at least conceptually, increase in precision.

Expressions that implicitly or explicitly cause a conversion from long double to float or double, and from double to float should be avoided as they may result in data loss.

When using a literal in a context that requires a type float, use the F suffix, and for consistency use the L suffix in a long double context.

Ada provides a predefined floating point type named float, which should provide at least 6 decimal digits of precision. The programmer is allowed to define custom floating point types with a user specified range and precision.

There is no implicit conversion between floating point types.

Ada also provides the ability to define fixed point types. Fixed point types are implemented as scaled integers. Fixed point types have a constant number of digits after the decimal place, while floating point types have a variable number of digits after the decimal place (or none at all) depending upon the magnitude of the value represented.

There is no implicit conversion between numeric types in Ada.

An implicit or explicit conversion from a floating to an integral type can result in data loss due to the significant difference in the respective range of values for each type.

Additionally, floating point to integral type conversions are biased as the fractional part is simply truncated instead of being rounded to the nearest integral value. For this reason use one of the standard library functions: std::floor and std::ceil is recommended if a conversion to an integral type is necessary.

Note: A return value of std::floor and std::ceiling is of floating type, and an implicit or explicit conversion of this value to an integral type is permitted.

There are no implicit conversions between Ada numeric types. Every floating point type and subtype has the attributes S’Ceiling and S’Floor defined to calculate the Ceiling and Floor of the floating point value.

If an explicit conversion between a floating point value and an integral value is performed the conversion  will include a range check. If the resulting value is out of range of the integral type the exception Constraint_Error will be raised.

Use of “magic” numbers and strings in expressions should be avoided in preference to constants with meaningful names.

The use of named constants improves both the readability and maintainability of the code.

Use of constants is recommended over the use of literals.

To enable optimizations and parallelization, the C++ Standard uses a notation of sequenced before, e.g.:

Evaluation of a full expression is sequenced before the next full-expression to be evaluated

Evaluation operands of an operator are sequenced before evaluation of the operator

Evaluation of arguments in a function call are sequenced before the execution of the function

For built-in operators &&, ||,  and operator ? evaluation of the first operand is sequenced before evaluation of the other operand(s)

This defines a partial order on evaluations, and where two evaluations are unsequenced with respect to one another, their execution can overlap. Additionally, two evaluations may be indeterminately sequenced, which is similar, except that the execution cannot overlap.

This definition leaves great latitude to a compiler to re-order evaluation of sub-expressions, which can lead to unexpected, and even undefined behavior. For this reason, and to improve readability an expression should not:

Have more than one side effect

Result in the modification and access of the same scalar object

Include a sub-expression that is an assignment operation

Include a sub-expression that is a pre- or post-increment/decrement operation

Include a built-in comma operator (for overloaded comma operation see Rule 13.2.1: “Do not overload operators with special semantics”)

In Ada assignment is not an expression, and cannot therefore be part of a compound expression. Furthermore, there are no pre- or post-increment/decrement expressions in Ada. These limitations limit the problems associated with violation of Rule 5.1.2.

Ada 2012 does allow the use of “in out” parameters in functions, which can lead to order dependencies. Early versions of Ada prohibited “in out” parameters in functions, allowing only “in” parameters, to avoid this problem. It is still recommended that functions only use “in” parameters except when interfacing with other languages, such as C and C++.

The effects of precedence and associativity of operators in a complex expression can be far from obvious. To enhance readability and maintainability of code, no reliance on precedence or associativity should be made, by using explicit parentheses, except for:

Any combination of + and – operations only

In every language it is recommended to use explicit parentheses instead of relying upon precedence and associativity rules.

In Ada the logical and operator is and. The logical or operator is or. The equivalent of the C++ && is “and then” and the equivalent of the C++ || is “or else”.

Capturing variables helps document the intention of the author. It also allows for different variables to be and within the same lambda.

Ada does not provide lamdas. It is possible to pass a subroutine (function or procedure) as a generic parameter.

The is optional in a lambda expression and results in a closure that can be called without any parameters.

To avoid any visual ambiguity with other C++ constructs, it is recommended to explicitly include , even though it is not strictly required.

Ada does not provide lamdas. It is possible to pass a subroutine (function or procedure) as a generic parameter.

For some expressions, the side effect of a sub-expression may not be evaluated at all or can be conditionally evaluated, that is, evaluated only when certain conditions are met. For Example:

The right-hand operands of the and operators are only evaluated if the left hand operand is and respectively.

The operand of is never evaluated.

The operand of is evaluated only if it is a function call that returns reference to a polymorphic type.

Having visible side effects that do not take place, or only take place under special circumstances makes the code harder to maintain and can also make it harder to achieve a high level of test coverage.

The same rule applies to the Ada “and then” and “or else” logical operations. The right hand side of the “and then” operation is only evaluated if the left hand side is True. The right hand side of the “or else” operation is only evaluated if the left hand side is False.

Unlike standard library containers, arrays do not benefit from bounds checking.

Array access can take one of the equivalent forms: or , and will result in undefined behavior, unless and point to elements of the same array object. Calculating (but not dereferencing) an address one past the last element of the array is well defined also. Note that a scalar object can be considered as equivalent to an array dimensioned to 1.

To avoid undefined behavior, appropriate safeguards should be coded explicitly (or instrumented by a tool), to ensure that array access is within bounds, and that indirection operations ( ) will not result in a null pointer dereference.

Ada makes these checks automatically, so there is no need for manually making them or using some separate tool that also needs to be validated.  The compiler will statically check values for array bounds violations and issue a compilation error when a bounds violation is detected. The Ada compiler also automatically inserts bounds checking into array accesses as needed.

Moreover, the range of the index values for an array can be any contiguous range of discrete values. Ada array indexing is not tied to pointer arithmetic and the lowest bound for an array need not be 0. Ada array definitions include a definition of the array type and range as well as the element type. Arrays have well defined attributes available to the programmer wherever the array object is visible.

Iterating through an array safely in Ada is done using the Ada for loop:

If you want to enforce this rule in Ada you can use the profile No_Recursion.

The result of applying a unary minus operator ( ) to an operand of unsigned type (after integral promotion) is a value that is unsigned and typically very large.

Prefer to use the bitwise complement ( ) operator instead.

The rule here is the same for Ada. The result for an Ada unsigned type is well defined, but may not be what the programmer intends.

C style allocation is not type safe, and does not invoke constructors or destructors. For this reason only operators and should be used to manage objects with dynamic storage duration.

Invoking on a pointer allocated with or invoking on a pointer allocated with will result in undefined behavior.

The C++ Standard requires that the operand to the operator is either:

pointer to a non array object allocated with

pointer to a base class subobject of a non array object allocated with

Similarly, the operand to the operator is either:

pointer to an array object allocated with

In order to avoid undefined behavior, plain and array forms of and should not be mixed.

Ada does not have this problem.

There are no special forms of new for allocating arrays in Ada.  An Ada array is a first class type and the compiler knows the size of an array. The new operator allocates the memory needed to hold an object of the type specified.

Ada does requires the generic function Ada.Unchecked_Deallocation be instantiated for the specific type to be deallocated. The generic parameters for this function are the access type and the base type being deallocated.

All casts result in some degree of type punning, however, some casts may be considered more error prone than others:

It is undefined behavior for the result of a to to be cast to any type other than the original from type.

Depending on the type of an object, casting away or and attempting to write to the result is undefined behavior.

Casts using are generally unspecified and/or implementation defined. Use of this cast increases the effort required to reason about the code and reduces its portability.

Simplistically, a C-style cast and a non class function style cast can be considered as a sequence of the other cast kinds. Therefore, these casts suffer from the same set of problems. In addition, without a unique syntax, searching for such casts in code is extremely difficult.

Ada uses the term type conversion when converting a value from one type to another type. There is only one syntax for type conversion:  subtype-name (expression-or-identifier)

If the target type of a conversion is an integer type and the operand is a real type then the result is the result rounded to the nearest integer (away from zero if exactly half way between two integers). Range checking is done after the converted value has been calculated.

The result of casting an integer to an enumeration type is unspecified if the value is not within the range of the enumeration. This also applies when casting between different enumeration types.

For this reason conversions to an enumeration type should be avoided.

Converting between an integer and an enumeration value is not performed by type conversion. Instead, enumeration types have the attributes T’Pos and T’Val. T’Pos takes an argument of the enumeration type and returns the position number of that argument. T’Val takes an integer as an argument and returns the value of type T whose position number equals the value of the argument. If there is no value with the given position number the exception Constraint_Error is raised.

The most common reason for casting down an inheritance hierarchy, is to call derived class methods on an object that is a reference or pointer to the base class.

Using a virtual function removes the need for the cast completely and improves the maintainability of the code.

In Ada casting between levels of an inheritance hierarchy is called a view conversion. Converting from a base type to a derived type is valid only when the derived type does not add any data members to the set of members defined in the base type.

The result of integer division or remainder operation is undefined if the right hand operand is zero. Therefore, appropriate safeguards should be coded explicitly (or instrumented by a tool) to ensure that division by zero does not occur.

The result of division by zero is well defined in Ada. The result will cause the exception Constraint_Error to be raised.

Use of signed operands with bitwise operators is in some cases subject to undefined or implementation defined behavior. Therefore, bitwise operators should only be used with operands of unsigned integral types.

In Ada the bitwise operators are only defined for unsigned types.

Floating point calculations suffer from machine precision (epsilon), such that the exact result may not be representable.

Epsilon is defined as the difference between 1 and the smallest value greater than 1 that can be represented in a given floating point type. Therefore, comparisons of floating point values need to take epsilon into account.

Floating point number exhibit the same behavior in Ada. If you want exact equality in a real number then use a fixed point representation instead of a floating point representation.

The result of comparing a pointer to member to a virtual function to anything other than is unspecified.

Ada polymorphism does not depend upon pointers to members of a class hierarchy. Parameters to subprograms can be defined as class-wide parameters, and the actual parameter can be any object with the class hierarchy.

Evaluation of a complex condition is best achieved through explicit conditional statements ( / ). Using the result of the conditional operator as an operand reduces the maintainability of the code.

The only permissible uses of a conditional expression are:

the right hand side operand of assignment (excluding compound assignment)

The last use is allowed on the basis of initialization of an object with automatic storage duration being equivalent to its declaration, followed by assignment.

Follow each control flow primitive ( , , , , and ) by a block enclosed by braces, even if the block is empty or contains only one line. Use of null statements or statement expressions in these contexts reduces code readability and making it harder to maintain.

All Ada selection or iteration statements are always fully bracketed compound statements.

Make sure that each if-else-if chain has a final else clause, and every switch statement has a default clause.

The advantage is that all execution paths are explicitly considered, which in turn helps reduce the risk that an unexpected value will result in incorrect execution.

The rule for if-elsif-else in Ada applies.

Ada case statements require all possible values of the selection type to be covered. If some value or values are not covered explicitly then an others case must be included. The compiler will issue an error if this rule is not followed.

Fall through from a non empty case block of a switch statement makes it more difficult to reason about the code, and therefore harder to maintain.

A switch statement with fewer than two case labels can be more naturally expressed as a single if statement.

Ada case statements are intended to handle all the values of a discrete type, not just one. A simple if statement is appropriate if only one value of a discrete range of values is being tested.

A range-based for statement reduces the amount of boilerplate code required to maintain correct loop semantics.

A range-based loop can normally replace an explicit loop where the index or iterator is only used for accessing the container value.

The traditional Ada for loop always iterates over a range of values. The Ada iterator loop iterates through the values of all standard Ada containers and all Ada arrays.

when entered, the loop is infinite, or

the loop will always terminate after the first iteration.

To improve maintainability it is recommended to avoid degenerate loops and to limit them to a single counter variable.

Ada provides four kinds of loops.

The simple loop is the most general loop and can be used for loops that test termination at the beginning of the loop, at the end of the loop, or in the middle of the loop

The while loop tests a control expression at the top of the loop

The for loop executes for each value in a specified range

The iterator loop executes for every member of a container or array

Ada does not provide a direct equivalent of the C++ for loop.

The behavior of iteration statements with multiple modifications of control or counter variables is difficult to understand and maintain.

The Ada for loop has a counter which is modified only at the top of the loop, and is read-only within the body of the loop. The counter cannot be modified more than once per loop iteration.

It is expected that a for loop counter is modified for every iteration. To improve code readability and maintainability, the counter variable should be modified in the loop expression.

The Ada for loop has a counter which is modified only at the top of the loop, and is read-only within the body of the loop. The counter cannot be modified more than once per loop iteration.

Backward jumps and jumps into nested blocks make it more difficult to reason about the flow through the function.

Loops should be the only constructs that perform backward jumps, and the only acceptable use of a goto statement is to jump forward to an enclosing block.

Control can also be transferred forward into a nested block by virtue of a switch label. Unless case and default labels are placed only into the top level compound statement of the switch, the code will be difficult to understand

Ada case statements do not allow selection of a value within an if statement.

Ada loops can be labeled, and the loop exit statement in an inner loop can identify the label of an outer loop, allowing a direct exit from the outer loop controlled by a condition in an inner loop. This ability removes the need to set flag variables throughout a nesting of loops with associated testing of the flag. The advantage is code simplicity and added readability.

Undefined behavior will occur if execution of a function with a non void return type (other than ) flows off the end of the function without encountering a return statement with a value.

function is exempt from this rule, as an implicit will be executed, when an explicit

Ada provides two kinds of subprograms. Procedures never return a value. Functions always return a value. The return value of a function must always be handled by the calling subprogram. The Ada compiler will issue an error if a function does not return a value of the specified return type, or if a procedure attempts to return a value of any type.

The Ada main subprogram is always a procedure and returns no value.

To preserve locality of reference, variables with automatic storage duration should be defined just before they are needed, preferably with an initializer, and in the smallest block containing all the uses of the variable.

The scope of a variable declared in a for loop initialization statement extends only to the complete for statement.

Therefore, potential use of a control variable outside of the loop is naturally avoided.

Ada only allows variables, constants, subprograms, or tasks to be defined in the declaration section of a block. The one exception is the for loop control variable which is defined at the start of the for loop and is not visible outside the for loop.

Declaring each variable or typedef on a separate line makes it easier to find the declaration of a particular identifier.

Determining the type of a particular identifier can become confusing for multiple declarations on the same line.

Ada only allows variables, constants, subprograms, or tasks to be defined in the declaration section of a block. The one exception is the for loop control variable which is defined at the start of the for loop and is not visible outside the for loop.

This allows specification of semantic constraint which a compiler can enforce. It explicitly communicates to other programmers that value should remain invariant. For example, specify whether a pointer itself is const, the data it points to is const, both or neither.

Ada allows an object to be defined as constant, but does not have the complex const rules of C++. When passing parameters to a subprogram the passing mode can be defined as IN, which forces the subprogram to view that parameter as a constant. Parameters passed with the IN mode are read-only within the subprogram they are passed to.

The C++ Standard allows any order of specifiers in a declaration. However, to improve readability if a non-type specifier ( , , , , , , , , , , ) appears in a declaration, it should be placed leftmost in the declaration.

Variable declarations always take the form of

The const or volatile qualifiers can appear either to the right or left of the type they apply to. When the unqualified portion of the type is a typedef name (declared in a previous typedef declaration), placing the CV-qualifiers on the left hand side, may result in confusion over what part of the type the qualification applies to.

For consistency, it is recommended that this rule is applied to all declarations.

Variable declarations always take the form of

The definition of an inline function needs to be available in every translation unit that uses it. This in turn requires that the definitions of inline functions and types used in the function definition must also be visible.

The keyword is just a hint, and compilers in general will only inline a function body if it can be determined that performance will be improved as a result.

As the compiler is unlikely to inline functions that have a large number of statements and expressions, inlining such functions provides no performance benefit but will result in increased dependencies between translation units.

Given an approximate cost of 1 for every expression and statement, the recommended maximum cost for a function is 32.

The inline aspect of a subprogram is optional for a compiler. It notifies the compiler of the programmer’s desire that the subprogram be inlined.

Using class types to represent scalar quantities exploits compiler enforcement of type safety. If this is not possible, typedefs should be used to aid readability of code.

Plain char type should not be used to define a typedef name, unless the type is intended for parameterizing the code for narrow and wide character types. In other cases, an explicit or type should be used in a typedef as appropriate.

To enhance portability, instead of using the standard integer types (signed char, short, int, long, long long, and the unsigned counterparts), size specific types should be defined in a project-wide header file, so that the definition can be updated to match a particular platform (16, 32 or 64bit). Where available, and types (e.g. ) defined in the header file should be used for this purpose.

Where the type specifier is used in a declaration, and the initializer is a constant expression, the declaration should not be allowed to resolve to a standard integer type. The type should be fixed by casting the initializer to a size specific type.

The C++ Language Standard places type requirements on certain constructs. In such cases, it is better to use required type explicitly rather than the equivalent which would reduce the portability of the code.

The following constructs are therefore exceptions to this rule:

When using a trailing return type, lookup for the function return type starts from the same scope as the function declarator. In many cases, this will remove the need to specify a fully qualified return type along with the keyword.

Ada has no equivalent of a trailing return type.

When declaring a variable that is initialized with a function call, the type is being specified twice. Initially on the return of the function and then in the type of the declaration.

This rule is contrary to Ada strong typing. Every variable must be declared to be definite, even if it is a member of an indefinite type. The type returned by an initializing function must match the type of the object being declared.

An object of an indefinite type must be initialized to a definite object. For instance, the type String is an unconstrained array of character. An unconstrained array is an indefinite type. Each instance of a String must have a specified length, which is defined when the String object is initialized. The String object is definite. The String type is indefinite.

Allowing the return type of a lambda to be implicitly deduced reduces the danger of unexpected implicit conversions, as well as simplifying future maintenance, where changes to types used in the lambda would otherwise result in the need to change the return type.

Ada does not allow lambdas.

A will generate a compile error if its expression is not . The earlier that a problem can be diagnosed the better, with the earliest time possible being as the code is written.

When defining a subtype the programmer should use either a Dynamic_Predicate or a Static_Predicate if the use of a simple range cannot fully define the characteristics of the subtype.

A Static_Predicate expression must be one of

A static membership test where the choice is selected by the current instance

A case expression whose dependent expressions are static and selected by the current instance

A call of the predefined operations =, /=, <, <=, >, >= where one operand is the current instance

A Dynamic_Expression can be any Boolean expression.

The underlying type of an unscoped enumeration is implementation defined, with the only restriction being that the type must be able to represent the enumeration values. An explicit enumeration base should always be specified with a type that will accommodate both the smallest and the largest enumerator.

A scoped enum will implicitly have an underlying type of , however, the requirement to specify the underlying type still applies.

Ada enumerations are not numeric types and cannot be converted to numeric types. The compiler chooses the size of the enumeration representation base upon the number of enumeration values.

It is error prone to initialize explicitly only some enumerators in an enumeration, and to rely on the compiler to initialize the remaining ones. For example, during maintenance it may be possible to introduce implicitly initialized enumerators with the same value as an existing one initialized explicitly.

When an enumeration is used to define the size and to index an array, it is acceptable and recommended to define three additional enumerators after all other enumerators, to represent the first and the last elements, and the size of the array.

When specifying the enumeration representation all enumerated values must be specified.

Namespaces are an important tool in separating identifiers and in making interfaces explicit.

A , i.e. , allows any name to be searched for in the namespace specified by the .

A , on the other hand, brings in a single name from the namespace, as if it was declared in the scope containing the .

The unit of encapsulation in Ada is the package. Packages provide the name space designation of C++ namespaces.

In Ada one can either use the entire package, use only a specific type defined in the package, or explicitly append the package name to each element accessed from the package.

Any naming ambiguity will be identified by the compiler.

Declaring an entity in an unnamed namespace limits its visibility to the current translation unit only. This helps reduce the risk of name clashes and conflicts with declarations in other translation units.

It is preferred to use unnamed namespaces rather than the keyword to declare such entities.

Each compilation unit specifies its own dependencies in its dependency clauses. There is no visibility to compilation units not defined in the dependency clause.

An inline function, a function template or a user defined type that is intended for use in multiple translation units should be defined in a single header file, so that the definition will be processed in exactly the same way (the same sequence of tokens) in each translation unit.

This will ensure that the is adhered to, avoiding undefined behavior, as well as improving the maintainability of the code.

Each subprogram, generic compilation unit, type, task, task type, protected object, or protected type is defined uniquely in a compilation unit. Dependency upon compilation units which define types or objects with overlapping identifiers results in ambiguity which is flagged as a compilation error and must be corrected before an executable is produced by the compilation process.

An object or function with external linkage should be in a single header file in the project.

This will ensure that the type seen for an entity in each translation unit is the same thereby avoiding undefined behavior.

Objects used by multiple compilation units must be declared in the public region of a package. Functions and procedures can either be declared in a package or in a stand-alone compilation unit.

Use of inline assembly should be avoided since it restricts the portability of the code.

Machine code insertions should be avoided since they restrict the portability of the code.

In C++, at most one level of pointer indirection combined with references is sufficient to express any algorithm or API.

Instead of using multidimensional arrays, an array of containers or nested containers should be used. Code reliant on more than one level of pointer indirection will be less readable and more difficult to maintain.

Use of multidimensional arrays is allowed, or one can choose containers or nested containers. Ada arrays do not employ pointer indirection at the source code level.

Although the C++ Standard does not mandate that parameter names match in all declarations of a function (e.g. a declaration in a header file and the definition in the main source file), it is good practice to follow this principle.

All subprogram parameter names must be declared and must match the corresponding subprogram implementation.

Subprogram parameters may be referenced by position or by name when the subprogram is called. It is recommended to use named notation when calling a subprogram. When using named notation the actual parameter is explicitly matched with the formal parameter, and the order of parameters in the called subprogram is not relevant.

A function defined with a long list of parameters often indicates poor design and is difficult to read and maintain.

The recommended maximum number of function parameters is six.

While it is seldom useful to declare a subprogram with a large number of parameters, the problem is greatly relieved through the use of named notation.

Because passing by const reference involves an indirection, it will be less efficient than passing by value for a small object with a trivial copy constructor.

Ada parameters have an associated mode indicating data flow. The modes are IN, OUT, IN OUT. The compiler determines whether a particular parameter should be passed by copy or by reference.

An object of type should be passed as a non-const reference, or by value. Passing by non-const reference signifies that the parameter is an in/out parameter. Passing by value signifies that the parameter is a sink (i.e. takes ownership and does not return it).

A const reference parameter provides no benefits and restricts the potential callers of the function.

Ada parameter modes explicitly state whether the parameter is passed IN, OUT, or IN OUT.

The McCabe Cyclomatic Complexity is calculated as the number of decision branches within a function plus 1.

Complex functions are hard to maintain and test effectively. It is recommended that the value of this metric does not exceed 10.

Excessive cyclomatic complexity has been shown to produce code that is difficult to understand and maintain. It is often an indication of poor code design.

Static program path count is the number of non-cyclic execution paths in a function. Functions with a high number of paths through them are difficult to test, maintain and comprehend. The static program path count of a function should not exceed 200.

High static path count is an indication of poor software design. All code should be testable and maintainable.

Use of default arguments can make code maintenance and refactoring more difficult. Overloaded forwarding functions can be used instead without having to change existing function calls.

Overloaded forwarding functions provide no maintenance benefit. Use of default arguments and named notation for calling subprograms clearly documents all calls for maintenance purposes without creating a plethora of overloaded subprograms.

A simple model for an is that it allows for the modification of a temporary. A const therefore defeats the purpose of the construct as modifications are not possible.

However, one valid use case is where the function is defined . This will disallow the use of an as an argument to that function.

Ada has no equivalent to defining a subprogram as =delete.

A significant component of program correctness is that the program behavior should be deterministic. That is, given the same input and conditions the program will produce the same set of results.

If a program does not have deterministic behavior, then this may indicate that the source code is reliant on unspecified or undefined behavior.

Such behaviors may arise from use of:

memory (or pointers to memory) that has been freed

The Ada compiler identifies when the value of a variable is used before the variable is initialized or assigned a value. The SPARK subset of Ada requires all variables to be fully initialized.

If an array or a struct is non-zero initialized, initializers should be provided for all members, with an initializer list for each aggregate (sub)object enclosed in braces. This will make it clear what value each member is initialized with.

Aggregates can be constructed for arrays or records. While aggregates can be constructed using positional notation, similar to C++, named notation should always be used.

Use of named notation will ensure and document that all elements of the composite type have been initialized.

A non-virtual member function that does not access the pointer can be declared . Otherwise, a function that is virtual or does not modify the externally visible state of the object can be declared .

The C++ language permits that a const member function modifies the program state (e.g. modifies a global variable, or calls a function that does so). However, it is recommended that const member functions are logically const also, and do not cause any side effects.

The keyword can be used to declare member data that can be modified in a const function, however, this should only be used where the member data does not affect the externally visible state of the object.

Packages are the unit of encapsulation in Ada. Tagged types are polymorphic types in Ada. Tagged types can be defined in a package, making them available to multiple compilation units. Tagged types can have primitive operations, which correspond to virtual member functions in C++. A subprogram is primitive to some tagged type T if all of the following are true:

The subprogram is declared in the visible part of the package in which tagged type T is declared

The subprogram has a parameter of type T, or an access parameter pointing to an instance of type T, or is a function returning a result of type T

Any subprogram which is declared in the package where type T is declared, and does not meet the above requirements, is not a primitive of type T. Such a subprogram is equivalent to a C++ static member function. Any procedure with only an parameter of IN mode of type T is equivalent to a C++ const member function.

The C++ Language Standard allows that default arguments be different for different overrides of a virtual function.

However, the compiler selects the argument value based on the static type of the object used in the function call.

This can result in confusion where the default argument value used may be different to the expectation of the user.

The Ada Language Standard requires  overridden subprograms be conformant in their use of default parameter expressions. When a subprogram overrides another subprogram the parameter profile cannot change regarding default expressions.

A pointer or reference to non-const data returned from a const member function may allow the caller to modify the state of the object. This contradicts the intent of a const member function.

A procedure with an IN mode parameter  cannot modify the data passed to it, nor can it return a value of any kind.

Member data that is returned by a non-const handle from a more accessible member function, implicitly has the access of the function and not the access it was declared with. This reduces encapsulation and increases coupling.

Ada functions need not return pointers to complex data. Instead they can return entire complex objects including records and arrays. This avoids the lifetime issues associated with C++ member functions.

Declaring a class as explicitly documents that this is a leaf class as it cannot be used as a base class.

Introducing a virtual function in such a class is therefore redundant as the function can never be overridden in a derived class.

Ada does not explicitly label a tagged type “final”. Instead, if no subprograms with class-wide parameters are introduced the tagged type has the effect of being “final”.

To avoid reliance on implementation defined behavior, only declare bit-fields of an explicitly unsigned type ( ) or an enumeration type with an enumeration base of explicitly unsigned type.

One must define data types with value ranges that can fit into the specified bit layout of a record. Failure to do so will result in a compiler error message.

A class inherited more than once in a hierarchy, and not inherited virtually in all paths will result in multiple base class subobjects being present in instances of the derived object type.

Such objects require that the developer explicitly select which base class to use when accessing members. The result is a hierarchy that is harder to understand and maintain.

Ada allows multiple inheritance only of interfaces, not of tagged types. All subprograms in interfaces are abstract, corresponding to virtual inheritance of multiple base classes in C++.

The special identifier is a directive to the compiler to check that the function is overriding a base class member. This will ensure that a change in the signature of the virtual function will generate a compiler error.

An interface class has the following properties:

all public functions are pure virtual functions or getters, and

there are no public or protected data members, and

it contains at most one private data member of integral or enumerated type

Inheriting from two or more base classes that are not interfaces, is rarely correct. It also exposes the derived class to multiple implementations, with the risk that subsequent changes to any of the base classes may invalidate the derived class.

On the other hand. it is reasonable that a concrete class may implement more than one interface.

Ada only allows inheritance from one base class. Ada allows multiple inheritance of interfaces.

If direct access to the object state is allowed through public or protected member data, encapsulation is reduced making the code harder to maintain.

By implementing a class interface with member functions only, precise control is achieved over modifications to object state as well as allowing for pre and post conditions to be checked when accessing data.

There are many uses for packages. One use is to define commonly used constants, while another is to define abstract data types. It is good to use data hiding for abstract data types, but it is also important to openly share commonly used constants. When declaring abstract data types in Ada it is advised that the public view of the data type refers to a private definition of the data structure.

Friend declarations reduce encapsulation, resulting in code that is harder to maintain.

Ada provides child packages rather than friends. Child packages do not reduce encapsulation. Child packages allow the creation of package extensions without compromising or altering the code in the parent package.

A user defined conversions can occur through the use of a conversion operator or a conversion constructor (a constructor that accepts a single argument).

A compiler can invoke a single user defined conversion in a standard conversion sequence, but only if the operator or constructor is declared without the keyword.

It is better to declare all conversion constructors and operators explicit.

If an object will ever be destroyed through a pointer to its base class, then the destructor in the base class should be . If the base class destructor is not virtual, then the destructors for derived classes will not be invoked.

Where an object will not be deleted via a pointer to its base, then the destructor should be declared with or access. This will result in a compile error should an attempt be made to delete the object incorrectly.

Ada controlled types allow user-defined finalization of objects of the type. Finalization is called when an object goes out of scope.

Ada polymorphism does not require the use of pointers to a base class.

and should work together. Overloading means that a custom memory management scheme is in operation for a particular class or program. If a corresponding (plain or array) is not provided the memory management scheme is incomplete.

Additionally, if initialization of the allocated object fails with an exception, the C++ runtime will try to call an with identical parameters as the called , except for the first parameter. If no such can be found, the memory will not be freed. If this does not actually need to perform any bookkeeping, one with an empty body should be defined to document this in the code.

When declared in a class, and are implicitly static members; explicitly including the specifier in their declarations helps to document this.

When creating a custom storage pool one must override the abstract type Root_Storage_Pool, including overriding its Allocate and Deallocate procedures and its Storage_Size function. There is no way to implement a custom storage pool without implementing all three subprograms.

use of , or

are said to use the dynamic type of the object.

Special semantics apply when using the dynamic type of an object while it is being constructed or destructed. Moreover, it is undefined behavior if the static type of the operand is not (or is not a pointer to) the constructor’s or destructor’s class or one of its base classes.

In order to avoid misconceptions and potential undefined behavior, such expressions should not be used while the object is being constructed or destructed.

Ada has no concept of a dynamic type, only dynamic type identification. Ada can perform view conversions of a child type to its parent type, but that does not change the type of an object.

A constructor should completely initialize its object. Explicit initialization reduces the risk of an invalid state after successful construction. All virtual base classes and direct non-virtual base classes should be included in the initialization list for the constructor. A copy or move constructor should initialize each non-static data member in the initialization list, or if this is not possible then in constructor body. For other constructors, each non-static data member should be initialized in the following way, in order of preference:

For many constructors this means that the body becomes an empty block.

Ada records, including tagged records, can be defined with default values for all their record components. The default initialization of a parent tagged record is applied to the child tagged record so that the child need not explicitly call parent initialization functions.

NSDMI stands for ’non static data member initializer’. This syntax, introduced in the 2011 C++ Language Standard, allows for the initializer of a member to be specified along with the declaration of the member in the class body. To avoid confusion as to the value of the initializer actually used, if a member has an NSDMI then it should not subsequently be initialized in the member initialization list of a constructor.

Ada does not provide for multiple initialization of an object.

Regardless of the order of member initializers in a initialization list, the order of initialization is always:

Virtual base classes in depth and left to right order of the inheritance graph.

Direct non-virtual base classes in left to right order of inheritance list.

Non-static member data in order of declaration in the class definition.

To avoid confusion and possible use of uninitialized data members, it is recommended that the initialization list matches the actual initialization order.

Since Ada only allows single inheritance from a base class there is no issue about which base class is first initialized.

Delegating constructors can help reduce code duplication by performing initialization in a single constructor. Using delegating constructors also removes a potential performance penalty with using an ’init’ method, where initialization for some members occurs twice.

Ada does not provide explicit constructors. Ada does provide an Initialize procedure for controlled types.

A compiler may provide some or all of the following special member functions:

The set of functions implicitly provided depends on the special member functions that have been declared by the user and also the special members of base classes and member objects.

The compiler generated versions of these functions perform a bitwise or shallow copy, which may not be the correct copy semantics for the class. It is also not clear to clients of the class if these functions can be used or not.

To resolve this, the functions should be defined with or thereby fully documenting the class interface.

As this rule is limited to concrete classes, it is the responsibility of the most derived class to ensure that the object has correct copy semantics for itself and for its sub-objects.

Tagged types inheriting from Controlled types must define Initialize, Adjust, and Finalize procedures to handle initialization, copy semantics, and deletion semantics.

This rule has no Ada equivalent because Ada prohibits inheritance from multiple base classes.

The human clients of a class will expect that the copy constructor can be used to correctly copy an object of class type. Similarly, they will expect that the move constructor correctly moves an object of class type.

Similarly, a compiler has explicit permission in the C++ Standard to remove unnecessary copies or moves, on the basis that these functions have no other side-effects other than to copy or move all bases and members.

Tagged types inheriting from Controlled types must define Initialize, Adjust, and Finalize procedures to handle initialization, copy semantics, and deletion semantics.

A class provides the Strong Exception Guarantee if after an exception occurs, the objects maintain their original values.

The move members of a class explicitly change the state of their argument. Should an exception be thrown after some members have been moved, then the Strong Exception Guarantee may no longer hold as the from object has been modified.

It is especially important to use for types that are intended to be used with the standard library containers.

If the move constructor for an element type in a container is not then the container will use the copy constructor rather than the move constructor.

Ada has no equivalent to a move constructor. A move constructor moves ownership of data from one object to another. If the resource is accessed through an access value then the access value of the data in the starting object must be copied to the corresponding access field of the target object. After the access value is copied the access value in the starting object must be set to null.

The move constructor moves the ownership of data from one object to another. Once a resource has been moved to a new object, it is important that the moved-from object has its handles set to a default value. This will ensure that the moved-from object will not attempt to destroy resources that it no longer manages on its destruction.

The most common example of this is to assign to pointer members.

Ada has no equivalent to a move constructor. A move constructor moves ownership of data from one object to another. If the resource is accessed through an access value then the access value of the data in the starting object must be copied to the corresponding access field of the target object. After the access value is copied the access value in the starting object must be set to null.

Implementing the copy assignment operator using a non throwing swap provides the Strong Exception Guarantee for the operations.

In addition, the implementation of each assignment operator is simplified without requiring a check for assignment to self.

Use of an atomic swap operation assumes the use of pointers and not full objects. This assumption frequently fails since Ada does not require the use of pointers to complex data types.

In the 2003 C++ Language Standard, user declared types differed from built-in types in that it was possible to have a ’modifiable rvalue’.

The 2011 C++ Language Standard allows for a function to be declared with a reference qualifier. Adding to the function declaration ensures that the call can only be made on objects, as is the case for the built-in operators.

Ada does not allow modifiable rvalues.

An instance of an abstract class can only exist as a subobject for a derived type. A public copy assignment operator would allow for incorrect partial assignments to occur.

The copy assignment operator should be protected, or alternatively defined if copying is to be prohibited in this class hierarchy.

Ada does not allow instances of abstract types. Each instance must be a concrete type derived from the abstract type.

When a member function is overridden or overloaded in a derived class, other base class functions of that name will be hidden. A call to a function from the derived class may therefore result in a different function being called than if the same call had taken place from the base class.

To avoid this situation, hidden names should be introduced into the derived class through a .

A using declaration for a namespace scope identifier, only brings into the current scope the prior declarations of this identifier, and not any declarations subsequently added to the namespace. This too may lead to unexpected results for calls to overloaded functions.

If the programmer wants the base type version of an overloaded or overridden subprogram to be called then the object must be passed to the overloaded subprogram name in the form of a view conversion to the base type.

A callable function is one which can be called with the supplied arguments. In the C++ Language Standard, this is known as the set of viable functions.

A template parameter declared has special rules during type deduction depending on the value category of the argument to the function call. Scott Meyers has named this a ’Universal Reference’.

As a universal reference will deduce perfectly for any type, overloading them can easily lead to confusion as to which function has been selected.

Standard C++ allows for a member of the viable function set to be deleted. In such cases, should these functions be called then it will result in a compiler error.

Ada does not provide an equivalent to universal reference. The closest Ada comes is an class-wide access type, which can reference any object in the inheritance hierarchy rooted at the tagged type specified in the definition of the access type.

Overloaded operators are just functions, so the order of evaluation of their arguments is unspecified. This is contrary to the special semantics of the following built-in operators:

– left to right and potentially evaluated

– left to right and potentially evaluated

Providing user declared versions of these operators may lead to code that has unexpected behavior and is therefore harder to maintain.

Additionally, overloading the unary (address of) operator will result in undefined behavior if the operator is used from a location in the source where the user provided overload is not visible.

The C++ operators && and || correspond to the Ada logical expressions “and then” and “or else”. Those logical expressions cannot be overloaded in Ada. Ada has no “address of” operator. It does have an attribute ‘Access which cannot be overloaded.

Built-in binary arithmetic and bitwise operators return a pure (which cannot be modified), this should be mirrored by the overloaded versions of these operators. For this reason the only acceptable return type is a fundamental or an enumerated type or a class type with a reference qualified assignment operator.

Built-in equality and relational operators return a boolean value, and so should the overloaded counterparts.

Custom operators can be defined which return complex values. For instance:

In the case above addition operators are declared for types Matrix and Vector. In this case the acceptable return type is not a scalar and need not be a tagged type.

Overloaded binary arithmetic and bitwise operators should be non-members to allow for operands of different types, e.g. a fundamental type and a class type, or two unrelated class types.

Overloaded binary arithmetic operators should be declared within the package that a particular numeric type is declared. Integer or real types are often defined as part of a larger abstraction such as date and time utilities. Often achieving the same effect in C++ may take the creation of several classes.

A non-const overload of the subscript operator should allow an object to be modified, i.e. should return a reference to member data. The const version is there to allow the operator to be invoked on a const object.

There is no subscript operator in Ada. Ada requires the programmer to specify the scalar subtype used to index an array type. Array indices in Ada may be indexed by any scalar type (signed integer, modular integer, enumeration) and the lowest index value may be set to any valid value of the specified index subtype.

This array’s index values start at Mon and end at Sun. Each array element is a float value.

This array is indexed with a modular type. Modular types exhibit wrap around arithmetic, allowing this array to easily implement a circular message buffer.

This array can be used to count the frequency of some event plotted to a normal curve.

Ada does allow indexing operators to be defined for tagged types. This indexing ability in Ada helps greatly in the implementation of indexable container types such as maps and sets. The container type can be designated to employ either constant indexing or variable indexing. The aspect of the type declaring either constant indexing or variable indexing must indicate one or more functions taking two parameters, one of which is an instance of the container type or a reference to a container instance.

Ada user defined indexing is not used for array types, which are not tagged types.

In order to limit duplication of code and associated maintenance overheads, certain operators can be implemented in terms of other operators.

The Ada 2012 Language Reference Manual states that one is not allowed to overload “/=” directly, however overloading “=” implicitly overloads “/=”, since not equals is simply the complement of the “=” function.

Use of the ellipsis notation to indicate an unspecified number of arguments should be avoided. Variadic templates offer a type-safe alternative.

The Ada equivalent to a template is called a generic. A programmer can define a generic subprogram or a generic package. Each generic unit definition includes a set of generic parameters followed by a normal subprogram or package specification.

There is no need for an equivalent to C++ variadic parameter lists.

Generic units are explained in section 12 of the Ada 2012 Language Reference Manual.

This example implements a generic stack. The package specification begins with  the reserved word “generic” followed by the list of generic parameters. In this case the parameter Size is a generic formal object of the subtype Positive, and the type Item is any non-limited type, private or public.

The package specification only contains two procedures, Push and Pop, plus the definition of two exceptions, Overflow and Underflow. This package implements a singleton stack, therefore no stack type is publicly exposed.

The package body contains the implementation of the Push and Pop procedures plus the definition of the singleton stack object.

Partial and explicit specializations of function and class templates should be declared with the primary template.

This will ensure that implicit specializations will only occur when there is no explicit declaration available.

Ada generics do not undergo specialization, only instantiation. Examples of instantiation of the generic singleton stack package shown above are:

Note that the generic parameters can be passed by name or by position. After the instantiations above the package procedures can be called as follows:

Note that Stack_Int is a singleton stack containing Integer values while Stack_Bool is a distinct and separate singleton stack containing Boolean values.

Overload resolution does not take into account explicit specializations of function templates. Only after overload resolution has chosen a function template will any explicit specializations be considered.

Ada generic formal parameters are much richer and more explicit than C++ template parameters rendering specialization unnecessary.

Use of a formal package parameter in a generic parameter list does not necessarily cause overloading of subprograms.

Declaring the template with will disable implicit instantiation of the template when it is used in other translation units, saving time and reducing compile time dependencies.

Exceptions pass information up the call stack to a point where error handling can be performed. If an object of class type is thrown, the class type itself serves to document the cause of an exception.

Only types that inherit from , should be thrown.

Only instances of the pre-defined type Exception can be raised. Each instance of exception that is raised can be accompanied by exception information in the form of a string.

The 2011 C++ Language Standard states that unless a user provided destructor has an explicit exception specification, one will be added implicitly, matching the one that an implicit destructor for the type would have received.

Furthermore when an exception is thrown, stack unwinding will call the destructors of all objects with automatic storage duration still in scope up to the location where the exception is eventually caught.

The program will immediately terminate should another exception be thrown from a destructor of one of these objects.

Ada has no explicit constructors or destructors. Instead, the procedures Initialize and Finalize are called. When a programmer customizes Initialize and Finalize care must be taken not to raise exceptions.

When a constructor or a destructor has a function try block, accessing a non-static member from an associated exception handler will result in undefined behavior.

The path of an exception should be logical and well defined. Throwing an exception that is never subsequently caught, or attempting to rethrow when an exception is not being handled is an indicator of a problem with the design.

Ada exceptions should be handled wherever possible. It is considered bad design to use exceptions as a normal path to program termination.

The preprocessor should only be used for including header files into other headers or the main source file, in order to form a translation unit. In particular only the following include directive forms should be used:

Ada does not require the use of a preprocessor. File dependencies are established through the use of a dependency clause (with clause).

Dependency clauses do not require any equivalent of include guards. Dependency clauses cannot create macros.

Hardcoding the path to a header file in a directive may necessitate changes to source code when it is reused or ported.

Alternatively, the directory containing the header file should be passed to the compiler on command line (e.g. or option).

Ada dependency clauses do not contain filenames. They contain the names of compilation units.

Some operating systems have case insensitive filesystems. Code initially developed on such a system may not compile successfully when ported to a case sensitive filesystem.

Ada dependency clauses do not contain filenames. They contain the names of compilation units.

It is common practice that is used for compiler provided headers, and for user provided files.

Adhering to this guideline therefore helps with the understandability and maintainability of the code.

Ada dependency clauses do not contain filenames. They contain the names of compilation units.

Presence of spurious include directives can considerably slow down compilation of a large code base. When a source file is refactored, the list of included headers should be reviewed, to remove include directives which are no longer needed.

Doing so may also offer an opportunity to delete from code repository source files that are no longer used in the project, therefore reducing the level of technical debt.

It is a good practice to minimize the dependency list for an Ada compilation unit. Minimized dependencies support code readability and maintenance.

The specialization does not conform to the requirements of a container and does not work as expected in all STL algorithms.

In particular &v[0] does not return a contiguous array of elements as it does for other vector types. Additionally, the C++ Language Standard guarantees that different elements of an STL container can safely be modified concurrently, except for a container of type.

There is no corresponding prohibition for Ada standard libraries.

The C11 standard library, which is included in the C++ standard library, leaves the handling of concerns relating to security and concurrency up to the developer.

Therefore, if the C standard library is to be used, it should be wrapped, with the wrappers ensuring that undefined behavior and data races will not occur.

The C standard library is not included in the Ada 2012 standard library.

An object with or type will never actually be moved as a result of calling .

There is no operation equivalent to C++ std::move defined in the Ada 2012 standard.

The function takes the value category of universal reference parameters into account when passing arguments through to callees.

When passing a non universal reference argument should be used.

As is implemented with argument deduction rules, an object declared with is also a universal reference for the purposes of this rule.

There are no Ada library components needed to pass parameter values to subprograms.

Depending on the value category of arguments used in the call of the function, may or may not result in a move of the parameter.

When the value category of the parameter is an , then modifications to the parameter will affect the argument of the caller. In the case of an , the value should be considered as being indeterminate after the call to (See Rule 8.4.1: ” Do not access an invalid object or an object with indeterminate value ”).

There are no Ada library components needed to pass parameter values to subprograms.

Memory allocated with array new must be deallocated with array delete. A smart pointer that refers to an array object must have this information passed in when the object is created. A consequence of this is that it is not possible to construct such a smart pointer using .

A or can be used in place of the raw array type. The usage and performance will be very similar but will not have the additional complexity required when deallocating the array object.

There is not special complexity dealing with allocating or deallocating arrays in Ada.

The class is a wrapper for a C style array. The cost of moving is linear with each element of the array being moved. In most cases, passing the array by or will provide the required semantics without this cost.

There is no standard wrapper for Ada arrays. The cost of assigning an array or an array slice is equivalent to a memory copy in Ada.

The 2011 C++ Language Standard introduced named accessors for returning const iterators. Using these members removes an implicit conversion from to .

Another benefit is that the declaration of the iterator object can then be changed to use without the danger of affecting program semantics.

Ada container packages define cursors to traverse a container objects. The cursor type is a private type defined in each standard container package.

The 2011 C++ Language Standard allows for perfect forwarding. This allows for the arguments to a constructor to be passed through an API and therefore allowing for the final object to be constructed directly where it is intended to be used.

The mutating algorithms , and both overloads of operate by swapping or moving elements of the range they are operating over.

On completion, they return an iterator to the last valid element. In the majority of cases the correct behavior is to use this result as the first operand in a call to .

While Ada does not provide an equivalent to these functions as separate library components, the concept of ignoring the return value of a function is foreign to Ada. All function return values must be used as an rvalue to some expression.

Rather than using platform-specific facilities, the C++ standard library should be used as it is platform independent.

Ada tasking is platform independent. There are no platform specific multi-threading facilities written with an Ada API.

The destructor of will call if the thread owned by the class is still joinable. By using a wrapper class a default behavior can be provided.

Ada tasks do not have an explicit join command nor an explicit detach command.

Ada tasks do have a dependency hierarchy. Each task (other than the environment task) depends on one or more masters. A task is said to be completed when the execution of the corresponding task body is completed. A task is said to be terminated when any finalization of the task body has been performed. The first step in finalizing a master is to wait for the termination of any tasks dependent upon the master. The task executing the master is blocked until all dependents have terminated. Any remaining finalization is then performed and the master is left.

Using the same lock when accessing shared data makes it easier to verify the absence of problematic race conditions.

To help achieve this goal, access to data should be encapsulated such that it is not possible to read or write to the variable without acquiring the appropriate lock. This will also help limit the amount of code executed in the scope of the lock.

Data may be referenced by more than one variable, therefore this requirement applies to the complete set of variables that could refer to the data.

Special attention needs to be made for const objects. The standard library expects operations on const objects to be thread-safe. Failing to ensure that this expectation is fulfilled may lead to problematic data races and undefined behavior. Therefore, operations on const objects of user defined types should consist of either reads entirely or internally synchronized writes.

Ada provides two forms of synchronization for passing data between tasks.

The Rendezvous mechanism provides a means to synchronously pass data directly between two tasks.

The Protected Object provides a way to pass data between tasks through a shared buffer. Protected objects are allowed to have a combination of three kinds of methods.

Protected procedures allow data in the protected object to be modified or updated unconditionally. Protected procedures implicitly manipulate a read/write lock on the protected object. Protected entries allow data in the protected object to be modified or updated conditionally.

Protected entries have a boundary condition which must be satisfied. When the boundary condition evaluates to False the protected entry is blocked and the calling task is suspended and placed in an entry queue. Protected entries automatically manipulate a read/write lock on the protected object. Protected functions are only allowed read access to the protected object. Protected functions may not modify or update the state of the protected object. Protected functions automatically manipulate a shared read lock on the protected object allowing multiple tasks to read from the protected object simultaneously.

Declaring a variable with the keyword does not provide any of the required synchronization guarantees:

Use mutex locks or ordered atomic variables, to safely communicate between threads and to prevent the compiler from optimizing the code incorrectly.

Use the Rendevous or protected objects to communicate between tasks.

The Double-Checked Locking pattern can be used to correctly synchronize initializations.

However, the C++ standard library provides std::call_once which allow for a cleaner implementation.

Initialization of a local object with static storage duration is guaranteed by the C++ Language Standard to be reentrant.

However this conflicts with Rule 3.3.1: ” Do not use variables with static storage duration ”, which takes precedence.

Allow the Ada tasking mechanisms to perform implicit lock manipulations.

It is undefined behavior if a thread tries to lock a it already owns, this should therefore be avoided.

Allow the Ada tasking mechanisms to perform implicit lock manipulations.

Mutex locks are a common causes of deadlocks. Multiple threads trying to acquire the same lock but in a different order may end up blocking each other.

When each lock operation is treated as a vertex, two consecutive vertices with no intervening lock operation in the source code are considered to be connected by a directed edge. The resulting graph should have no cycles, i.e. it should be a Directed Acyclic Graph (DAG).

Allow the Ada tasking mechanisms to perform implicit lock manipulations.

Use of is indicative of bad design: Some functionality is expecting the state to be consistent which may not be a correct assumption since the mutex protecting a resource is already locked.

Allow the Ada tasking mechanisms to perform implicit lock manipulations.

The type provides additional features not available in . There is an additional cost when using and so it should only be used if the additional functionality is required.

Allow the Ada tasking mechanisms to perform implicit lock manipulations.

A mutex object should only be managed by the or object that owns it.

Using non-sequentially consistent memory ordering for atomics allows the CPU to reorder memory operations resulting in a lack of total ordering of events across threads. This makes it extremely difficult to reason about the correctness of the code.

Allow the Ada tasking mechanisms to perform implicit lock manipulations.

When using , there is potential for additional costs in terms of size, performance or operating system resources, because it is more general than .

Allow the Ada tasking mechanisms to perform implicit lock manipulations.|||

