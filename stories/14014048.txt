Not even a little bit.A programming language is calledif itFunctions have very: a function's return value canchange based on its arguments; you can always trace the flow of  dependencies through your code in a very straightforward way by  following arguments and return values.Procedures can have an arbitrary amount of. These can come up from anywhere in your code like some mutable state in another module. They can even come fromyour code, like depending on the system time or an external database. Similarly, the results of a procedure can propagate outwards using the same implicit mechanisms. This is what makes procedures more powerful and, in turn, harder to think about and easier to mess up.By this criteria, the most commonlanguage is. Haskell structurally differentiates between functions which have types like(for a function that maps integers to floating point numbers) and procedures which have types like¹ (for a procedure that returns a floating point number). Note that functions in Haskellhave to be total.It is very important to realize that. In fact, Haskell, while being pure, supports imperative constructs in its procedures. Rather, pure just means that the language hasdistinction and is. Most other multiparadigm languages are imperative first; Haskell just happens to be the other way round.Even languages that aren't strictly pure can try to support this distinction through conventions. Scheme is a good example: procedures which modify or depend on state tend to be named with a !, like. This is not quite the same as being purely functional, but it is closer to functional than not.(SICP) does a good job of teaching and motivating the difference between functions and procedures in Scheme. It's well worth a read as an introduction to abstraction as well as different programming paradigms; the only important thing it's missing is types. And I love the analogy between programmers and sorcerors (which is most apparent on the old 1st edition cover²).Python does. There is simplyin the language or standard conventions. Python simply doesn't offer any support for this, which puts it quite far from being a purely functional language!In fact, Python is pretty poor even as an impure functional language. Why? Well, there's a lot of little reasons: most of the standard structures are mutable, there's an ugly distinction between statements and expressions, many standard idioms and constructions are inherently impure... etc. But there is one big: Python was simply. In fact, Guido! He didn't even want the meager features Pythonhave—like its unfortunate lambdas or map and filter—in the language in the first place. He moved, a fairly fundamental functional construct, into a separate module and opposes supporting proper tail calls.In fact, Guido wanted to(including lambdas!) and only kept map, filter and lambda because of significant public outcry. He wasn't the one to add them in the first place and doesn't like them:You simply can't expect good functional programming when the language is run by a BDFL who turns out not to be so benevolent!So: Python is a bad functional languages because it was¹ In fact, it's interesting to note that Haskell actually hasprocedures are the most general: they can do anything, just like subroutines in other languages. However, you can also have more constrained procedures likewhich can use mutable state but not do arbitrary IO. This is nice because the scope of the state is strictly delimited and references can't leak out of it, giving you more control over the behavior of the procedures. The extratype variable is for managing the scope.² It's a wizard casting the Scheme metacircular evaluator as a spell:|||

