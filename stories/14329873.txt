From the sample web application, we see that the third parameter to the scotty function is a list of actions that needs to be performed if the request matches the route pattern specified as the second argument. Every time a request needs to be processed, we want to be able to match the request to the url pattern and use the respective action to process the request. Therefore, we want want to wrap each action in a route. Hence we create a set of routes to handle request to different url patterns. We will store this information in the scotty state.

We want any client of Scotty to be able to create a route handler for each route pattern. One way we can do that is to thread the request through a list of routes handlers until one of the routes wraps an action that succeeds. Every route handler should take a Request type and return some m Response type (eg. IO Response). We also want to thread our requests to the next route handler. Therefore, we a need to create a route value whose type would be to process a request using a particular action and also accept another route handler that can be used if the request cannot be processed with the given action.

The reason why Scotty abstracts over this type will become clearer later on. For now, it is sufficient to understand that with the local Application type Scotty can wrap the Response in a stack of monads that will abstract away some of the error handling that would be required. Notice, this Application type differs from our toy example. This is due some redirection introduced by Network.Wai library to control the ResponseReceived values returned by each Application.

Scotty also declares a Middleware type. This type is an example of continuation-passing style where a value of type Middleware takes an Application and then decides to delegate the call to its second parameter which happens to be another Application. Using, this pattern we can thread a request through different Application values until the request in successfully processed. This type also gives Scotty the ability to thread a request through a pipeline of Middleware values. The route value we were looking for in the earlier will be a example of Middleware value. With the initial setup of our sample application, we end up with a list of routes which are of type [Middleware m]. Note, that this type aligns with the type the route function in the toy example was using.

In this chapter we will focus on the routes attribute. The routes attribute is a list of routes that Scotty needs to thread every request through till the request is successfully processed. As we discussed earlier, another way to look at the type of one element of routes would be

So, we see that an element of routes is a type that take a function that turns a Request into m Response. In the process, it also receives another function as a continuation that can be used if the first function argument cannot process the request successfully. The tricky thing to observe for a some of us would be to see that the final return value of this function in still m Response, even though the above organization makes it look like a Middleware value is returned. We specifically state the return value of this function is m Response, since that is what is required to interact with the Network.Wai layer.

The core function to understand is the addRoute function. The function takes a StdMethod which specifies one of the Http request methods. The second parameter is the route pattern. For example "/index" or "/:name" etc. The third parameter is the action that is going to be performed for the given request. Notice that each each action is wrapped inside a route closure. This is the parameter that is provided as the second parameter to get as an action value.

We will look at the route function in detail later on. But for now it is enough to understand that the route function wraps the action that needs to be performed for the request. For the novice haskeller, this a great example of power of currying. We seamlessly, create a route value, by providing just the first 4 parameters. The only remaining parameter to this function is Middleware m. When this function gets called later, the Application (which happens to be the next route in the list of routes and the Request object are provided. Therefore, the types check out. Take a minute and reason how the addRoute function returns a value of type Middleware m when called inside the State monad. Then think about how a Request and Application m can be passed to this function at a later time.

Now, looking closely, when the route gets added to the list of routes, the parameters provided to this function are ErrorHandler e m, Maybe StdMethod, RouterPattern, ActionT e m. The remaining parameters are provided when the client requests arrive. When the client requests arrive, first the ActionT e m () value is run using runAction and if that action fails, then tryNext is called which passes the Request on to the next Application. The next handler could be any Middleware m (that is another route or an arbitrary middlware).

In this section, we explored how the third parameter we passed to scotty function is used to configure a list of routes, which each route captures the url pattern of the requests it can service and the action that needs to be applied to the requests when the url pattern matches. This also aligns with toy scotty we built using a similar route function.|||

