A recent post by Yegor Bugayenko titled Why I Don’t Talk to Google Recruiters highlighted a common misconception about careers in the software industry, certainly a misconception that I had in the early years of my career.

Yegor described a very unproductive interview experience he had with Amazon, where he was subjected to the dreaded whiteboard hazing:

Some programmers who didn't know a thing about my profile asked me to invent some algorithms on a white board for almost four hours. Did I manage? I don't think so. Did they make me an offer? No. If [the Amazon recruiter] would have started her email with "We're looking for an algorithm expert," we would never have gotten any further and would not have wasted our time. Clearly, I'm not an expert in algorithms. There is no point in giving me binary-tree-traversing questions; I don't know those answers and will never be interested in learning them.

I stopped nodding my head long enough to write a sympathetic tweet:

Like many developers, I fantasized about working for companies like Google—a company with cool products that I admired and with legendary perks for its employees. It took me a long time to understand that Google selects for a certain kind of programmer, one that I fundamentally was not.

As Jon Galloway explained in a post back in 2008, one that was highly influential on me at the time:

Steve Yegge works for Google. Steve and I are both professional programmers; in fact we both work on web applications. Yet, our jobs are no more related than if we were both doctors in different fields - say, a podiatrist and an orthodontist. For example, if you work for Google, you're going to be concerned with how to make your applications run against huge data sets using large, unreliable computer clusters. None of those are priorities in applications I work on, since I'm generally working against a relational database which aren't running at high volume or scale. So, Steve is thinking about how to build Google-scale applications running on Map/Reduce, while I'm working on comparatively small projects running against relational databases. I still believe that Steve's questions would be useless in hiring someone to work on my current projects. I don't care if a candidate can check if a high-order bit is set, to the point that I might be a little turned off by an applicant whose answer revealed they were a bit-twiddler. I've hired bit-twiddlers before, and while they interviewed well, they weren't much help in shipping applications. Worse, we're wasting valuable time talking about hexadecimal formatting when we should be covering things like database access and rudimentary knowledge of HTML and HTTP.

What it comes down to is that the “software industry” is comprised of many kinds of people, working for many different companies, working on very different things, with very different priorities.

Don’t beat yourself up if you don’t spend your free time on Project Euler or if the idea of working through the linked list algorithms in a book about technical interviews makes you want to slit your wrists.

Most software jobs outside of Silicon Valley are not with high profile tech companies that hire for these kinds of traits. Most companies are interested in hiring people with experience in solving real, everyday business challenges with the technologies they’re invested in.|||

