This post is written as a follow-up on one of my Facebook conversations. Exception handling is one of topics almost everyone understands differently. But any code we write is somehow relying on exception handling, so understanding all the details of this process is important — that’s why I finally made myself to write it :)

The post is mostly focused on .NET exception handling, though the rules are almost the same in nearly any other language supporting exceptions; some of C++, Python, and JavaScript specific rules are mentioned explicitly here. In short, if you use some other language and don’t know much about exception handling, reading this post definitely won’t be a waste of your time.

The most common questions on exception handling:

I’ll try to answer all these questions, so let’s start.

Short answer is: it’s better for you to assume it can throw anything — no matter what you call. What can be thrown is not important — you should care only about what you can handle.

Of course, if you call a very simple method, such as int.Parse(…), you can more or less safely assume that it throws only X + a set of exceptions that could be thrown by any code. But you shouldn’t make any assumptions for even moderately complex methods you call.

Also note that interface / virtual method calls are very frequent in apps relying on Inversion of Control / Dependency Injection (in other words, in any apps built by experienced engineers): since the actual implementations of dependencies are injected into the constructor / properties, almost any class you write uses interfaces of these dependencies — so you never know the exact implementation.

All of this sounds crazy, right? I mean, how am I even supposed to write a code if any piece of code I write can throw anything?

The good side is: there are other rules that actually make all of this easy and logical. Let’s look at one of them:

First, let’s define what “to handle an exception” means. Actually, there are just 3 possible cases you should keep in mind:

If your case doesn’t fall into one of these 3 categories, most likely you’re doing something wrong: other possible scenarios (e.g. when you need to take an action only for a certain kind of exception but still rethrow it) are necessary in maybe just 0.1% of all the cases.

Now let’s look closer on these 3 patterns.

All these cases are similar to this one:

As you can see, we look for specific errors here (FormatException, OverflowException).

How do we know which errors we should look for?

Note that there is a 3rd kind of exception that can be thrown by int.Parse:

So when do you need a “catch” block? The key question you should ask is: can you do anything meaningful to gracefully handle some of possible errors in this specific call?

Also note that the example I provided here is actually an example of wrong use of int.Parse: this method has a sibling allowing to us write the same code as:

TryParse returns true when parse succeeds, and false otherwise. So in fact, MyIntParse is redundant.

And here we come to another interesting question: why there are two “flavors”of int.Parse? Or in other words, if I have to write a method that throws some exceptions — when do I need to provide a similar overload that doesn’t throw an exception?

You should know two points here:

You can try it online here. The output of this code:

As you see, try-catch version is ~ 150 … 300x slower when there is an error, otherwise it’s similarly fast. In other words, you can throw and catch only about 90K exceptions per second in a single thread on CoreCLR, and only about 50K / second — on “vanilla” .NET.

Presence of try-catch doesn’t add anything to the overall time. That’s expected: try-catch-finally only leads to a bit different layout of a code generated by JIT compliler (there are more jmp instructions), but it’s still the same code. The addresses of “catch” and “finally” blocks to process are identified only when an exception is thrown — when a stack walk happens (note that it is anyway necessary to capture the stack trace). A return address on each stack frame is enough to identify the address of corresponding exception handling code, and .NET runtime actually has this mapping.

As a result, the version with exception handling is the fastest one — mainly, because it doesn’t allocate as much on call stack as others do, though in this case the difference is tiny: TryParse accepts a single extra pointer. But as you see, this 1ms (~ 2%) difference is still measurable.

And that’s a nice example of why exception handling is good, and how it’s supposed to be used: all “try” blocks add zero overhead in case of normal execution flow. So if you throw exceptions only in truly exceptional cases, your performance won’t suffer at all. Based on above measurements, if you throw ~5000 exceptions per second per thread, you should expect ~1% performance degrade. In reality, you should minimize the frequency of throws to a bare minimum, and later we’ll discuss what are more precise criteria of when an exception has to be thrown.

Interestingly that in these languages it is typically very different:

All that I wrote here is mainly based on my past experience with CPython. One of pretty unexpected consequences of such a behavior there is that all generators (~ enumerators in C#) have a single next() method expected to return the next item from the sequence, or throw StopIteration exception, if there are no more items. And that’s a huge language design issue:

This is a remarkable example showing that even Guido van Rossum probably didn’t know how to deal with exceptions at the moment he’ve made this decision. As a result of this single mistake, his creation (Python) will never be as fast as e.g. JavaScript — no matter how sophisticated the Python interpreter or JIT compiler is. Honestly, there are many other design issues making Python one of the worst choices, if you care about speed, but it’s still a very good choice for any research / data science / ML projects, where speed is either not a concern, or it’s “covered” by non-Python code.

Anyway, this issue seems to be a very strong “showcase” explaining why it makes sense to know the fundamentals of exception handling for every developer.

We covered one out of three cases I listed earlier:

So the question for this section is: when do I need a “finally” block?

The answer here is actually the simplest one: you need “finally” only in case you need to take certain actions immediately after the completion of “try” block, and independently on whether there was an error or not.

This sounds like a definition of what “finally” does, so let me clarify this further:

There are two main features in .NET runtime that are dedicated to resource disposal:

A few other rules related to IDisposable and finalizers are less well-known:

Let’s see how disposables and finalizers are supposed to be implemented:

Now, let’s get back to “finally” — how all of this is related to finally blocks?

Note that IDisposable itself implements the same pattern, but for “owned” disposables referenced from object’s fields.

Now, are there any language features that simplify writing these try-finally blocks? Yes:

There are 3 other C# keywords that use try-finally under the hood:

As you can see,

I promised to show there is an extra cost associated with having a finalizer. A part of this cost is paid when such an instance is created:

The output (this time it’s from my Core-i7 laptop):

If there would be no “using” keyword, your “finally” section would be responsible mainly for resource disposal. But since there is “using”, normally you won’t need even this — typically, you’ll have this code instead:

So normally you’ll use “finally” for other purposes — e.g. to implement lock-unlock pattern or something similar. In reality even this is rarely necessary in .NET — mainly, because most of types requiring this kind of behavior also provide IDisposable implementation to support dispose pattern — e.g. that’s how it works with AsyncLock from AsyncEx.

This is why if your “finally” looks complex (or even exists) in .NET, there is a good chance you’re doing something wrong. Probably the most frequent case is when your code needs it because your own types require some finalization, although they don’t implement IDisposable — i.e. basically, you have to rely on “finally” instead of “using” only because you don’t know .NET well enough.

To recap, that’s where we are now:

Catch-and-rethrow case is fairly simple: it’s mostly used for logging, and for passing the information about exception to the “finally” block. Consider this example:

The last case to cover is catch-and-mask, i.e. throw some other exception instead. In general you should avoid this by all means, though there are a few rare cases where it makes sense:

I can’t remember any other well-known examples of this, which means that you should think about doing something similar in a very very rare cases.

Let’s list all of them:

So there 4 of such exceptions, but I suspect there might be something else :)

Should you do anything special about these exceptions? Nope. To deal with them, you should just properly place your try-finally / using / lock blocks.

Obviously, any throw can be replaced with a special type of result. So it’s good to know what’s preferable in a particular case — a special type of result, or an exception?

I don’t remember if I ever saw a very precise description of how to approach this — probably, because there is no “perfect” answer. The most important criteria are:

Throw an exception, if, when thrown:

And finally, when in doubt, think of implementing both. In .NET such methods are normally implemented with TryXxx pattern:

Why both methods can be useful? Let’s think about int.Parse again:

Note that C# 7 also supports tuples, and I suspect returning a tuple of (bool, TResult) is a bit faster alternative to bool + out TResult. But since no one uses this alternative just yet, I recommend to stick to the old one for now.

Almost never — you should always try to use the best fitting standard exception type first (i.e. any exception type from System namespace of mscorlib.dll assembly).

You need your own exception type, when:

Note that System namespace doesn’t provide any standard exceptions that resemble “type 2” exceptions — i.e. all the standard exception types are “type 1” exceptions, and they cover almost all imaginable scenarios. So another indication that you need your own exception type is when you can’t find a match among standard ones.|||

This post is written as a follow-up on one of my Facebook conversations. Exception handling is one of topics almost everyone understands differently. But any code we write is somehow relying on…