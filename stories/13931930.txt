Whenever I plug an external monitor into my laptop, nothing happens. Then I run xrandr, and gears turn, and displays appear. Not too surprising. Whenever I unplug an external monitor, nothing happens. Then I run xrandr, gears turn, and all those hidden offscreen windows come screaming back. This is absurd, right? Shouldn’t my desktop software be, I don’t know, desktopping?

I actually like it, and I wouldn’t want it any other way. Like many people, I have a particular desktop setup I like. An arrangement of xterms for this, an arrangement of xterms for that, an email client here, a browser there. Some of it is big time serious business and goes on the big monitor. Other stuff lives on the small screen.

What’s neat is I can take a break, unplug and move about without being flooded by all those serious windows. Then I go back to my desk and everything is just where I left it. Every other desktop system I’ve used insists on collapsing the desktop the instant a monitor is disconnected. If they try to be smart, they’ll make some effort to put things back when reconnected, but that’s very different from actually being smart. Lucky if half the windows end up where they should be, and only if you’re careful not to move or touch them in the interim. I sometimes tell people this story and they chuckle at the primitiveness of OpenBSD, but then they sigh as they wish their laptop could do the same. Hardly sufficient motivation to switch, but a sad commentary on our willingness to accept aggravation as one of the base conditions for using a computer.

Collapsing the desktop is an obvious usability feature. If you don’t know about offscreen windows and don’t know how to get them back, that can be quite frustrating. But even when the feature works, it can be frustrating. Giving a presentation and bump the laptop, interrupting the display connection for half a second? Boom. Presentation is over. Now everybody gets to watch as we fiddle with remirroring the display, restarting the presentation, fast forwarding through all the slides, etc. All because some developer decided that no signal was incontrovertible proof that the presentation must be over.

My example is admittedly very niche, and it never would have occurred to me to request it. I discovered it quite by accident in fact, but I’m no less happy to have it. True of many (mis)features I suspect. We become accustomed to the way things are, the way things apparently should be. It makes me wonder what else my computer does automatically that given the opportunity I might disable, but have overlooked because sometimes it’s helpful. If there’s something I want done, I can eventually learn to do it, but how do I learn what I don’t want done?

Similar example: On Windows, I like to keep random desktop debris lined up along the top. Every other graphics driver update will flip the screen to lowres mode for a quarter second, jamming all the icons into several rows. Does Windows put them back when the screen returns to hires? No, it doesn’t. There is no way to request that off screen icons only be collected manually, so my workaround is to not update the graphics driver. Hurray. Users will go to absurd lengths to avoid features that work against them. The computer that does something undesired is twice as aggravating as the computer that fails to do something desired.

Of course, it’s possible to rationalize anything. There’s an xkcd about exactly this. It helps to think of systems in three categories. A system where you can do something, a system where you cannot do something, and a system where you can not do something. The distinction between the second and third categories is subtle but important.|||

