FRACTRAN is a Turing-complete esoteric programming language invented by the mathematician John Conway. A FRACTRAN program is an ordered list of positive fractions together with an initial positive integer input n. The program is run by updating the integer n as follows:

In The Book of Numbers, John Conway and Richard Guy gave a formula for primes in FRACTRAN:[1][note 1]

Starting with n=2, this FRACTRAN program generates the following sequence of integers:

After 2, this sequence contains the following powers of 2:

which are the prime powers of 2.

A FRACTRAN program can be seen as a type of register machine where the registers are stored in prime exponents in the argument n.

Using Gödel numbering, a positive integer n can encode an arbitrary number of arbitrarily large positive integer variables.[note 2] The value of each variable is encoded as the exponent of a prime number in the prime factorization of the integer. For example, the integer

represents a register state in which one variable (which we will call v2) holds the value 2 and two other variables (v3 and v5) hold the value 1. All other variables hold the value 0.

A FRACTRAN program is an ordered list of positive fractions. Each fraction represents an instruction that tests one or more variables, represented by the prime factors of its denominator. For example:

tests v2 and v5. If and , then it subtracts 2 from v2 and 1 from v5 and adds 1 to v3 and 1 to v7. For example:

Since the FRACTRAN program is just a list of fractions, these test-decrement-increment instructions are the only allowed instructions in the FRACTRAN language. In addition the following restrictions apply:

The simplest FRACTRAN program is a single instruction such as

This program can be represented as a (very simple) algorithm as follows:

Given an initial input of the form , this program will compute the sequence , , etc., until eventually, after steps, no factors of 2 remain and the product with no longer yields an integer; the machine then stops with a final output of . It therefore adds two integers together.

We can create a "multiplier" by "looping" through the "adder". In order to do this we need to introduce states into our algorithm. This algorithm will take a number and produce :

State B is a loop that adds v3 to v5 and also moves v3 to v7, and state A is an outer control loop that repeats the loop in state B v2 times. State A also restores the value of v3 from v7 after the loop in state B has completed.

We can implement states using new variables as state indicators. The state indicators for state B will be v11 and v13. Note that we require two state control indicators for one loop; a primary flag (v11) and a secondary flag (v13). Because each indicator is consumed whenever it is tested, we need a secondary indicator to say "continue in the current state"; this secondary indicator is swapped back to the primary indicator in the next instruction, and the loop continues.

Adding FRACTRAN state indicators and instructions to the multiplication algorithm table, we have:

When we write out the FRACTRAN instructions, we must put the state A instructions last, because state A has no state indicators - it is the default state if no state indicators are set. So as a FRACTRAN program, the multiplier becomes:

In a similar way, we can create a FRACTRAN "subtracter", and repeated subtractions allow us to create a "quotient and remainder" algorithm as follows:

Writing out the FRACTRAN program, we have:

and input 2n3d11 produces output 5q7r where n = qd + r and 0 ≤ r < d.

Conway's prime generating algorithm above is essentially a quotient and remainder algorithm within two loops. Given input of the form where 0 ≤ m < n, the algorithm tries to divide n+1 by each number from n down to 1, until it finds the largest number k that is a divisor of n+1. It then returns 2n+1 7k-1 and repeats. The only times that the sequence of state numbers generated by the algorithm produces a power of 2 is when k is 1 (so that the exponent of 7 is 0), which only occurs if the exponent of 2 is a prime. A step-by-step explanation of Conway's algorithm can be found in Havil(2007).

calculates the Hamming weight H(a) of the binary expansion of a i.e. the number of 1s in the binary expansion of a.[2] Given input 2a, its output is 13H(a). The program can be analysed as follows:|||

