The SciMark 2.0 Monte Carlo benchmark is calculating \(\pi\) by generating random points \(\{(x,y) \mid x,y \in [0,1]\}\) and calculating the ratio of points that are located within the quarter circle \(\sqrt{x^2 + y^2} \le 1\). The square root can be avoided by squaring both sides, and the benchmark is implemented asGCC used to generate a conditional move for this if-statement, but a recent change made this generate a normal branch which caused a 30% performance reduction for the benchmark due to the branch being mispredicted ( bug 79389 ).The randomization function is not inlined as it is compiled in a separate file, and it contains a non-trivial amount of loads, stores, and branchesso I had expected the two calls to this function to dominate the running time, and that the cost of the branch would not affect the benchmark too much. But I should have known better ‚Äî x86 CPUs can have more than 100 instructions in flight (192 micro-ops for Broadwell), and a mispredict need to throw away all that work and restart from the actual branch target.The cost of branch instructions differ between different CPU implementations, and the compiler needs to take that into account when optimizing and generating branches.Simple processors with a 3-stage pipeline fetch the next instruction when previous two instructions are decoded and executed, but branches introduce a problem: the next instruction cannot be fetched before the address is calculated by executing the branch instruction. This makes branches expensive as they introduce bubbles in the pipeline. The cost can be reduced for conditional branches by speculatively fetching and decoding the instructions after the branch ‚Äî this improves performance if the branch was not taken, but taken branches need to discard the speculated work, and restart from the actual branch target.Some CPUs have instructions that can execute conditionally depending on a condition, and this can be used to avoid branches. For examplecan be compiled to the following straight line code on ARM (assuming that, andare placed in, andrespectively)Theinstruction sets theflag in the status register, and theinstruction is treated as an addition ifis 0, and as ainstruction ifis 1.is similarly treated as a subtraction ifis 1 and as aifis 0. The instruction takes time to execute, even when treated as a, but this is still much faster than executing branches.Taken branches become¬†more expensive as the CPUs get deeper pipelines, and this is especially annoying as loops must branch to the top of the loop for each iteration. This can be solved by adding more hardware to let the fetch unit calculate the target address of the conditional branch, and the taken branch can now be the cheap case.It is, however, nice to have the ‚Äúnot taken‚Äù case be the cheap case, as the alternative often introduce contrived control flow that fragments the instruction cache and need to insert extra ‚Äúuseless‚Äù (and expensive) unconditional branches. The way most CPUs solve this is to predict that forward branches are unlikely (and thus speculatively fetch from following instructions), and that backward branches are likely (and thus speculatively fetch from the branch target).There are many branches that the compiler cannot predict, so the next step up in complexity is adding branch prediction to the CPU. The basic idea is that the CPU keeps a cache of previous branch decisions and use this to predict the current branch. High-end branch predictors look at the history of code flow, and can correctly predict repetitive patterns in how the branch behaved. Hardware vendors do not publish detailed information about how the prediction work, but Agner Fog‚Äôs optimization manuals contain lots of information (especially part 3, ‚Äú The microarchitecture of Intel, AMD and VIA CPUs ‚Äù, that also have a good overview of different ways branch prediction can be done).Branch prediction in high-end CPUs is really good, so branches are essentially free, while conditional execution adds extra dependencies between instructions which constrain the out-of-order execution engine, so conditional execution should be avoided. This is essentially the opposite from how the simple CPUs should be handled. üòÉ|||

