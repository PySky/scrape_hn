Every now and then, with the advancements in technology, new programming paradigms emerge or gain traction, making developers completely shift the way we thing about their programs. The explosion of the Object Oriented [OO] languages widely disseminated the OO paradigm, with Java being the most used language in the world. It is very common to anyone trying to put the OO paradigm into somebody's head, to say that everything is an object. The time has come, and we are in the verge of a new paradigm shift; now, everything is a stream!

We got stuck in the evolution of processors, so the way we scale an application has switched from creating more powerful machines to replicating our programs through commodity hardware; add high velocity networks and that turns to be the cloud, which exponentially increased our scaling capacity. However, as well advised by Uncle Ben: with great power comes comes great responsibility, and we saw a big increase in the complexity of our systems, resulting in the Microservices architecture emerging to help us on handling it.

Here we are now, with unlimited processing power, but programs that can only take advantage of a single process, and a high level of complexity to add parallelism using OO languages threads manipulation APIs. A regular application using the Object Orientation paradigm gets quite complex to read, with nested generalizations and spread specializations, adding threads for parallelism using native APIs makes the code get even bigger and harder to reason about, with maintenance costs raising more and more on a distributed environment.

The Reactive Programming paradigm brings big improvements to this scenario, where applications does not rely solely on extensive defined flows, as opposed to the OO and Imperative paradigms, and instead relies on compostable state transitions, where observers with reaction logic are attached to state changing observables, making the program very decoupled on a very low level of abstraction, way easier to read, reason about, maintain, and mainly: asynchronous.

Reactive applications are asynchronous by nature, exempting the developer to reason about parallelism and keep the focus on the functionality, taking full advantage of the distributed computing power. The good news are that it is possible to start using such capabilities without a complete technological shift, once that the well known Reactive Extensions (ReactiveX) brings these concepts to most OO languages, and many other frameworks and toolkits, such as: Akka, Vert.x, and Spring Reactor, allows for progressive transition to the reactive world, leveraging not only programs, but also reactive applications architecture.

Technology will continue to evolve and paradigm shifting is something that we as developers should aways be willing to embrace. I myself enjoy wrapping my head around new paradigms, and I get really amazed once they start to make sense to me, - I am sure you felt the same way when the OO paradigm started making sense to you -. There are other very interestingÂ paradigms empowering recent technological advancements, such as the Functional Paradigm for Serverless Architecture, and even really cool multi-paradigm languages, such as Elixir, but these are topics for a next writing.|||

