This is a new thing I am trying where I scan a few pages of a sketchbook and explain it, expand upon it. A lot my praxis in designing delivery pipelines is in illustration but up to now I have never shared this aspect of how I solve problems! So it is exciting to show this: the first ever post showing how I draw out my problem spaces!!!!

Daily cadence is entirely overlooked by management analysts. Only since Dekker and co. Began focusing on sharp end event situational awareness has daily cadence become of interest to risk managers.

Some thoughts on what “in sync with master” could mean in terms of build semantics.

This represents @stanks’ observation that answering the question of what CI does or what does Jenkins deliver in terms of value and ROI can be answered by saying “continuous automated testing ” and then leading the querent down the semantic tree that descends from asking why “continuous automated testing ” would be important.

Also it is abbreviated as C.A.T. so as a tentacular devops your value add can be communicated as CAT.

This is deeply useful in terms of naming tentacular devops things which is the hardest problem in tentacular devops computer science!

It would be useful to google each of the above phrases IF one seeks the way of my tentacular devops. Also then google “world of Warcraft is the new golf”

An outline of my talk on test oracles, most recently delivered at a meetup at Wise Engineering, Ukraine 2015.

BATS is the test runner for bash shell scripts. It is maintained by smart people like Mislav. I love my testrunner so much I draw little bats in my notebooks all the time!

It is awesome use bats to test all your shell script.

All your shell script are be test by bats.

All your shell script are be PWNT by bats, if you seek to PWN your own scripts. Which you will if test your assumptions you do. Which you should.

Some new ideas here. Do see though @bigballofmud paper “The Selfish Class” which makes the association between Dawkins “selfish meme” and memes as atomic components of the semantics of software systems. Or “software architecture” if you prefer.|||

