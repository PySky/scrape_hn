The terms lvalue and rvalue are not something one runs into often in C/C++ programming, but when one does, it's usually not immediately clear what they mean. The most common place to run into these terms are in compiler error & warning messages. For example, compiling the following with :

True, this code is somewhat perverse and not something you'd write, but the error message mentions lvalue, which is not a term one usually finds in C/C++ tutorials. Another example is compiling this code with :

Now the error is:

Here again, the error mentions some mysterious rvalue. So what do lvalue and rvalue mean in C and C++? This is what I intend to explore in this article.

This section presents an intentionally simplified definition of lvalues and rvalues. The rest of the article will elaborate on this definition. An lvalue (locator value) represents an object that occupies some identifiable location in memory (i.e. has an address). rvalues are defined by exclusion, by saying that every expression is either an lvalue or an rvalue. Therefore, from the above definition of lvalue, an rvalue is an expression that does not represent an object occupying some identifiable location in memory.

The terms as defined above may appear vague, which is why it's important to see some simple examples right away. Let's assume we have an integer variable defined and assigned to: An assignment expects an lvalue as its left operand, and is an lvalue, because it is an object with an identifiable memory location. On the other hand, the following are invalid: Neither the constant , nor the expression are lvalues (which makes them rvalues). They're not lvalues because both are temporary results of expressions, which don't have an identifiable memory location (i.e. they can just reside in some temporary register for the duration of the computation). Therefore, assigning to them makes no semantic sense - there's nowhere to assign to. So it should now be clear what the error message in the first code snippet means. returns a temporary value which is an rvalue. Attempting to assign to it is an error, so when seeing the compiler complains that it expected to see an lvalue on the left-hand-side of the assignment statement. Not all assignments to results of function calls are invalid, however. For example, C++ references make this possible: Here returns a reference, which is an lvalue, so it can be assigned to. Actually, the ability of C++ to return lvalues from functions is important for implementing some overloaded operators. One common example is overloading the brackets operator in classes that implement some kind of lookup access. does this: The assignment works because the non-const overload of returns a reference that can be assigned to.

Generally speaking, language constructs operating on object values require rvalues as arguments. For example, the binary addition operator takes two rvalues as arguments and returns an rvalue: a = ; b = ; c = a + b; // + needs rvalues, so a and b are converted to rvalues // and an rvalue is returned As we've seen earlier, and are both lvalues. Therefore, in the third line, they undergo an implicit lvalue-to-rvalue conversion. All lvalues that aren't arrays, functions or of incomplete types can be converted thus to rvalues. What about the other direction? Can rvalues be converted to lvalues? Of course not! This would violate the very nature of an lvalue according to its definition . This doesn't mean that lvalues can't be produced from rvalues by more explicit means. For example, the unary (dereference) operator takes an rvalue argument but produces an lvalue as a result. Consider this valid code: arr[] = { , }; * p = &arr[ ]; *(p + ) = ; // OK: p + 1 is an rvalue, but *(p + 1) is an lvalue Conversely, the unary address-of operator takes an lvalue argument and produces an rvalue: The ampersand plays another role in C++ - it allows to define reference types. These are called "lvalue references". Non-const lvalue references cannot be assigned rvalues, since that would require an invalid rvalue-to-lvalue conversion: std::string& sref = std::string(); // 'std::string&' from an rvalue of Constant lvalue references can be assigned rvalues. Since they're constant, the value can't be modified through the reference and hence there's no problem of modifying an rvalue. This makes possible the very common C++ idiom of accepting values by constant references into functions, which avoids unnecessary copying and construction of temporary objects.

If we read carefully the portion of the C++ standard discussing lvalue-to-rvalue conversions , we notice it says: An lvalue (3.10) of a non-function, non-array type T can be converted to an rvalue. [...] If T is a non-class type, the type of the rvalue is the cv-unqualified version of T. Otherwise, the type of the rvalue is T. What is this "cv-unqualified" thing? CV-qualifier is a term used to describe const and volatile type qualifiers. Each type which is a cv-unqualified complete or incomplete object type or is void (3.9) has three corresponding cv-qualified versions of its type: a const-qualified version, a volatile-qualified version, and a const-volatile-qualified version. [...] The cv-qualified or cv-unqualified versions of a type are distinct types; however, they shall have the same representation and alignment requirements (3.9) But what has this got to do with rvalues? Well, in C, rvalues never have cv-qualified types. Only lvalues do. In C++, on the other hand, class rvalues can have cv-qualified types, but built-in types (like ) can't. Consider this example: The second call in actually calls the method of , because the type returned by is , which is distinct from . This is exactly what's meant by the last sentence in the quote mentioned earlier. Note also that the return value from is an rvalue. So this is an example of a cv-qualified rvalue in action.

Rvalue references and the related concept of move semantics is one of the most powerful new features the C++11 standard introduces to the language. A full discussion of the feature is way beyond the scope of this humble article , but I still want to provide a simple example, because I think it's a good place to demonstrate how an understanding of what lvalues and rvalues are aids our ability to reason about non-trivial language concepts. I've just spent a good part of this article explaining that one of the main differences between lvalues and rvalues is that lvalues can be modified, and rvalues can't. Well, C++11 adds a crucial twist to this distinction, by allowing us to have references to rvalues and thus modify them, in some special circumstances. As an example, consider a simplistic implementation of a dynamic "integer vector". I'm showing just the relevant methods here: So, we have the usual constructor, destructor, copy constructor and copy assignment operator defined, all using a logging function to let us know when they're actually called. Let's run some simple code, which copies the contents of into : Makes sense - this faithfully represents what's going on inside . But suppose that we want to assign some rvalue to : Although here I just assign a freshly constructed vector, it's just a demonstration of a more general case where some temporary rvalue is being built and then assigned to (this can happen for some function returning a vector, for example). What gets printed now is this: Ouch, this looks like a lot of work. In particular, it has one extra pair of constructor/destructor calls to create and then destroy the temporary object. And this is a shame, because inside the copy assignment operator, another temporary copy is being created and destroyed. That's extra work, for nothing. Well, no more. C++11 gives us rvalue references with which we can implement "move semantics", and in particular a "move assignment operator" . Let's add another to : The syntax is the new rvalue reference. It does exactly what it sounds it does - gives us a reference to an rvalue, which is going to be destroyed after the call. We can use this fact to just "steal" the internals of the rvalue - it won't need them anyway! This prints: What happens here is that our new move assignment operator is invoked since an rvalue gets assigned to . The constructor and destructor calls are still needed for the temporary object that's created by , but another temporary inside the assignment operator is no longer needed. The operator simply switches the rvalue's internal buffer with its own, arranging it so the rvalue's destructor will release our object's own buffer, which is no longer used. Neat. I'll just mention once again that this example is only the tip of the iceberg on move semantics and rvalue references. As you can probably guess, it's a complex subject with a lot of special cases and gotchas to consider. My point here was to demonstrate a very interesting application of the difference between lvalues and rvalues in C++. The compiler obviously knows when some entity is an rvalue, and can arrange to invoke the correct constructor at compile time.|||

