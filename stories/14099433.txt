Update: You can now get this post on Kindle.

I‚Äôve been using git full time for the past 4 years, and I wanted to share the most practical tips that I‚Äôve learned along the way. Hopefully, it will be useful to somebody out there.

If you are completely new to git, I suggest reading Git Cheat Sheet first. This article is aimed at somebody who has been using git for three months or more.

Chances are, by now you‚Äôve used git log. It supports a number of command line parameters, which are very powerful, especially when used in combination. Here are the ones that I use the most:

For example, I once had a manager who required weekly reports submitted each Friday. So every Friday I would just run: , edit it a little and send it in to the manager for review.

Git has a lot more command line parameters that are handy. Just run and see what it can do for you.

If everything else fails, git has a parameter that let‚Äôs you create a highly customizable output.

or lets you view not only the commit message, author, and date, but actual changes that took place in each commit.

Then you can use the regular search command of ‚Äúslash‚Äù followed by your search term to look for changes to a particular keyword over time. (Use lower case n to go to the next result, and upper case N to go to the previous result).

You can use to find the person responsible for every line of the file.

is a great tool, but sometimes it does not provide enough information.

An alternative is provided by with a flag. This flag allows you to specify particular lines in a file that you are interested in. Then Git would only log changes relevant to those lines. It‚Äôs kind of like with focus.

If you ever worked on a long-lived branches, with multiple people working on it, chances are you‚Äôve experienced numerous merges of the parent branch(i.e. master) into your feature branch. This makes it hard to see the changes that took place on the master branch vs. the changes that have been committed on the feature branch and which have yet to be merged.

will solve the issue. Note the flag indicate to only show changes that have not been merged yet to ANY branch, and the master.. option, indicates to only show changes that have not been merged to master branch. (You must include the¬†.. after master).

You can also do or (output is identical) to see actual file changes that are have yet to be merged.

Sometimes it is nice to take a pick at an entire file on a different branch, without switching to this branch.

You can do so via , which would show the file in your terminal.

You can also redirect the output to a temporary file, so you can perhaps open it up in a side by side view in your editor of choice.

Note: If all you want to see is a diff between two files, you can simple run:



We‚Äôve talked about a lot of merge commits when working on a remote branch. Some of those commits can be avoided by using .

Generally I consider rebasing to be an advanced feature, and it‚Äôs probably best left for another post.

Even git book has the following to say about rebasing.

That being said, rebasing is not something to be afraid of either, rather something that you should do with care.

Probably the best way to rebase is using interactive rebasing, invoked via . It will open up an editor, with self explanatory instruction. Since rebasing is outside of the scope of this article, I‚Äôll leave it at that.

For example, imagine you are working on a local version of a master branch, and you made one small commit. At the same time, somebody else checked in a week worth of work onto the master branch. When you try to push your change, git tells you to do a first, to resolve the conflict. Being a good citizen that you are, you do a to end up with the following commit message auto generated by git.

While this is not a big deal and is completely safe, it does clutter log history a bit.

In this case, a valid alternative is to do a instead.

This will force git to first pull the changes, and then re-apply(rebase) your un-pushed commits on top of the latest version of the remote branch, as if they just took place. This will remove the need for merge and the ugly merge message.

I like to create a new branch for every new bug or feature. Among other benefits, it helps me to get a great clarity on how a series of commits may relate to a particular task. If you ever merged a pull request on github or a similar tool, you will in fact be able to nicely see the merged branch history in view.

If you ever try to merge a local branch, into another local branch, you may notice git has flatten out the branch, making it show up as a straight line in git history.

If you want to force git to keep branches history, similarly to what you would see during a pull request, you can add a flag, resulting in a nice commit history tree.

This one is pretty straightforward.

Let say you made a commit and then realized you made a typo. You could make a new commit with a ‚Äúdescriptive‚Äù message typo. But there is a better way.

If you haven‚Äôt pushed to the remote branch yet, you can simply do the following:

If you are working on your own branch, you can fix commits even after you have pushed, you would just have to do a (-f stands for force), which would over-ride the history. But you WOULD NOT want to do this on a branch that is being used by other people (as discussed in rebase section above). At that point, a ‚Äútypo‚Äù commit, might be your best bet.

As you may already know by now, a file in git can be in 3 stages:

You can see a long description of the files and state they are in by running . You move a file from ‚Äúnot staged for commit‚Äù stage to ‚Äústaged for commit‚Äù stage, by running or to add all files at once.

Another view that makes it much easier to visualize the stages is invoked via where stand for short (I think), and would result in an output that looks like that:

Obviously, will not show files that have already been committed, you can use to see those instead üôÇ

There are a couple of options available to you to move the files to a different stage.

There are 3 types of reset available in git. A reset allows you to return to a particular version in git history.

This may appear as useless information at first, but it is actually very handy when you are trying to move through different version of the file.

Common use cases that I find myself using the reset are bellow:

If you simply want to forget some local changes for some files, but at the same time want to keep changes made in other files, it is much easier to check out committed versions of the files that you want to forget, via:



It‚Äôs like running but only on some of the files.

As mentioned before you can also check out a different version of a file from another branch or commit.

You‚Äôll notice that the checked out files will be in a ‚Äústaged for commit‚Äù stage. To move them back to ‚Äúun-staged for commit‚Äù stage, you would have to do a . You can run again, to return the file to it‚Äôs original state.

Note, that running does not work. In general, moving through various stages in git is a bit confusing and the pattern is not always clear, which I hoped is to remedied a bit with this section.

This one is handy if you want to undo a previous commit or two, look at the changes, and see which ones might have caused a problem.

Regular will automatically re-commit reverted files, prompting you to write a new commit message. The flag tells git to take it easy on committing for now, since all we want to do is look.

My favorite diff-ing program is Meld. I fell in love with it during my Linux times, and I carry it with me.

I am not trying to sell you on Meld, though. Chances are you have a diff-ing tool of choice already, and git can work with it too, both as a merge and as a diff tool. Simply run the following commands, making sure to replace meld with your favorite diff tools of choice:

After that all you have to do is run to see the changes in that program instead of the console.

But some of the diff-ing tools (such as meld) support full directory diffs.

If you invoke with a flag, it will try to diff the entire folder. Which could be really handy at times.

Have you ever re-indented or re-formatted a file, only to realize that now shows that you are responsible for everything in that file?

Turns out, git is smart enough to know the difference. You can invoke a lot of the commands (i.e. , ) with a flag, and git will ignore the white space changes.

Somebody at git must really like the flag, because it always comes with some handy functionality.

In case of , it allows you to interactive select exactly what you want to be committed. That way you can logically organize your commits in an easy to read manner.

It is common for a large number of remote branches to just hang around, some even after they have been merged into the master branch. If you are a neat freak (at least when it comes to code) like me, chances are they will irritate you a little.

You can see all of the remote branches by running git branch with the flag (show all branches) and the flag would only show branches that are fully merged into the master branch.

You might want to run (fetch and purge old data) first, to make sure your data is up to date.

If you want to get really fancy, you can get a list of all the remote branches, and the list of last commits made on those branches by running:

¬† .

Unfortunately, there is no easy way (that I know of) to only show merged branches. So you might have to just compare the two outputs or write a script to do it for you.

If you don‚Äôt yet know what does, it simply puts all your unsaved changes on a ‚Äúgit stack‚Äù of sorts. Then at a later time you can do and your changes will be re-applied. You can also do to see all your stashed changes. Take a look at for more options.

One limitation of regular is that it will stash all of the files at once. And sometimes it is handy to only stash some of the file, and keep the rest in your working tree.

Remember the magic command? Well it‚Äôs really handy with as well. As you may have probably guessed by now, it will ask you to see which chunks of changes you want to be stashed.

Make sure to hit¬† while you at it to see all available options.

Another handy trick, for stashing only some of the files, is to:

A little while ago I came across a great article on how to write a good commit message. Check it out here: How to Write a Git Commit Message

One rule that really stood out for me is, ‚Äúevery good commit should be able to complete the following sentence‚Äù

When applied, this commit will: {{ YOUR COMMIT MESSAGE}}

For example:

‚Ää‚Äî‚ÄäWhen applied this commit will Update README file

‚Ää‚Äî‚ÄäWhen applied this commit will Add validation for GET /user/:id API call

‚Ää‚Äî‚ÄäWhen applied this commit will Revert commit 12345

Git packages for some operating systems (i.e. Ubuntu) come with git auto completion enabled by default. If your operating system did not come with one(Mac doesn‚Äôt), you can easily enable it by following these guidelines:

TLDR; Use git or bash aliases for most commonly used long git commands

Best way to use Git is via command line, and the best way to learn the command line is by doing everything the hard way first (typing everything out).

After a while, however, it might be a good idea to track down your most used commands, and create an easier aliases for them.

Git comes with built in aliases, for example you can run the following command once:

Which would create a new git alias named , that would allow you to run:

¬† instead of .

Note that you can also append other parameters after the alias (i.e. ).

Another alternative, is good old Bash alias.

For example, I have the following entry in my¬†.bashrc file.

, allowing me to use instead of the long command,which is even 2 character shorter than having to type ¬†:).

uses divide and conquer algorithm to find a broken commit among a large number of commits.

Imagine yourself coming back to work after a week long vacation. You pull the latest version of the project only to find out that a feature that you worked on right before you left is now broken.

You check the last commit that you‚Äôve made before you left, and the feature appear to work there. However, there has been over a hundred of other commits made after you left for your trip, and you have no idea which of those commits broke your feature.

At this point you would probably try to find the bug that broke your feature and use on the breaking change to find the person to go yell at.

If the bug is hard to find, however, you could try to navigate your way through the commit history, in attempt to pin point where the things went bad.

The second approach is exactly where is so handy. It will allow you to find the breaking change in the fastest time possible.

After you specify any known bad commit and any known good commit, will split the in-between commits in half, and checkout a new (nameless) branch in the middle commit to let you check if your future is broken at that point in time.

Let say the middle commit still works. You would then let git know that via command. Then you only have half of the commits left to test.

Git would then split the remaining commits in half and into a new branch(again), letting you to test the feature again.

will continue to narrow down your commits in a similar manner, until the first bad commit is found.

Since you divide the number of commits by half on every iteration, you are able to find your bad commits in log(n) time (which is simply a ‚Äúbig O‚Äù speak for very fast).

You can also automate the process by providing with a script. You can read more here:

If you liked this post, please consider reviewing it on Amazon.|||

I‚Äôve been using git full time for the past 4 years, and I wanted to share the most practical tips that I‚Äôve learned along the way. Hopefully, it will be useful to somebody out there. If you are‚Ä¶