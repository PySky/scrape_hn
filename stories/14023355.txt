A lot of people are recommending Structure and Interpretation of Computer Programs, but I just can’t bring myself to dive into it. I’ve got a lot of blood sweat and tears wrapped up in Common Lisp and Emacs and I dread moving to another milieu. I really like Peter Norvig’s teaching style, though… and I’m so excited about Paradigms of Artificial Intelligence Programming. Boardgame AI is one of those topics that I’ve always thought of as being way beyond my abilities. I just can’t even think of how to even brute-force my way through such a task. My default trial-and-error code-munging style is completely inadequate there…. (It’s sort of like having to learn how to read music in order to become a better musician. There’s just something here that I need to learn.)

So my deductive reasoning (ie debugging) skills are moderately strong, but my advanced analytical skills are pretty pathetic. Maybe I’m not ready for PAIP…. How can I know? Well… I’ll just start anyway and if I end up having to take a detour then so be it.

His first problem set seems deceptively simple to me. The questions are very simple to state, but to get through them, you have to be fluent in recursion, recursion in trees, and even in getting Common Lisp to do your recursion for you. These are techniques that I really agonized over when I was working through Shapiro. It’s nice to see that I’ve internalized the them. I didn’t have to think about some of the problems and a couple of them worked on the first try.

The very first problem had a couple of snags that caused me to waste a lot of time. One was how to deal with symbols that had commas in them. Of course, you can sandwich anything you want between a couple of pipe characters to allow commas to be inside your symbol names. But how do you clean them out? After several failed searches and not being able to find anything relevant in Common Lisp the Language, I ended up finding what I needed at that always useful Common Lisp Cookbook. My solution may not be beautiful, but it gets the job done without being overly munge-tacular.

Another thing I did was come up with a way to recurse backwards over a lisp. There’s no way that my (reverse (rest (reverse list)))) approach can be at all efficient, but again… it’s very difficult to know what they call that function in the Common Lisp culture.

If anyone else is working through this classic programming text, please drop by and compare notes with me. Maybe we can put together an informal study group or something.  My code for the Chapter 1 problem set is here.

This entry was posted on July 20, 2007 at 7:55 pm and is filed under Artificial Intelligence, LISP. You can follow any responses to this entry through the RSS 2.0 feed. You can leave a response, or trackback from your own site.|||

A lot of people are recommending Structure and Interpretation of Computer Programs, but I just can't bring myself to dive into it. I've got a lot of blood sweat and tears wrapped up in Common Lisp and Emacs and I dread moving to another milieu. I really like Peter Norvig's teaching style, though... and I'm…