This module supports type hints as specified by PEP 484 and PEP 526. The most fundamental support consists of the types , , , , , and . For full specification please see PEP 484. For a simplified introduction to type hints see PEP 483.

The function below takes and returns a string and is annotated as follows:

In the function , the argument is expected to be of type and the return type . Subtypes are accepted as arguments.

A type alias is defined by assigning the type to the alias. In this example, and will be treated as interchangeable synonyms: Type aliases are useful for simplifying complex type signatures. For example: # The static type checker will treat the previous type signature as # being exactly equivalent to this one. Note that as a type hint is a special case and is replaced by .

Use the helper function to create distinct types: The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors: # does not typecheck; an int is not a UserId You may still perform all operations on a variable of type , but the result will always be of type . This lets you pass in a wherever an might be expected, but will prevent you from accidentally creating a in an invalid way: # 'output' is of type 'int', not 'UserId' Note that these checks are enforced only by the static type checker. At runtime the statement will make a function that immediately returns whatever parameter you pass it. That means the expression does not create a new class or introduce any overhead beyond that of a regular function call. More precisely, the expression is always true at runtime. This also means that it is not possible to create a subtype of since it is an identity function at runtime, not an actual type. Similarly, it is not possible to create another based on a type: # Fails at runtime and does not typecheck # Also does not typecheck See PEP 484 for more details. Recall that the use of a type alias declares two types to be equivalent to one another. Doing will make the static type checker treat as being exactly equivalent to in all cases. This is useful when you want to simplify complex type signatures. In contrast, declares one type to be a subtype of another. Doing will make the static type checker treat as a subclass of , which means a value of type cannot be used in places where a value of type is expected. This is useful when you want to prevent logic errors with minimal runtime cost.

A user-defined class can be defined as a generic class. as a base class defines that the class takes a single type parameter . This also makes valid as a type within the class body. The base class uses a metaclass that defines so that is valid as a type: A generic type can have any number of type variables, and type variables may be constrained: Each type variable argument to must be distinct. This is thus invalid: You can use multiple inheritance with : When inheriting from generic classes, some type variables could be fixed: In this case has a single parameter, . Using a generic class without specifying type parameters assumes for each position. In the following example, is not generic but implicitly inherits from : # Return type here is same as Union[Iterable[str], int] The metaclass used by is a subclass of . A generic class can be an ABC by including abstract methods or properties, and generic classes can also have ABCs as base classes without a metaclass conflict. Generic metaclasses are not supported. The outcome of parameterizing generics is cached, and most types in the typing module are hashable and comparable for equality.

A special kind of type is . A static type checker will treat every type as being compatible with and as being compatible with every type. This means that it is possible to perform any operation or method call on a value of type on and assign it to any variable: # Typechecks; 'item' could be any type, # and that type might have a 'bar' method Notice that no typechecking is performed when assigning a value of type to a more precise type. For example, the static type checker did not report an error when assigning to even though was declared to be of type and receives an value at runtime! Furthermore, all functions without a return type or parameter types will implicitly default to using : # A static type checker will treat the above # as having the same signature as: This behavior allows to be used as an escape hatch when you need to mix dynamically and statically typed code. Contrast the behavior of with the behavior of . Similar to , every type is a subtype of . However, unlike , the reverse is not true: is not a subtype of every other type. That means when the type of a value is , a type checker will reject almost all operations on it, and assigning it to a variable (or using it as a return value) of a more specialized type is a type error. For example: # Fails; an object does not have a 'magic' method. # Typechecks, since ints and strs are subclasses of object # Typechecks, since Any is compatible with all types Use to indicate that a value could be any type in a typesafe manner. Use to indicate that a value is dynamically typed.|||

