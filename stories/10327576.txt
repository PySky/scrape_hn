In order to better understand the physical world, it sometimes becomes necessary to use mathematical models to predict the reaction of various physical systems, such as the motion of a mass attached to a spring, to external stimuli, like forcing.  Through the use of differential equations, it becomes possible to accurately model the behavior of such systems.  However, to actually see graphical representations of solutions to these models becomes computationally complex.  Enter the analog computer.  Analog computers, through the use of multipliers, summers, and integrators can quickly and accurately represent the differential equation graphically.

In order to model the forced, damped oscillation of a mass attached to a spring, we constructed an analog computer using summers and integrators.  Using the differential equation:  we were able to determine the system’s response to sine, triangle and square waves of frequencies between 2 Hz and 2 MHz.  In constructing our computer, we had designed two circuits.  Both circuits represented the same differential equation, but the second one turned out to be far superior to the first.



 The modeling of the motion of a damped, forced mass-spring system is centered on the differential equation: 

 where M is the mass of the object attached to a spring, K is the damping constant, K is the spring constant, and F(t) is the forcing function. In order to solve this differential equation, one must first solve the homogeneous equation to obtain the natural response of this system. Solving the homogeneous equation gives solutions of the form: 

 Next, we must solve for the particular solution to the original equation.  Using the Laplace Transform, we can transform the equation and solve for x (s). Then using the inverse Laplace Transform, we can solve for x(t).  Solving this integral will give the solution to the differential equation which the analog computer models. Or we could use an analog computer.

One of the most problematic issues we encountered before we could build any circuits was how to design a reliable integrator. Our first attempt involved the use of only a capacitor as the feedback component of the integrator. The integrator consisted of an input resistance (on the order of 10 kilohm to 1 megaohm), a feedback capacitor (.1 microfarad) and an LM 741 Op-Amp. In this case, the integrator also scaled the the output by -1/RCs (with s being the input frequency). One problem that resulted from these integrators was the inability of the integrator to hold a waveform for more than a certain amount of time. The integrator held the proper waveform longer when a square wave was the input and the shortest when a sine wave was an input.  Also, the greater the input resistance, the longer the integrator held the waveform.  The circuit that held the waveform for the longest consisted if the .1 microfarad capacitor as feedback and a 1 megaohm resistor on the input.  This integrator held the following waveforms for the following times:

*Note:  All waves had a frequency of 130 Hz. The integrator could not hold the waveform because the output of the function generator that we used did not have an output of zero for any of the signals.  If it had been, the integrator would have functioned much better. Hence, we started playing around with the circuit and came across what is called a parallel feedback integrator.  A parallel feedback integrator has both a resistor and a capacitor in parallel serving as the mechanism of feedback for the Op-Amp.  This integrator gave us a much more stable waveform.  For our parallel feedback integrator, we used a 10 megaohm resistor as the input resistor and a 5.1 megaohm in parallel with a .1 microfarad capacitor as feedback.  This gave an overall transfer function of -R R R is the feedback resistor and R is the input resistor.  Here are the schematics for the two different integrators we tried:

Once we built this circuit, we soon discovered a number of problems with it that eventually led us to minimize the design.  The largest problem occurred due to the number of Op-Amps that we used.  Since we used 7 Op-Amps, and four of them acted as integrators, the circuit was very susceptible to noise.  When we tested each component of the circuit separately, each performed its function without too much distortion.  However, when we hooked up the whole circuit, the noise became a significant problem, as it was integrated and amplified by the Op-Amps.  Noise also made it difficult to find a stable wave form.  The DC offset on the function generator had to be tweaked for each different wave that we used as input to the circuit in order to achieve a stable output.  If the DC offset was even slightly different from the necessary value, the output would quickly go to a DC output either much greater than the desired output or zero.                 Because the noise effects were so large (as shown in the next section), we decided to minimize the circuit, with much success (discussed in a couple sections).

After some research and some work, here is the block diagram of our minimized analog computer.  Instead of using separate summers, amplifiers, and integrators, we used summer-integrators.  This allowed us to greatly cut down on the number of components needed.  Here is the block diagram for the second circuit that we built. Here is the circuit schematic for this block diagram.  Notice how there are a lot fewer components in this schematic.  Therefore, there are a lot fewer places where noise can enter the circuit. In this circuit, there are three Op-Amps.  Two are used for integration and summation, and one is used as an inverter.  The constants of the differential equation that this circuit model cannot be individually set.  Instead, the four potentiometers allow the ratios between them to be adjusted.   This circuit displayed a much better response to the input, as discussed in the next section.  With this circuit, the noise problem was essentially fixed.  Also, we no longer had to tweak the DC offset of the function generator of the function generator to get the desired result.  In fact, we did not adjust the DC offset.  As soon as the circuit was turned on, the desired output waveform appeared.

The output of the first circuit did not perform as expected.  Noise had too many places where it could enter the system, and the output showed that noise was really affecting it.  The output waves were not very large, and had the characteristic "wiggle" of noise.  Not much can be said about the output of the first circuit except that it was not what was expected. Much can be said about the output of the second circuit however.  The output tried to match the input wave form for every wave that we put into the system.  This is most noticeable in the 1 Hz. Square wave graph.  Notice how the output can never really match the input though.  When triangle waves and sine waves are put into the circuit, this inability to match the input shows up in a phase shift.  In every case, as the frequency increased, the influence of the phase on the output increased.  The computer we used to produce the graphs could not sample fast enough, but the reaction to a 2 MHz. square wave was really interesting.  At 2 MHz, the function generator outputs a really distorted square wave.  It has a lot of wiggles.  It was interesting to see that the output also showed a lot more distortion and a lot more wiggling, as it tried to match the input. This phase shift, and inability to match the input can be described a couple different ways.  In physics terms, this shift is the momentum of the mass that is attached to the spring.  As the input wave switches values, the mass cannot instantaneously follow.  Because of its momentum, it must first be brought to rest and then start moving in the other direction.   In systems terms, the phase shift is simply a result of the circuit.  The circuit does not have a completely linear phase, and this non-linear phase will cause distortions in any waveform as it travels through the circuit.

After adjusting our design, we found that the analog computer efficiently gave solutions to the differential equation that we were trying to model.  Analog computers may not be as accurate as digital computers, but they are incredibly fast at solving differential equations.  Because analog computers solve the whole equation at once, we could change the frequency or shape of the forcing function and have, with an unnoticeable delay, the new solution.  However, there are disadvantages to analog computers.  It was difficult to set the initial conditions because we needed to have a floating voltage source voltage that could quickly be disconnected from the circuit.  Also, it was a challenge to zero out the DC offset of the circuit with the function generator.  In the end, analog computers are an effective way to model real world physical systems.|||

