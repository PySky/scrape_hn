The major advantage of modeling applications with Petri nets is that they provide a natural view on the concurrent behavior of an application. This is achieved by making explicit the preconditions for an operation to be carried out while leaving implicit how and when an operation is triggered and how independent operations are timed.

This OTP behavior allows programming with Petri nets. It implements a very general form of Petri nets using Erlang terms as tokens. This means that (i) tokens are not only markers but can be any data structure conceivable in Erlang, (ii) a place can hold any number of tokens not just one, (iii) transitions can perform any computation conceivable in Erlang.

The Petri net is specified by implementing a set of callback functions (much like the gen_fsm behavior) declaring the place names, the transition names, the preset for each transition, in what modes a transition is enabled, what happens, when a transition fires in a given mode, and the net's initial marking. To communicate with the outside world, callback functions handling calls, casts, and unformatted messages can be provided. Finally, the user can specify a trigger function that is called for each token that is about to emerge on a place. This trigger function can devise side effects and can either let the token be created normally or make it vanish. Both terminating and live nets can be defined using gen_pnet and even though a live net never finishes to make progress, the net instance is constantly responsive to outside requests. Conflicting transitions fire randomly and fairly.

The documentation of the gen_pnet module's API is available online.

This section shows how the gen_pnet library can be added to your project, how Petri nets are defined, and how Petri net instances are started, queried, and manipulated. We demonstrate the API by constructing a cookie vending machine. The source code of the cookie vending machine module is part of the example collection for gen_pnet.

Cookie vending machine example net. Place and transition names are atoms while, in this example, tokens are also atoms.

To integrate gen_pnet into a rebar3 managed project change the entry in your application's file to include the tuple .

Petri nets are defined by creating a callback module that implements the gen_pnet behavior by providing a number of callback functions.

There are six callbacks that define the Petri net structure and its initial marking:

We have a look at each of them in turn.

The function lets us define the names of all places in the net.

Here, we define the net to have the five places in the cookie vending machine.

The function lets us define the names of all transitions in the net.

Here, we define the net to have the two places and in the cookie vending machine.

The lets us define the preset places of a given transition.

Here, we define the preset of the transition to be just the place while the transition has the places and in its preset.

The function lets us define the initial marking for a given place in the form of a token list.

Here, we initialize the storage place with three tokens. All other places are left empty.

The function is a predicate determining whether a given transition is enabled in a given mode.

Here, we state that the transition is enabled if it can consume a single from the place. Similarly, the transition is enabled if it can consume a token from the place and a token from the place. No other configuration can enable a transition. E.g., managing to get a token on the place will not enable any transition.

The function defines what tokens are produced when a transition fires in a given mode. As arguments it takes the name of the transition, a firing mode in the form of a hash map mapping place names to token lists, and a user info field that was generated by . The function is called only on modes for which returns . The function is expected to return either a tuple or the atom . If is returned, the firing is canceled. I.e., nothing is produced or consumed.

Here, the firing of the transition produces a token on the place and a token on the place. Similarly, the firing of the transition produces a token on the place. We do not need to state the tokens to be consumed because the firing mode already uniquely identifies the tokens to be consumed.

In addition to the structure callback functions there are another six callback functions that determine how the net instance appears as an Erlang actor to the outside world:

The function determines what happens when a hot code reload appears. This callback is identical to the function in the gen_server behavior.

The function performs a synchronous exchange of messages between the caller and the net instance. The first argument is the request message, the second argument is a tuple identifying the caller, and the third argument is a record instance describing the current state of the net. The function can either generate a reply without changing the net marking by returning a tuple or it can generate a reply, consuming or producing tokens by returning a tuple.

Here, we react to two kinds of messages: Inserting a coin in the coin slot and removing a cookie box from the compartment. Thus, we react to an message by replying with , consuming nothing and producing a token on the place. When receiving a message, we check whether the place is empty, replying with an error message if it is, otherwise replying with , consuming one token from the place, and producing nothing. We can inspect the tokens on a given place by using the accessor function. Calls that are neither nor are responded to with an error message.

The function reacts to an asynchronous message received by the net instance. The first argument is the request while the second argument is a record instance. The function can either leave the net unchanged by returning or it can consume or produce tokens by returning a tuple.

Here, we just ignore any cast.

The function reacts to an asynchronous, unformatted message received by the net instance. The first argument is the message term while the second argument is a record instance. The function can either leave the net unchanged by returning or it can consume or produce tokens by returning a tuple.

Here, we just ignore any message.

The function initializes the net instance. It is given a start argument term which is the start argument term that was provided with . As a return value a tuple of the form is expected. We can construct it with the help of . This function takes two arguments: The module implementing the net structure callback functions as well as a user info field.

Here we state that the actor interface module is also the net structure module. We initialize the user info field with the empty list .

The function determines what happens when the net instance is stopped. The first argument is the reason for termination while the second argument is a record instance. This callback is identical to the function in the gen_server behavior.

The function determines what happens when a token is produced on a given place. Its first argument is the place name, its second argument is the token about to be produced, and its third argument is the user info field generated by . The function is expected to return either in which case the token is produced normally, or in which case the token is forgotten.

Here, we simply let any token pass.

In the following we demonstrate how to start and play with the previously defined cookie vending machine example. You can either copy the above code in an Erlang callback module of your own or you can obtain the module from the joergen7/gen_pnet_examples repository. Here, we clone it from GitHub and compile it. Then we start an interactive Erlang shell using rebar3.

Compiling with rebar3 also fetches the gen_pnet library. We start the cookie vending machine which is stored in the callback module by using .

The first argument is the callback module defining the cookie vending machine. It must implement all callback functions in the gen_pnet behavior. The second argument is an option list, identical to the one used in the functions. On success, returns the process id of the just created Petri net process. Now that the Petri net is running we can query the content of its places with . This Petri net has five places: , , , , and . Initially, all places are empty except the place which holds three cookie packages.

To interact with the cookie vending machine we insert a coin by adding an according token to the place. This can be done with the function which takes a reference to a Petri net instance, a place name, and a token which is added to that place.

The effect of calling the net instance with is that a coin is produced on the place. Immediately, transition fires making the coin wander to the place, leaving the place empty again. Immediately afterwards, the transition fires, making a token appear in the formerly empty place while the number of tokens on the has reduced by one. We can check this by querying the places as previously.

Now, we can remove the cookie box from the compartment by calling the net instance with .

Calling with a second time will yield an error, since only one cookie box was bought.|||

gen_pnet - A generic Petri net OTP behavior.