When building web applications with JavaScript, there are thousands of tools and frameworks to choose from. Most of these tools aim to make developing with JavaScript easier and more productive, and most of them help web developersÂ achieve that. However, sometimes the language itself is the constraint.Â If you have built web applicationsÂ in JavaScript, thereâ€™s a good chance youâ€™ve experienced errors like that end up taking lots of time to debug. The language does not help you catch these errors early enough in the development cycle, and they usually end up being discovered too late,Â mostlyÂ by your users reporting that something is not working.

What if you could release your web app with the confidence that you wouldÂ never get any runtime exceptions again? What if every time you needed to refactor code, you could do it confidently knowing you have a compiler that would let you know of any errors and suggestions on how to fix them? What if you could get all these benefits today, right now?

Welcome to the world of Elm.

Elm is a language written specifically for building reliable web-based user interfaces and targeted towards the needs of modern frontend applications. It compiles to JavaScript, which makes it usable in web browsers, and is famous for its promise ofÂ No Runtime Exceptions.Â With Elm, you are guaranteed that once your app compiles, there wonâ€™t be any crashes and you can devote your timeÂ to deal with the things that matter. Letâ€™s dive in and explore this language and what it has to offer.

The best part of using a language with a compiler is you never have to deal with minute details such as typos and using undefined functions. You leave those to the compiler. Think of a compiler like a helpful assistant that helps you with the simple stuff and leaves the importantÂ logic detailsÂ to you. One thingâ€™s for sure; you will make mistakes from time to time, and the compiler is here to make you aware when you make these mistakes and how to fix them.

Letâ€™s see how the compiler can be helpful with a real example. Letâ€™s assume we want to add up all the numbers in a list and while creatingÂ the list, we happen to makeÂ the slightest of mistakes by includingÂ one of the numbers as a string.

If we were doing this in JavaScript, this is how this might look:

This will return , not quite the resultÂ we expectedÂ ðŸ¤”

Now letâ€™s try to do the exact same computation in Elm and see what happens.

The code wonâ€™t even run. Elm expects all items in a list toÂ be of the same type, and it notices that it is being asked to add numbers and strings, which is an ambiguous operation. The Elm compiler realizes our mistake and points outÂ the exact list entry that is causing the mismatchÂ and even adds some helpful hints and a link to the docs to explore things further.

This is exactly what I want in a language. IÂ obviously made a silly mistake, which JavaScript ignores and gives me a result of Â , which isnâ€™t really that helpful. I would prefer to know that I made a mistake and fix it rather than get a result that is obviously wrong.

This is what makes developing apps in Elm such a pleasant experience, since you always know the compiler has got yourÂ back. There are no surprises after youâ€™ve released your app, and no more sleepless nights debugging why the sum of â€‹ ,Â  and is Â ðŸ˜€

Elm has a standardÂ way of organizing your application, and this pattern is calledÂ The Elm Architecture. Youâ€™ll notice this pattern over and over again as youÂ explore Elm apps.Â It enables you to separate your application into three parts:

I find this to be a solid way of structuringÂ web applications. The first part is the model, which holds your app state. Going through the Elm architecture examples really helps in showing how to model different types of data. Iâ€™ve also found union types to be helpful in creating custom types that express your intent more clearly.

The update section is how you change your app state. It receivesÂ an intent to change the state, computesÂ the new state from the old one and returns theÂ updated stateÂ object. Since everything is immutable in Elm, we are always returning aÂ new state objectÂ after each computation, and never modifying the old one. This enables us to get a trail of how our modelÂ changesÂ over time as peopleÂ interact with it.

This concept makes debugging trivial sinceÂ toÂ reproduce a particularÂ state, we can record the sequence of actions that were taken andÂ apply them to the model to get to the state we want.Â This is the concept behind innovationsÂ such as the time traveling debugger, which you can check out in action inÂ this Mario game.

Lastly, thereâ€™s the viewÂ which is aÂ visual representation of theÂ model on the screen. Anytime the model changes, the view is updated automatically, and Elm is blazing fast at this.

The good news is that the JavaScript ecosystem is generally heading towards this direction with ideas such as a single state tree, reducers and pure view functions. In fact Redux is modeled afterÂ the Elm Architecture.

The best way to experience ElmÂ is to try it for yourself. Even if you donâ€™t plan on using it on a daily basis, try it. Start with The Elm Architecture and take it from there. It will have a positive effect on anyÂ code you write in future. If it seemsÂ hard and confusing the first few times,Â give it five minutes.

The Elm community is pretty welcoming and you shouldÂ join the Elm Community SlackÂ and ask any questions that arise.

I canâ€™t wait to see what you build with ElmÂ ðŸ˜Ž|||

When building web applications with JavaScript, there are thousands of tools and frameworks to choose from. Most of these tools aim to make developing with JavaScript easier and more productive, and most of them help web developersÂ achieve that. However, sometimes the language itself is the constraint.Â If you have built web applicationsÂ in JavaScript, there's a goodâ€¦