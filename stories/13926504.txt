“I don’t set trends. I just find out what they are and exploit them.” – Dick Clark, New Year’s Rockin’ Eve software metric guru.

Management loves software metrics. They love to set goals and then measure how their employees are doing against those goals (system stability needs to be 95%, for example). Software metrics don’t have to be a bad thing, but unfortunately, they are often used inappropriately. A single software metric is a snapshot and without context means nothing. While we can all agree that a codebase with a system stability of 5% is significantly worse than a codebase with a system stability of 95%, what about a codebase with 60% system stability versus a codebase with 70% system stability? It is easy to compare one number to another, but it is harder to see if that number is relevant in context of the larger software system.

In terms of “good” and “bad” codebases, a single metric is also not very helpful. You need a combination of software metrics. You could look at System Cyclicality, Intercomponent Cyclicality, System Stability and Coupling, for example, to get a better understanding of your codebase.

Then you have the question about what is the difference between a codebase with 94% system stability and one with 95%. If it requires a large amount of work to go from 94% to 95% just to get to that goal of 95% system stability, is that final 1% really worth it? This is where trends come in. Trends are the true added value to software metrics. How do you prioritize what should be fixed in your code? You can look at the trend or evolution of that software metric over time.

The “magic insight” only comes from looking at a number of relevant software metrics and the trends of those software metrics over time. This is why trends are more important than the actual goal. The trend will show if a team is moving in the right direction and the rate of that change. And trends create actionable insight for an organization. These insights, based on real data, into current performance trigger thinking about deeper underlying forces at work in the development of the software. Anticipating and responding to trends means thinking through all the scenarios that a trend could bring about, and how you need to respond to that trend. The goal should be to ensure trends accelerate, decelerate or reverse based on the project.

Trends also encourage experimentation. What happens if we implement pair-programming or if we switch to GitHub? Over a long project, trends can be motivating. You focus on moving in the right direction instead of the large gap between now and the end of the project. This is why trends are more important than the actual goal.

Learn how Lattix is Tracking Stability of a Software System or check out all of our metrics in our Lattix web demo.|||

Software Metrics don't have to be a bad thing. But you need to look at a number of relevant software metrics and their trends over time to get real insight.