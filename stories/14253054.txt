One of my favorite games to play is Tetris. I particularly like the "Rebtris" clone, written in REBOL by Frank Sievertsen. While playing Rebtris recently, it struck me that writing a Tetris clone of my own would be a helpful exercise for this tutorial. In conceiving how to make it a bit different from all the other endless variations of Tetris, I thought "why not try a text version?". Creating it may be easier than a GUI version, and it would run on machines where GUI versions of REBOL aren't available. Writing a text version of Tetris would also force me to organize a set of display techniques that could be useful in laying out other text-based applications. Sounds like a fun project with some useful side effects. NOTE: I've never considered how to build a Tetris clone, and I'm writing this section as I design, experiment, and write code for the program. So as you read this, you'll follow my exact train of thought in putting the program together, and I'll make no attempt to artificially clean up the process. The point of this tutorial is to demonstrate exactly how to go about creating all types of programs on your own. I hope that following my footsteps exactly - imperfections and all - should be a helpful experience. Let's see what happens... Instead of starting this entire thing from scratch, I remembered briefly skimming a tutorial about how to create a text positioning dialect called "TUI". I found it again at http://www.rebolforces.com/articles/tui-dialect/ and looked for some reusable code... Here's the TUI dialect, created by Ingo Hohmann (I renamed his "cursor2" function to "tui"): tui: func [ {Cursor positioning dialect (iho)} [catch] commands [block!] /local screen-size string arg cnt cmd c err ][ screen-size: ( c: open/binary/no-wait [scheme: 'console] prin "^(1B)[7n" arg: next next to-string copy c close c arg: parse/all arg ";R" forall arg [change arg to-integer first arg] arg: to-pair head arg ) string: copy "" cmd: func [s][join "^(1B)[" s] if error? set/any 'err try [ commands: compose bind commands 'screen-size ][ throw err ] arg: parse commands [ any [ 'direct set arg string! (append string arg) | 'home (append string cmd "H") | 'kill (append string cmd "K") | 'clear (append string cmd "J") | 'up set arg integer! (append string cmd [ arg "A"]) | 'down set arg integer! (append string cmd [ arg "B"]) | 'right set arg integer! (append string cmd [ arg "C"]) | 'left set arg integer! (append string cmd [ arg "D"]) | 'at set arg pair! (append string cmd [ arg/x ";" arg/y "H" ]) | 'del set arg integer! (append string cmd [ arg "P"]) | 'space set arg integer! (append string cmd [ arg "@"]) | 'move set arg pair! (append string cmd [ arg/x ";" arg/y "H" ]) | set cnt integer! set arg string! ( append string head insert/dup copy "" arg cnt ) | set arg string! (append string arg) ] end ] if not arg [throw make error! "Unable to parse block"] string ] I read the tutorial and played with the code a bit. In addition to being a great tutorial, the end product is a useful tool for formatting output in console applications. The function "tui" gets passed a block of parameters including text to be printed, directional keywords to move the cursor around the screen ("home", "up", "down", "left", "right", and "at" a specific location) and several other commands to get the screen size, clear the screen, delete text, repeat text, and insert spaces. I tried a few commands to get familiar with the syntax: prin tui [ clear ] print tui [ 50 "-" ] print tui [ right 10 down 7 50 "x" ] prin tui [ clear right 10 down 10 50 "x" ] print tui [ clear home "message1"] print tui [ home space 20 "message2"] print tui [ at 20x20 "message3" kill "message4"] print tui [ at 20x20 del 10] print tui [ move 10x10] prin tui [ clear (screen-size/y * screen-size/x - 4) "x" ] I had more fun playing with the TUI dialect than I did playing Tetris :) Basically, TUI wraps up some of the native print control codes built into REBOL, in a nice clean format that eliminates all the odd characters used in native codes. It contains everything required to move game pieces around the screen, so I'll start to come up with some requirements to build the game. Here's an outline that covers the main design goals I'm conceiving at this point: Draw a static playing field (the unchanging graphic backdrop design that's on screen the whole time the game is being played). This will represent the left, right, and lower vertical bounds which the game coordinates may not exceed. There are 7 block shapes used in the game. Create text versions of each graphic shape, in each of the 4 possible rotated positions. Come up with code to print and delete each of the graphic shapes. The TUI dialect will let me print and delete characters anywhere on the screen. I'll use directional statements to print the required characters, starting from any given coordinate. Put all these shape routines into a block for easy naming and reuse. Write a continuous loop to put one shape on the screen, make it fall at a given speed, and allow the user to spin it around and move it left-right. If a shape touches the bottom of the playing field, make it lock into the grid of other shapes that have already fallen. If the bottom row is complete, remove it, and make all the rows above it fall down a row to take its place. If the shape touches the ceiling, end the game. The first part of the outline is easy. I'll use the "print a-line" code created in the "loops and conditions - a simple data storage app" example earlier in this tutorial. Here's a simple little backdrop that's printed to the screen: For the second part, I need to create some code to print the 7 block shapes. They look like this: Here are all the possible variations when the above shapes are rotated clockwise: To print any piece, I can start at the top left coordinate in the shape and move the appropriate number of spaces right, left, and/or down to print the other characters in each piece. Starting at the first character in shape 2, for example, I would move as follows: "#", down 1 left 1, "#", down 1 left 1, "#", down 1 left 1, "#". Shape 3 would move as follows: "###", down 1 left 2, "#". Here's a block called "shape", made up of individual blocks that can be passed to tui to print all the above shapes: shape: [ ["####"] ["#" down 1 left 1 "#" down 1 left 1 "#" down 1 left 1 "#"] ["###" down 1 left 2 "#"] [right 1 "#" down 1 left 2 "##" down 1 left 1 "#"] [right 1 "#" down 1 left 2 "###"] ["#" down 1 left 1 "##" down 1 left 2 "#"] ["###" down 1 left 3 "#"] ["##" down 1 left 1 "#" down 1 left 1 "#"] [right 2 "#" down 1 left 3 "###"] ["#" down 1 left 1 "#" down 1 left 1 "##"] ["###" down 1 left 1 "#"] [right 1 "#" down 1 left 1 "#" down 1 left 2 "##"] ["#" down 1 left 1 "###"] ["##" down 1 left 2 "#" down 1 left 1 "#"] ["##" down 1 left 1 "##"] [right 1 "#" down 1 left 2 "##" down 1 left 2 "#"] [right 1 "##" down 1 left 3 "##"] ["#" down 1 left 1 "##" down 1 left 1 "#"] ["##" down 1 left 2 "##"] ] Now I can use the format "prin tui shape/number" to print any shape. For example: prin tui [right 1 "#" down 1 left 2 "##" down 1 left 1 "#"] I came up with the following code to print out each shape, to check for errors, and to get used to using the above format. Notice the use of the "compose" function: for i 1 19 1 [ print tui [clear] print rejoin ["shape " i ":"] do compose [print tui shape/(i)] ask "" ] To erase the shapes, I decided to extend the block using duplicates of each shape to print spaces instead of "#"s. Now all I have to do is add 19 to any shape's index number, and I can print out a shape made of spaces that erases the original shape made of "#"s. Here's the final shape block: shape: [ ["####"] ["#" down 1 left 1 "#" down 1 left 1 "#" down 1 left 1 "#"] ["###" down 1 left 2 "#"] [right 1 "#" down 1 left 2 "##" down 1 left 1 "#"] [right 1 "#" down 1 left 2 "###"] ["#" down 1 left 1 "##" down 1 left 2 "#"] ["###" down 1 left 3 "#"] ["##" down 1 left 1 "#" down 1 left 1 "#"] [right 2 "#" down 1 left 3 "###"] ["#" down 1 left 1 "#" down 1 left 1 "##"] ["###" down 1 left 1 "#"] [right 1 "#" down 1 left 1 "#" down 1 left 2 "##"] ["#" down 1 left 1 "###"] ["##" down 1 left 2 "#" down 1 left 1 "#"] ["##" down 1 left 1 "##"] [right 1 "#" down 1 left 2 "##" down 1 left 2 "#"] [right 1 "##" down 1 left 3 "##"] ["#" down 1 left 1 "##" down 1 left 1 "#"] ["##" down 1 left 2 "##"] ; Here are the same shapes, with spaces instead of "#"s: [" "] [" " down 1 left 1 " " down 1 left 1 " " down 1 left 1 " "] [" " down 1 left 2 " "] [right 1 " " down 1 left 2 " " down 1 left 1 " "] [right 1 " " down 1 left 2 " "] [" " down 1 left 1 " " down 1 left 2 " "] [" " down 1 left 3 " "] [" " down 1 left 1 " " down 1 left 1 " "] [right 2 " " down 1 left 3 " "] [" " down 1 left 1 " " down 1 left 1 " "] [" " down 1 left 1 " "] [right 1 " " down 1 left 1 " " down 1 left 2 " "] [" " down 1 left 1 " "] [" " down 1 left 2 " " down 1 left 1 " "] [" " down 1 left 1 " "] [right 1 " " down 1 left 2 " " down 1 left 2 " "] [right 1 " " down 1 left 3 " "] [" " down 1 left 1 " " down 1 left 1 " "] [" " down 1 left 2 " "] ] I wrote another quick script to test it. Notice the "i + 19" used to erase the exiting shape: for i 1 19 1 [ print tui [clear] print rejoin ["shape " i ":"] do compose [prin tui [move 10x10] print tui shape/(i)] ask "" do compose [prin tui [move 10x10] print tui shape/(i + 19)] print rejoin ["shape " i " has been erased."] ask "" ] Beautiful. Steps 1 and 2 are complete. Now I can work on the last part of the outline (the things related to how the game actually plays, moving pieces and responding to user input). First, I'll get the shapes to fall down the screen. That'll be done by printing, erasing and then redrawing the piece one row lower, in a continuous loop. Here's an outline to organize that thought process: Pieces appear in a random order, so come up with a random number to represent some random shape's index number. Use a for loop to increment the vertical position of the piece: for each row, print the random piece number at the current horizontal position (initially set to 15), and at the vertical position represented by the current "for" variable. Wait a moment, then erase the piece (using the shape number + 19). Then increment the row number and start again. When the piece reaches the last row, print it there without erasing. Wrap that whole thing in a forever loop to keep it going indefinitely. Let's get that much going: prin tui [clear] forever [ random/seed now r: random 19 ; the number of a random shape xpos: 18 ; the initial horizontal position for i 1 25 1 [ pos: to-pair rejoin [i "x" xpos] ; print the shape represented by "r" at the "pos" ; coordinate: do compose/deep [prin tui [at (pos)] print tui shape/(r)] ; The wait time could be a user controlled variable, or ; it could be sped up as the difficulty level increases: wait :00:00.30 ; erase the shape, then continue the loop: do compose/deep [ prin tui [at (pos)] print tui shape/(r + 19)] ] ; reprint the shape at its final resting place: do compose/deep [prin tui [move (pos)] print tui shape/(r)] ] NOTE: It struck me in writing the above code that the TUI function actually takes all its coordinates in an unusual order. Typically, in coordinates with the form XxY, "X" is the horizontal position and "Y" is the vertical position. TUI uses the format YxX, where Y is the vertical position measured in rows from the top of the screen. X is the horizontal position, measured in columns from the left side of the screen. Keep in mind that the order of X and Y coordinates is opposite the normal expectation. Now I need to come up with a way for the user to control the horizontal position of the shape. Here's some pseudo code to help me think about how to do that: Be on the lookout for keystroke input from the user. If the user presses the "l" key, add 1 to the current horizontal position of the shape (held in the variable "xpos"). If the user presses the "k" key, subtract 1 from xpos. First, I need a way to get keystroke input without blocking the program flow (i.e., I need to wait for keystroke input to be acknowledged when it occurs, but I can't just stop the normal program flow to wait for key presses. For game play to continue, the "for" and "forever" loops can't be interrupted. So I searched Google for "REBOL key stroke" and got pointed to the following code at http://www.rebol.org/cgi-bin/cgiwrap/rebol/ml-display-thread.r?m=rmlSCRQ (in the REBOL mailing list archive): c: open/binary/no-wait [scheme: 'console] ; set following to whatever you wish ; intentionally slow at 2 secs so you can "see" the effect wait-duration: :0:2 d: 0 forever [ if not none? wait/all [c wait-duration] [ print to-char to-integer copy c ] d: d + 1 ;let's do other stuff print d ] That little bit of code does exactly what I need. The parts required for my needs are: c: open/binary/no-wait [scheme: 'console] forever [ if not none? wait/all [c wait-duration] [ print to-char to-integer copy c ] ] I adjusted the variable names, checked for "k" or "l" key presses, and used the code below to test that it worked the way I wanted: keys: open/binary/no-wait [scheme: 'console] forever [ if not none? wait/all [keys :00:00.01] [ switch to-string to-char to-integer copy keys [ "k" [print "you pressed k"] "l" [print "you pressed l"] ] ] ; print "nothing pressed" ; make sure it's working ] Next, I integrated the above code into the loop created earlier to drop the shape down the screen. Notice that I added a conditional "if", to be executed when either "k" or "l" keystrokes are encountered. It checks that the horizontal bounds don't go outside the 5-30 positions. That keeps the shapes within the horizontal boundaries of the playing field. Also, notice that the variable "old-xpos" is used to hold the position of the shape that needs to be erased: keys: open/binary/no-wait [scheme: 'console] forever [ random/seed now r: random 19 xpos: 18 for i 1 25 1 [ pos: to-pair rejoin [i "x" xpos] do compose/deep [prin tui [at (pos)] print tui shape/(r)] old-xpos: xpos if not none? wait/all [keys :00:00.30] [ switch to-string to-char to-integer copy keys [ "k" [if (xpos > 5) [xpos: xpos - 1]] "l" [if (xpos < 30) [xpos: xpos + 1]] ] ] pos: to-pair rejoin [i "x" old-xpos] do compose/deep [ prin tui [at (pos)] print tui shape/(r + 19)] ] do compose/deep [prin tui [move (pos)] print tui shape/(r)] ] It's coming along well :) Now I need to be able to spin the shapes around. Here's some pseudo code to organize my thoughts: Watch for the "O" key to be pressed. That will be the keycode to run the shape spinning code. Create a set of conditionals to cycle through the list of rotated shapes related to the current shape. For example, if the current shape (variable "r") is number 12, then the rotated versions of that shape are numbers 11-14. With each press of the "O" key, replace the variable r with the next shape in that list. That logic must "wrap around" (i.e., the next shape after 14 should be 11). Instead of using a block list of shapes to do this, I decide to use a switch structure to individually map each shape to the one it should rotate to (something like "if shape r is now #14, turn shape r into #11" - do that explicitly for each shape). I already have some code to watch for keystrokes, so I'll try the last part of the above outline first: Wait a sec - that makes the shapes rotate clockwise (from #11 go to #12, #14 to #11, etc.) I prefer for them to rotate counterclockwise (#11 to #14, #14 to #13, etc). Here's the revised code: Now add the letter "O" to the list of keys to be watched, and run the above code when it's pressed. Also create an "old-r" variable to retain the number of the shape that needs to be erased. (Since the user changes shapes after the current one has been printed, we need to keep track of which one to erase): keys: open/binary/no-wait [scheme: 'console] forever [ random/seed now r: random 19 xpos: 18 for i 1 25 1 [ pos: to-pair rejoin [i "x" xpos] do compose/deep [prin tui [at (pos)] print tui shape/(r)] old-xpos: xpos old-r: r if not none? wait/all [keys :00:00.30] [ keystroke: to-string to-char to-integer copy keys switch keystroke [ "k" [if (xpos > 5) [xpos: xpos - 1]] "l" [if (xpos < 30) [xpos: xpos + 1]] "o" [switch to-string r [ "1" [r: 2] "2" [r: 1] "3" [r: 6] "4" [r: 3] "5" [r: 4] "6" [r: 5] "7" [r: 10] "8" [r: 7] "9" [r: 8] "10" [r: 9] "11" [r: 14] "12" [r: 11] "13" [r: 12] "14" [r: 13] "15" [r: 16] "16" [r: 15] "17" [r: 18] "18" [r: 17] "19" [r: 19] ]] ] ] do compose/deep [ prin tui [at (pos)] print tui shape/(old-r + 19) ] ] do compose/deep [prin tui [at (pos)] print tui shape/(r)] ] The shapes are moving correctly now, but there's still a lot of work to be done. The first line of the last section of the overall game outline reads: "If the shape touches the bottom of the playing field, make it lock into the grid of other shapes that have already fallen". Right now the pieces all just fall to different stopping points in the playing field (depending on their height), and they don't stack on top of each other. Here's some pseudo code to fix that: I need to be aware of the highest coordinate in each column on the playing field. When the game starts, the highest coordinate in every column of the playing field is row 30 (the flat bottom line that makes up the playing field). I'll store each of these coordinates in a block called "floor". I also need to be aware of the lowest coordinate in each column of the currently falling shape. I'll make a block called "edge" to hold those coordinates (referring to the lower edges of the shape). Those coordinates will define the position of each of the lowest points in the currently falling shape, in relation to its top left point (the "pos" coordinate). Every time the shape falls one position down the screen, add each of the edge coordinates to the pos coordinate. If any of those coordinates is one position higher than the floor coordinate in the same column, then stop moving that shape (break out of the "for" loop that makes the shape fall). Use a foreach loop to cycle through the current coordinates in the relevant columns of each block, performing a comparison check on the floor and edge coordinates in each column. When a shape finishes its drop down the screen, calculate the new highest position in the columns it occupies (the coordinates of the top character in each column), and make those changes to the block that holds the high point information. To do that, I'll need to make a "top" block to hold the relative positions of the highest coordinates in the shape, and add them to the height of the current coordinates in the appropriate columns. I'll start out simply, just getting each shape to lay flat on the floor of the playing field (row 30). For the moment, all I need to do is create a block of floor coordinates that represents that bottom line: Next, I'll define a set of lower coordinates for each shape, and store them in a nested block structure similar to the earlier "shape" block. "0x0" refers to the same coordinate as "pos" (0 positions to the right, and 0 positions down from "pos"). "0x10" is one position to the right, and "1x0" is one position down. I look at the visual representations of the shapes again to come up with the list: Here's the complete set of low point definitions for each shape: So, the relative coordinates of the low points in shape 3, for example, are referred to as edge/3. Here's some sample code to demonstrate how I can now refer to the bottom points in any shape using a foreach loop. The code "pos + position" refers to the low edge in each column: To check if any of those edges are touching the floor, use a foreach loop to cycle through the current coordinates in the relevant columns of each block, performing a comparison check on the floor and edge coordinates in each column. Here's some sample code to flesh out and test that idea: pos: 30x10 for r 1 19 1 [ print tui [clear] prin "Piece: " print r foreach po compose edge/(r) [ print pos + po foreach coord floor [ floor-y: to-integer first coord floor-x: to-integer second coord edge-y: to-integer first pos + to-integer first po edge-x: to-integer second pos + to-integer second po print rejoin [ "edge: " edge-y "x" edge-x " " "floor: "floor-y "x" floor-x ] if (edge-y >= floor-y) and (floor-x = edge-x) [ print rejoin [ "You're touching or beyond the floor at: " pos + po ] ] ] ] ask "" ] Now let's integrate this technique into the existing code. We'll use a new variable "stop" to break out of the loop that drops the shape, when the current shape touches the floor: keys: open/binary/no-wait [scheme: 'console] forever [ random/seed now r: random 19 xpos: 18 for i 1 32 1 [ pos: to-pair rejoin [i "x" xpos] do compose/deep [prin tui [at (pos)] print tui shape/(r)] old-r: r old-xpos: xpos if not none? wait/all [keys :00:00.30] [ keystroke: to-string to-char to-integer copy keys switch keystroke [ "k" [if (xpos > 5) [xpos: xpos - 1]] "l" [if (xpos < 30) [xpos: xpos + 1]] "o" [switch to-string r [ "1" [r: 2] "2" [r: 1] "3" [r: 6] "4" [r: 3] "5" [r: 4] "6" [r: 5] "7" [r: 10] "8" [r: 7] "9" [r: 8] "10" [r: 9] "11" [r: 14] "12" [r: 11] "13" [r: 12] "14" [r: 13] "15" [r: 16] "16" [r: 15] "17" [r: 18] "18" [r: 17] "19" [r: 19] ]] ] ] do compose/deep [ prin tui [at (pos)] print tui shape/(old-r + 19) ] stop: false foreach po compose edge/(r) [ foreach coord floor [ floor-y: to-integer first coord floor-x: to-integer second coord edge-y: i + to-integer first po edge-x: xpos + to-integer second po if (edge-y >= floor-y) and (floor-x = edge-x) [ stop: true break ] ] ] if stop = true [break] ] do compose/deep [prin tui [at (pos)] print tui shape/(old-r)] ] This works, but there's a bug. If the piece has been spun around (using the "O" key), the new foreach loop fails to stop the piece from falling. That's because the foreach loop only cycles through the coordinates of the "edge/r" block. If the user flips the shape around, the "r" value gets changed before this code is run. The easiest way to fix this problem is to simply repeat the foreach loop using the "edge/old-r" block. This is an inefficient quick hack, but I'm writing this late at night - and there's some value to pointing out bad coding practice - so I choose to use that solution. I make a promise to myself to come up with a more elegant solution later... (Note to self: once a coding solution has been implemented, changes are harder to make, and bad code typically remains permanent ... I need to be careful about using quick hacks). Here's the current code: keys: open/binary/no-wait [scheme: 'console] forever [ random/seed now r: random 19 xpos: 18 for i 1 32 1 [ pos: to-pair rejoin [i "x" xpos] do compose/deep [prin tui [at (pos)] print tui shape/(r)] old-r: r old-xpos: xpos if not none? wait/all [keys :00:00.30] [ keystroke: to-string to-char to-integer copy keys switch keystroke [ "k" [if (xpos > 5) [xpos: xpos - 1]] "l" [if (xpos < 30) [xpos: xpos + 1]] "o" [switch to-string r [ "1" [r: 2] "2" [r: 1] "3" [r: 6] "4" [r: 3] "5" [r: 4] "6" [r: 5] "7" [r: 10] "8" [r: 7] "9" [r: 8] "10" [r: 9] "11" [r: 14] "12" [r: 11] "13" [r: 12] "14" [r: 13] "15" [r: 16] "16" [r: 15] "17" [r: 18] "18" [r: 17] "19" [r: 19] ]] ] ] do compose/deep [ prin tui [at (pos)] print tui shape/(old-r + 19) ] stop: false foreach po compose edge/(r) [ foreach coord floor [ floor-y: to-integer first coord floor-x: to-integer second coord edge-y: i + to-integer first po edge-x: xpos + to-integer second po if (edge-y = floor-y) and (floor-x = edge-x) [ stop: true break ] ] ] foreach po compose edge/(old-r) [ foreach coord floor [ floor-y: to-integer first coord floor-x: to-integer second coord edge-y: i + to-integer first po edge-x: old-xpos + to-integer second po if (edge-y = floor-y) and (floor-x = edge-x) [ stop: true break ] ] ] if stop = true [break] ] do compose/deep [prin tui [at (pos)] print tui shape/(old-r)] ] Next, I decide to test the existing program for other bugs. I've been keeping separate text files containing all the code changes I make as I go along. Every time I make, test, and change a chunk of code, I save the new trial version with a new filename and version number. I save each version, just so that I don't permanently erase old code with each change - it may be potentially useful. My current working version is now #19. I noticed during this debugging session that shape 1 still breaks through the right side of the wall. I could change that by adjusting the "(xpos < 30)" conditional expression that occurs when the "L" key gets pressed. But that solution will keep the other shapes from laying snugly against the wall. In fact, that additional problem is occurring now with shapes that are only 2 characters wide - I didn't notice until now. To deal with these problems, I create a block of values called "width", listing the widths of all 19 shapes, which can be used in the existing conditional expression: Now I can check if the shape is at the right boundary, using the revised code below: That check also needs to be performed every time the "O" key is pressed (we don't want the shape breaking out of the wall when it spins). I make the above changes to my current version of the program, and the problems are fixed. The game is really starting to take shape! Now we need to make the shapes stack on top of each other. Earlier, I wrote these outline thoughts: "when a shape finishes its drop down the screen, calculate the new highest position in the columns it occupies (the coordinates of the top character in each column), and make those changes to the block that holds the high point information. To do that, I'll need to make a "top" block to hold the relative positions of the highest coordinates in the shape, and add them to the height of the current coordinates in the appropriate columns". Sounds like I'll need to loop through some columns to make the changes to the floor. To create the "top" block I look at the visual representations of each shape once again, and come up with a coordinate list representing the high points in the shape, relative to the top left coordinate. It's similar to the "edge" block: The shape finishes its drop down the screen during the previous foreach loops we created, so to calculate the new highest positions in the columns occupied by the shape, I first need to determine which shape was the last one on the screen ("r" or "old-r"). The quick hack I made earlier is now coming back to bite me a bit - I now need to make duplicates of any changes that occur in both foreach loops: stop-shape-num: r ; (or stop-shape-num: old-r, depending on the foreach loop) stop: true break Now to make the changes to the "floor" block, I loop through the columns occupied by the piece, setting each of the top characters in the shape to be the high coordinates in the respective columns of the floor. The "poke" function lets me replace the original coordinates in the floor block with the new coordinates. Those changes are made just before breaking out of the loop that drops the shape: if stop = true [ ; get the left-most column the last shape occupies: left-col: second pos ; get the number of columns the shape occupies: width-of-shape: length? compose top/(stop-shape-num) ; get the right most column the shape occupies: right-col: left-col + width-of-shape - 1 ; Loop through each column occupied by the shape, ; replacing each coordinate in the current column ; of the floor with the new high coordinate: counter: 1 for current-column left-col right-col 1 [ add-coord: compose top/(stop-shape-num)/(counter) new-floor-coord: (pos + add-coord + -1x0) poke floor current-column new-floor-coord counter: counter + 1 ] break ] The new stacking code works, but there's a design flaw. If I maneuver a shape into an unoccupied space directly underneath any high point in the floor, without first touching the high point in that column, the piece doesn't stop. Furthermore, if that happens, it changes the new high point to the bottom of the column which the current shape occupies. I realize here that what I need to mark are not only the high points in the floor, but also every additional coordinate on the screen that contains a character. This is just as easy to accomplish. Instead of changing the current coordinates in the floor block (using the "poke" function): just add the new coordinates to the list (using "append"). That will keep track of all points at which a character is printed on the screen: That fixes the problem above, but I've also realized that if I move a shape sideways into an open position in the floor, the characters sometimes still overlap inappropriately. That's because the "top" and "edge" blocks only mark the highest and lowest points in each shape. It strikes me now that I could just combine those two blocks into one, marking all the coordinates occupied by a shape. Here's the new block - I call it "oc", short for "occupied": I remove the "top" and "edge" blocks, and replace all code references to them with "oc". Now there's another bug I need to fix. Sometimes when I press a key, the following error occurs: ** Script Error: Invalid argument: [45 ** Where: to-integer | ** Near: forall arg [change arg to-integer first arg] arg: to-pair The code referenced is not part of any code I've written. It seems to be related to keystroke input because it only happens when I press one of the game control keys. Since I'm not sure what's creating the error (maybe it's related to the timing of keystrokes, or perhaps it has to do with a key release), I make an educated guess and figure that the following line, which waits for keystrokes, is where it's occurring: if not none? wait/all [keys :00:00.30] [...] I wrap that whole thing in an error check: if not error? try [if not none? wait/all [keys :00:00.30] [...]] And, hmmm ... that doesn't work. So instead of guessing, I work methodically to check each of the other main sections of the program. Every section gets wrapped in an "error? try" routine, and I also put in an "if" conditional stucture to print out a numbered error message whenever an error occurs. I find that the error is first occurring here: Wrapped in the error test, that section looks like this: if error? try [ do compose/deep [ prin tui [at (pos)] print tui shape/(r) ] ] [print "er1"] I'm curious about what's causing the error, so I dig a little deeper. This time I have the error check print out the variables contained in the code: if error? try [ do compose/deep [ prin tui [at (pos)] print tui shape/(r) ] ] [print rejoin [pos " " r]] Nothing seems to be amiss. Every time the error occurs, the variables show a correct coordinate and shape number. So, for now I'll simply leave the error check in place, removing the printout. This will keep the game moving along whenever the ghostly error occurs. I'll need to post a message to the REBOL mailing list to see if anyone knows why the error is occurring. For the time being, the following error handler fixes the issue: if error? try [ do compose/deep [ prin tui [at (pos)] print tui shape/(r) ] ] [] It turns out that I need to do the same thing for all the other similar occurences of code that print a shape to the screen: if error? try [ do compose/deep [ prin tui [at (pos)] print tui shape/(old-r + 19) ] ] [] if error? try [ do compose/deep [ prin tui [at (pos)] print tui shape/(old-r) ] ] [] With all the known bugs controlled, I can move on to implementing the last parts of the game design. We need to check if the top row of the playing area is reached. If any shape stops moving at this ceiling row, end the game. This needs to be done any time a piece reaches it's final resting place, so I put it immediately after the main "for" loop in the program outline (so that it's evaluated immediately after the stopping code is executed): if (first pos) < 2 [ prin tui [at 35x0] print "Game Over" halt ] Finally, to erase the bottom line of shapes every time a row is filled in horizontally, we're going to have to redraw the playing field entirely. The "floor" block contains all the information needed to rebuild the current state of the playing field (all the positions at which a character is currently printed). Here's an outline and some pseudo code to think through what needs to be done: Every time a shape stops moving, check to see if any row of the floor is full (i.e., there's one character printed in every column). I can use a for loop and a find function to perform that check on the floor block. (I'll start things off by just checking the bottom row). If any row is full (for now, just the bottom row), remove that row of characters from the floor block. Use a remove-each loop to remove any coordinates that have y positions in the relevant row from the floor block. Move all of the other characters above the relevant row down one row. Add one y position to all the other coordinates in the floor block which are above the relevant row. Use a foreach loop to go through each coordinate in the block and add 1x0. To replace the old floor block with the new one, first create a temporary block made up of the new floor block coordinates, then copy it back to the floor block once it's complete. Erase the current screen, print the static background, and then reprint a new playing field using the refreshed block of floor coordinates. We can accomplish this easily using a foreach loop and TUI to print the characters at each coordinate in the list. ; #1: line-is-full: true for colmn 5 32 1 [ each-coord: to-pair rejoin [29 "x" colmn] if not find floor each-coord [ line-is-full: false break ] ] ; #2: if line-is-full = true [ remove-each cor floor [(first cor) = 29] ; #3: new-floor: copy [] foreach cords floor [ append new-floor (cords + 1x0) ] floor: copy new-floor ; #4: prin tui [clear] a-line: copy [] loop 28 [append a-line " "] a-line: rejoin [" |" to-string a-line "|"] loop 30 [print a-line] prin " " loop 30 [prin "+"] print "" foreach was-here floor [ if not ((first was-here) = 30) [ prin tui compose [at (was-here)] prin "#" ] ] ] At this point, I realize that I've made some logic errors in how the floor block and the stopping routine are structured. As it stands, when the screen is refreshed, the bottom row of the block (row 30) needs to be erased so that all the characters in row 29 can fall down one position. But if row 30 is erased, then the bottom of the floor disappears. As it turns out, row 31 should actually be treated as the bottom row, and all the characters should stop at 1x0 position higher then any character in the floor. I make the required changes to the coordinates in the floor block (change all the y positions from 30 to 31). I also change the "new-floor-coord" variable in the stopping routine, and adjust the code above so that characters below line 30 are not printed. Additionally, the entire section above gets wrapped in a "for" loop to check if each row 1-30 is full. In the code above, I only checked if the bottom line was full - the number 29 referred to the row. I replace that number with the "row" variable created in the for loop. And with that, the last requirements of my original game outline are satisfied and an initial version of "Textris" is in working order. Here's the code: REBOL [Title: "Textris"] tui: func [ {Cursor positioning dialect (iho)} [catch] commands [block!] /local screen-size string arg cnt cmd c err ][ screen-size: ( c: open/binary/no-wait [scheme: 'console] prin "^(1B)[7n" arg: next next to-string copy c close c arg: parse/all arg ";R" forall arg [change arg to-integer first arg] arg: to-pair head arg ) string: copy "" cmd: func [s][join "^(1B)[" s] if error? set/any 'err try [ commands: compose bind commands 'screen-size ][ throw err ] arg: parse commands [ any [ 'direct set arg string! (append string arg) | 'home (append string cmd "H") | 'kill (append string cmd "K") | 'clear (append string cmd "J") | 'up set arg integer! (append string cmd [ arg "A"]) | 'down set arg integer! (append string cmd [ arg "B"]) | 'right set arg integer! (append string cmd [ arg "C"]) | 'left set arg integer! (append string cmd [ arg "D"]) | 'at set arg pair! (append string cmd [ arg/x ";" arg/y "H" ]) | 'del set arg integer! (append string cmd [ arg "P"]) | 'space set arg integer! (append string cmd [ arg "@"]) | 'move set arg pair! (append string cmd [ arg/x ";" arg/y "H" ]) | set cnt integer! set arg string! ( append string head insert/dup copy "" arg cnt ) | set arg string! (append string arg) ] end ] if not arg [throw make error! "Unable to parse block"] string ] shape: [ ["####"] ["#" down 1 left 1 "#" down 1 left 1 "#" down 1 left 1 "#"] ["###" down 1 left 2 "#"] [right 1 "#" down 1 left 2 "##" down 1 left 1 "#"] [right 1 "#" down 1 left 2 "###"] ["#" down 1 left 1 "##" down 1 left 2 "#"] ["###" down 1 left 3 "#"] ["##" down 1 left 1 "#" down 1 left 1 "#"] [right 2 "#" down 1 left 3 "###"] ["#" down 1 left 1 "#" down 1 left 1 "##"] ["###" down 1 left 1 "#"] [right 1 "#" down 1 left 1 "#" down 1 left 2 "##"] ["#" down 1 left 1 "###"] ["##" down 1 left 2 "#" down 1 left 1 "#"] ["##" down 1 left 1 "##"] [right 1 "#" down 1 left 2 "##" down 1 left 2 "#"] [right 1 "##" down 1 left 3 "##"] ["#" down 1 left 1 "##" down 1 left 1 "#"] ["##" down 1 left 2 "##"] ; [" "] [" " down 1 left 1 " " down 1 left 1 " " down 1 left 1 " "] [" " down 1 left 2 " "] [right 1 " " down 1 left 2 " " down 1 left 1 " "] [right 1 " " down 1 left 2 " "] [" " down 1 left 1 " " down 1 left 2 " "] [" " down 1 left 3 " "] [" " down 1 left 1 " " down 1 left 1 " "] [right 2 " " down 1 left 3 " "] [" " down 1 left 1 " " down 1 left 1 " "] [" " down 1 left 1 " "] [right 1 " " down 1 left 1 " " down 1 left 2 " "] [" " down 1 left 1 " "] [" " down 1 left 2 " " down 1 left 1 " "] [" " down 1 left 1 " "] [right 1 " " down 1 left 2 " " down 1 left 2 " "] [right 1 " " down 1 left 3 " "] [" " down 1 left 1 " " down 1 left 1 " "] [" " down 1 left 2 " "] ] floor: [ 31x5 31x6 31x7 31x8 31x9 31x10 31x11 31x12 31x13 31x14 31x15 31x16 31x17 31x18 31x19 31x20 31x21 31x22 31x23 31x24 31x25 31x26 31x27 31x28 31x29 31x30 31x31 31x32 ] oc: [ [0x0 0x1 0x2 0x3] [0x0 1x0 2x0 3x0] [0x0 0x1 0x2 1x1] [0x1 1x0 1x1 2x1] [0x1 1x0 1x1 1x2] [0x0 1x0 1x1 2x0] [0x0 0x1 0x2 1x0] [0x0 0x1 1x1 2x1] [0x2 1x0 1x1 1x2] [0x0 1x0 2x0 2x1] [0x0 0x1 0x2 1x2] [0x1 1x1 2x0 2x1] [0x0 1x0 1x1 1x2] [0x0 0x1 1x0 2x0] [0x0 0x1 1x1 1x2] [0x1 1x0 1x1 2x0] [0x1 0x2 1x0 1x1] [0x0 1x0 1x1 2x1] [0x0 0x1 1x0 1x1] ] width: [4 1 3 2 3 2 3 2 3 2 3 2 3 2 3 2 3 2 2] a-line: copy [] loop 28 [append a-line " "] a-line: rejoin [" |" to-string a-line "|"] loop 30 [print a-line] prin " " loop 30 [prin "+"] print "" keys: open/binary/no-wait [scheme: 'console] forever [ random/seed now r: random 19 xpos: 18 for i 1 30 1 [ pos: to-pair rejoin [i "x" xpos] if error? try [ do compose/deep [ prin tui [at (pos)] print tui shape/(r) ] ] [] old-r: r old-xpos: xpos if not none? wait/all [keys :00:00.30] [ keystroke: to-string to-char to-integer copy keys switch/default keystroke [ "k" [if (xpos > 5) [ xpos: xpos - 1 ]] "l" [if (xpos < (33 - compose width/(r))) [ xpos: xpos + 1 ]] "o" [if (xpos < (33 - compose width/(r))) [ switch to-string r [ "1" [r: 2] "2" [r: 1] "3" [r: 6] "4" [r: 3] "5" [r: 4] "6" [r: 5] "7" [r: 10] "8" [r: 7] "9" [r: 8] "10" [r: 9] "11" [r: 14] "12" [r: 11] "13" [r: 12] "14" [r: 13] "15" [r: 16] "16" [r: 15] "17" [r: 18] "18" [r: 17] "19" [r: 19] ] ] ] ] [] ] if error? try [ do compose/deep [ prin tui [at (pos)] print tui shape/(old-r + 19) ] ] [] stop: false foreach po compose oc/(r) [ foreach coord floor [ floor-y: to-integer first coord floor-x: to-integer second coord oc-y: i + to-integer first po oc-x: xpos + to-integer second po if (oc-y = (floor-y - 1)) and (floor-x = oc-x) [ stop-shape-num: r stop: true break ] ] ] foreach po compose oc/(old-r) [ foreach coord floor [ floor-y: to-integer first coord floor-x: to-integer second coord oc-y: i + to-integer first po oc-x: old-xpos + to-integer second po if (oc-y = (floor-y - 1)) and (floor-x = oc-x) [ stop-shape-num: old-r stop: true break ] ] ] if stop = true [ left-col: second pos width-of-shape: length? compose oc/(stop-shape-num) right-col: left-col + width-of-shape - 1 counter: 1 for current-column left-col right-col 1 [ add-coord: compose oc/(stop-shape-num)/(counter) new-floor-coord: (pos + add-coord) append floor new-floor-coord counter: counter + 1 ] break ] ] if (first pos) < 2 [ prin tui [at 33x0] print "GAME OVER!!!" halt ] if error? try [ do compose/deep [ prin tui [at (pos)] print tui shape/(old-r) ] ] [] for row 1 30 1 [ line-is-full: true for colmn 5 32 1 [ each-coord: to-pair rejoin [row "x" colmn] if not find floor each-coord [ line-is-full: false break ] ] if line-is-full = true [ remove-each cor floor [(first cor) = row] new-floor: copy [ 31x5 31x6 31x7 31x8 31x9 31x10 31x11 31x12 31x13 31x14 31x15 31x16 31x17 31x18 31x19 31x20 31x21 31x22 31x23 31x24 31x25 31x26 31x27 31x28 31x29 31x30 31x31 31x32 ] foreach cords floor [ either ((first cords) < row) [ append new-floor (cords + 1x0) ][ append new-floor cords ] ] floor: copy unique new-floor prin tui [clear] a-line: copy [] loop 28 [append a-line " "] a-line: rejoin [" |" to-string a-line "|"] loop 30 [print a-line] prin " " loop 30 [prin "+"] print "" foreach was-here floor [ if not ((first was-here) = 31) [ prin tui compose [at (was-here)] prin "#" ] ] ] ] ] Now that the program is working to my original specs, I want to make it look a bit spiffier. First of all, the playing area looks too wide and tall. I check Rebtris, and it's only 10 columns wide by 20 rows tall. I like that look and feel, so I adjust the floor block, the code that draws the static backdrop, and all computations related to the right boundaries of the playing field and the number of rows, to reflect that change. I also want to print out a "Textris" title header, some keyboard instructions, and a score header. Tui allows me to print this text to the right of the playing field where I want it: print tui [ at 4x21 "TEXTRIS" at 5x21 "-------" at 7x20 "'K' = left" at 8x20 "'L' = right" at 9x20 "'O' = spin" at 11x21 "Score:" ] Keeping track of the score is simple. When the program starts, a "score" variable is created and set to 0 ("score: 0"). Every time a piece stops falling, 10 points are added to the score. That number is printed beneath the score header (notice that the score number must first be converted to a string, in order to be printed by tui): Every time a row is filled in, 1000 points are added to the score. When the screen if redrawn to reflect the newly erased row, the tui code that prints the backdrop also prints out the updated score: print tui compose [ at 4x21 "TEXTRIS" at 5x21 "-------" at 7x20 "'K' = left" at 8x20 "'L' = right" at 9x20 "'O' = spin" at 11x21 "Score:" at 13x21 (to-string score) ] Next, I want to add a pause key. This will fit in the switch structure that watches for keystrokes. Whenever the "P" key is pressed, print a message indicating that the game has been paused. Use an "ask" action to wait for input, and then print two blank lines to erase the pause message and any errant characters that the user may type in before hitting the [Enter] key: "p" [ print tui [ at 23x0 "Press [Enter] to continue" ] ask "" print tui [ at 24x0 " " at 23x0 " " ] ] After posting some of this code to the REBOL mail list, another bug has become obvious. If the insert key or the arrow keys are pressed during game play, the game crashes. The following code produces a "** Math Error: Math or number overflow" when those keys are evaluated: To fix that, I create my own error check. The keys codes for the arrow keys are #{1B5B41}, #{1B5B42}, #{1B5B43}, #{1B5B44}, and #{1B5B327E}. I check to see if they've been pressed first. If not, run the code above: That works, but a message to the list by Gabrielle Santilli creates a simpler solution. It turns out that I should have looked at the console port format a bit more carefully. All that's needed to get the keystroke is: And that does not produce errors for any entered keys. I added all the above code to the program, and then tested everything. In doing so, I made an interesting discovery - it turns out that the code which produced the ghostly key input error in the shape printing routines is in a section of the TUI dialect that enables one to check for screen size. I think the error has something to do with the fact that I'm "compose"ing the results - not sure, but it doesn't matter. Since I'm not using that function, I simply remove it from the code. While I'm at it, I remove all the other parts of the TUI dialect that I'm not using. It turns out that all I need is: tui: func [commands [block!]] [ string: copy "" cmd: func [s][join "^(1B)[" s] arg: parse commands [ any [ 'clear (append string cmd "J") | 'up set arg integer! (append string cmd [ arg "A"]) | 'down set arg integer! (append string cmd [ arg "B"]) | 'right set arg integer! (append string cmd [ arg "C"]) | 'left set arg integer! (append string cmd [ arg "D"]) | 'at set arg pair! (append string cmd [ arg/x ";" arg/y "H" ]) | set arg string! (append string arg) ] end ] string ] With that error gone, I can remove all the error checking routines in the program (they were causing some additional problems). Now Textris feels like a reasonably complete program. Here's the final code: REBOL [Title: "Textris"] tui: func [commands [block!]] [ string: copy "" cmd: func [s][join "^(1B)[" s] arg: parse commands [ any [ 'clear (append string cmd "J") | 'up set arg integer! (append string cmd [ arg "A"]) | 'down set arg integer! (append string cmd [ arg "B"]) | 'right set arg integer! (append string cmd [ arg "C"]) | 'left set arg integer! (append string cmd [ arg "D"]) | 'at set arg pair! (append string cmd [ arg/x ";" arg/y "H" ]) | set arg string! (append string arg) ] end ] string ] shape: [ ["####"] ["#" down 1 left 1 "#" down 1 left 1 "#" down 1 left 1 "#"] ["###" down 1 left 2 "#"] [right 1 "#" down 1 left 2 "##" down 1 left 1 "#"] [right 1 "#" down 1 left 2 "###"] ["#" down 1 left 1 "##" down 1 left 2 "#"] ["###" down 1 left 3 "#"] ["##" down 1 left 1 "#" down 1 left 1 "#"] [right 2 "#" down 1 left 3 "###"] ["#" down 1 left 1 "#" down 1 left 1 "##"] ["###" down 1 left 1 "#"] [right 1 "#" down 1 left 1 "#" down 1 left 2 "##"] ["#" down 1 left 1 "###"] ["##" down 1 left 2 "#" down 1 left 1 "#"] ["##" down 1 left 1 "##"] [right 1 "#" down 1 left 2 "##" down 1 left 2 "#"] [right 1 "##" down 1 left 3 "##"] ["#" down 1 left 1 "##" down 1 left 1 "#"] ["##" down 1 left 2 "##"] ; [" "] [" " down 1 left 1 " " down 1 left 1 " " down 1 left 1 " "] [" " down 1 left 2 " "] [right 1 " " down 1 left 2 " " down 1 left 1 " "] [right 1 " " down 1 left 2 " "] [" " down 1 left 1 " " down 1 left 2 " "] [" " down 1 left 3 " "] [" " down 1 left 1 " " down 1 left 1 " "] [right 2 " " down 1 left 3 " "] [" " down 1 left 1 " " down 1 left 1 " "] [" " down 1 left 1 " "] [right 1 " " down 1 left 1 " " down 1 left 2 " "] [" " down 1 left 1 " "] [" " down 1 left 2 " " down 1 left 1 " "] [" " down 1 left 1 " "] [right 1 " " down 1 left 2 " " down 1 left 2 " "] [right 1 " " down 1 left 3 " "] [" " down 1 left 1 " " down 1 left 1 " "] [" " down 1 left 2 " "] ] floor: [ 21x5 21x6 21x7 21x8 21x9 21x10 21x11 21x12 21x13 21x14 21x15 ] oc: [ [0x0 0x1 0x2 0x3] [0x0 1x0 2x0 3x0] [0x0 0x1 0x2 1x1] [0x1 1x0 1x1 2x1] [0x1 1x0 1x1 1x2] [0x0 1x0 1x1 2x0] [0x0 0x1 0x2 1x0] [0x0 0x1 1x1 2x1] [0x2 1x0 1x1 1x2] [0x0 1x0 2x0 2x1] [0x0 0x1 0x2 1x2] [0x1 1x1 2x0 2x1] [0x0 1x0 1x1 1x2] [0x0 0x1 1x0 2x0] [0x0 0x1 1x1 1x2] [0x1 1x0 1x1 2x0] [0x1 0x2 1x0 1x1] [0x0 1x0 1x1 2x1] [0x0 0x1 1x0 1x1] ] width: [4 1 3 2 3 2 3 2 3 2 3 2 3 2 3 2 3 2 2] score: 0 prin tui [clear] a-line: copy [] loop 11 [append a-line " "] a-line: rejoin [" |" to-string a-line "|"] loop 20 [print a-line] prin " " loop 13 [prin "+"] print "" print tui compose [ at 4x21 "TEXTRIS" at 5x21 "-------" at 7x20 "Use arrow keys" at 8x20 "to move/spin." at 10x20 "'P' = pause" at 13x20 "SCORE: " (to-string score) ] keys: open/binary/no-wait [scheme: 'console] forever [ random/seed now r: random 19 xpos: 9 for i 1 20 1 [ pos: to-pair rejoin [i "x" xpos] do compose/deep [prin tui [at (pos)] print tui shape/(r)] old-r: r old-xpos: xpos if not none? wait/all [keys :00:00.30] [ switch/default to-string copy keys [ "p" [ print tui [ at 23x0 "Press [Enter] to continue" ] ask "" print tui [ at 24x0 " " at 23x0 " " ] ] "^[[D" [if (xpos > 5) [ xpos: xpos - 1 ]] "^[[C" [if (xpos < (16 - compose width/(r))) [ xpos: xpos + 1 ]] "^[[A" [if (xpos < (16 - compose width/(r))) [ switch to-string r [ "1" [r: 2] "2" [r: 1] "3" [r: 6] "4" [r: 3] "5" [r: 4] "6" [r: 5] "7" [r: 10] "8" [r: 7] "9" [r: 8] "10" [r: 9] "11" [r: 14] "12" [r: 11] "13" [r: 12] "14" [r: 13] "15" [r: 16] "16" [r: 15] "17" [r: 18] "18" [r: 17] "19" [r: 19] ] ] ] ] [] ] do compose/deep [ prin tui [at (pos)] print tui shape/(old-r + 19) ] stop: false foreach po compose oc/(r) [ foreach coord floor [ floor-y: to-integer first coord floor-x: to-integer second coord oc-y: i + to-integer first po oc-x: xpos + to-integer second po if (oc-y = (floor-y - 1)) and (floor-x = oc-x) [ stop-shape-num: r stop: true break ] ] ] foreach po compose oc/(old-r) [ foreach coord floor [ floor-y: to-integer first coord floor-x: to-integer second coord oc-y: i + to-integer first po oc-x: old-xpos + to-integer second po if (oc-y = (floor-y - 1)) and (floor-x = oc-x) [ stop-shape-num: old-r stop: true break ] ] ] if stop = true [ left-col: second pos width-of-shape: length? compose oc/(stop-shape-num) right-col: left-col + width-of-shape - 1 counter: 1 for current-column left-col right-col 1 [ add-coord: compose oc/(stop-shape-num)/(counter) new-floor-coord: (pos + add-coord) append floor new-floor-coord counter: counter + 1 ] break ] ] do compose/deep [prin tui [at (pos)] print tui shape/(old-r)] if (first pos) < 2 [ prin tui [at 23x0] print " GAME OVER!!!^/^/" halt ] score: score + 10 print tui compose [at 13x28 (to-string score)] for row 1 20 1 [ line-is-full: true for colmn 5 15 1 [ each-coord: to-pair rejoin [row "x" colmn] if not find floor each-coord [ line-is-full: false break ] ] if line-is-full = true [ remove-each cor floor [(first cor) = row] new-floor: copy [ 21x5 21x6 21x7 21x8 21x9 21x10 21x11 21x12 21x13 21x14 21x15 ] foreach cords floor [ either ((first cords) < row) [ append new-floor (cords + 1x0) ][ append new-floor cords ] ] floor: copy unique new-floor score: score + 1000 prin tui [clear] loop 20 [print a-line] prin " " loop 13 [prin "+"] print "" print tui compose [ at 4x21 "TEXTRIS" at 5x21 "-------" at 7x20 "Use arrow keys" at 8x20 "to move/spin." at 10x20 "'P' = pause" at 13x20 "SCORE: " (to-string score) ] foreach was-here floor [ if not ((first was-here) = 21) [ prin tui compose [at (was-here)] prin "#" ] ] ] ] ] The "shape" block, containing the TUI instructions for drawing each shape is defined. The "floor", "oc", and "width" coordinate blocks are defined. The "score" variable is also defined. The backdrop characters (left, right, and bottom barriers), instructions, headers, and score are printed. A forever loop runs the main actions of the program. The subsections of that loop are: A shape is printed on the screen. A switch structure decides what to do with entered keystrokes (right arrow = move right, left arrow = move left, up arrow = rotate shape, p = pause). Another switch structure determines which shape to print when the current shape is rotated. The currently printed shape is erased. Two foreach loops check whether the current shape has reached a position at which it should stop falling. If the piece has reached a stopping point, the coordinates occupied by the piece are added to the "floor" block. The shape is printed at its final resting place. If the current shape touches the ceiling, the game ends. If any rows have been completely filled in, their coordinates are removed from the floor block, the coordinates of all other characters are moved down a row, and the screen is reprinted with the new floor coordinates and the new score. If I'd been so thoughtful and organized as to write a structured outline like that in the beginning of the case study, things would've moved along more quickly. But any project is easier in retrospect ... I just try to remember that building as detailed an outline as possible before writing any code always saves a great deal of work and confusion. Now that the game satisfies my original intentions, I'll bring the case study to a close, but not without first putting together a to-do list of things to improve in the program. If you'd like to try implementing some of these changes, first figure out where in the outline they should go, write some pseudo code to get the job done, and then come up with REBOL code to satisfy those pseudo code expressions: Add a way to incrementally increase the speed at which shapes drop. Do this every time a certain number of rows is cleared. Look for a way to remove the cursor from the printout, so that it's not visible along the left side of the wall as the shapes fall. Add sound. Play tones for each event that occurs, and play a background tune while the game is running. Rewrite the entire program using GUI techniques, instead of console text characters and TUI. Looking at my coding process in retrospect, I should note some criticisms. One element that annoyed me was a set of badly chosen variable names. I initially used "r", for example, to represent the current shape number because it was first used to represent a random number. "R" is not so descriptive, and it was hard to remember what "r" represented while I was coding. The same was true of "i", which became more important as the loop that dropped the shapes grew in complexity. I left those variables as they were in this case study so that the lines of code fit neatly onto this web page, but in my own coding I choose to use more descriptive variables. Doing that in general makes code more readable and easier to think through. Whether or not you're interested in game programming, and despite the fact that the final product of this case study is a bland implementation of Tetris, some general understanding about coding can be gained from the thought process covered in this section. It's typical of any general coding project you'll encounter: start with a design concept, outline the main structure of the program you imagine, use pseudo code to guide you from the "what am I trying to do?" through the "how do I code it" stages, and refine the detail of your outline by testing and experimenting with small code chunks along the way. In general, if you can't think through the process of "what am I trying to accomplish" in a structured way, then you won't be able to write the code to accomplish it. Once you've got a basic grasp of language concepts and syntax, you'll see that writing code just takes lots of creative organization and experimentation. Keep a language reference close at hand, and you can work out the syntax of virtually any code you need to write. That's only a matter of knowing which functions and constructs are available to solve your problems, and looking up the format for those you're not familiar with. The difficult part in any coding situation is mapping each small thought process to a data construct, conditional expression, looping routine, function definition, existing code module, word label, etc. For large projects, you'll typically need an outline because it's so easy to get lost in the minute coding details along the way. Start with a top down approach, conceive and design a flow chart/outline, and then flesh out the details of each section until you've got code written to solve each design concept. Once you become familiar with that process, experience will show that you can code solutions for virtually any problem you encounter. You'll find that in many cases REBOL allows you to think directly in code more easily than you can with pseudo code. That's because REBOL's high level design is meant to be human readable and human "thinkable". Although many coding concepts in all computer languages are generally the same, most other languages are more overtly designed and constrained by legacy concepts derived from requirements about how computers operate. Some languages tend to require much more low level coding or coersing of disparate modules to fit together in order to make the conceptual design take shape in final code form. Other languages get you bogged down in thinking about higher level OOP constructs. A lack of universal data structures such as REBOL's block/series structure, a lack of built in native data types such as time, tuples, pairs, money, etc., and a less natural way of structuring functions, variables and module definitions (not using words and dialects in a natural language way), require unique and contrived constructs to be designed to manipulate data in each individual program. In the most popular languages, program authors typically have to be more concerned about managing the rudimentary memory and cpu actions of the computer for everything that occurs in a program. That enables a greater measure of control over how a computer uses it's hardware resources, but it's very far from the way humans naturally think about solving real life situations. REBOL allows things to be done in a way of thinking that's closer to the outline stage. When you get used to writing REBOL code, you'll find that it saves a tremendous amount of time compared to other languages. Remember along the way that no matter what computer language(s) you learn, understanding how to think through the "what I am I trying to accomplish" outline is essential to writing code that accomplishes your task.|||

