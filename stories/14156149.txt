The past two weeks we have been traveling and meeting a bunch of developers. It was a chance for us to tell them about Elm through talks at conferences and to present a short one-hour workshop. You can find the slides of the two talks here: However, this article is a summary of the take aways of this workshop for those who would like to know a bit more about Elm.

What is Elm and why should I be interested? Elm is a Web application development platform, providing a programming language, a compiler, an architecture and tooling around. It focuses on making sure your app state and the HTML that reflects it are always in sync. If you have been doing any frontend development during the last couple of years, you might have seen that the JavaScript ecosystem is a bit wild. Keeping up-to-date with the growing number of competing frameworks can take a lot of energy, not to mention the challenge in making sure your app works on all the available browser versions. In addition, writing tests for the front-end can be tedious and supporting Flow or TypeScript, while tremendously useful, is yet another layer to setup, configure and maintain in your stack. You can think of the Elm platform as the equivalent combined feature set of React, Redux, react-redux, Babel, eslint, Flow/Typescript and Webpack all bundled in a single homogeneous and consistent package! Elm brings functional programming to your browser. The language is statically typed, so with Elm you won't see any runtime errors caused by inconsistent typing. Being functional and pure, Elm let you write code that is completely decoupled, which makes your code more reusable and easier to refactor.

How is Elm different? Most of the time, using Elm, the two lines it takes to load your app from the HTML file is all the JavaScript you will write, as your Elm code will be compiled to JavaScript by the Elm compiler. Most mistakes you make will be caught at compilation time, which means that you will barely ever encounter exceptions at runtime in the browser. Also that means less unit tests and defensive programming to write, which is always good. Because there is a compilation step, Elm forces you to handle every possible case of your model state. It makes sure you covered them on the rendering side. Also, the Elm compiler is super smart. It always does its best to help you with meaningful messages, provides guidance to fix your types and handle uncovered edge cases. It even finds your typos! Cannot find variable nane hello ++ ++ nane ++ ^^^^ Maybe you want one of the following? name tan Cmd.none Sub.none Detected errors in module. The tooling is great. elm-live automatically updates the browser code to reflect your code update in realtime. It comes with a debugger that will show you the list of events and state of your application at a given point in time — you can even go back in time and replay previous events. elm-format will also format your code automatically to avoid fighting over coding styles.

No need for boilerplate here, you can just start by running to install the core packages required to start creating your app: ~/tutorial$ elm-package install Some new packages are needed. Here is the upgrade plan. Install: elm-lang/core .1.1 elm-lang/html .0.0 elm-lang/virtual-dom .0.4 Do you approve of this plan? Y/n Y Starting downloads... ● elm-lang/html .0.0 ● elm-lang/virtual-dom .0.4 ● elm-lang/core .1.1 Packages configured successfully! You now have an file in your project as well as a directory that contains libraries that installed. is to Elm projects what is to nodejs ones.

To get started you can simply create a new file named with the following: Elm benefits from a full featured module system, with a broad ecosystem of external packages avaiable. is part of the core. If your editor is well configured with , you should see this as soon as you save it: If not, you can run manually on your file: Opening your app in the browser One way to run your app is to use , the core app browser provided by the platform: Then open http://localhost:8000/Main.elm in your favorite Web browser.

Virtual DOM functions to generate HTML are in the module. The module we used above to render some text also exposes many more functions for rendering HTML tags. You can import them all using: Note that unlike with some other languages, the Elm compiler will complain if you try to import symbols already defined in the current module, which makes it actually useful and really enjoyable to use. You can then use directly for instance: The Virtual DOM HTML nodes are functions named after standard HTML tags, and take two parameters: If I want to create a with a link it would look like this: We can also create a list of links in our div:

Now that you know how to render your page in HTML, let's see how to write a program that handles events. The way Elm handles that is by having: a , an Elm record: a bit like a JavaScript object with properties, that keep the state of the app an update function that will handle all the app events and update the model state accordingly a view function that will return the Virtual DOM that matches the state every time it's updated. For those who know Redux, it has been heavily inspired by Elm. Basically is a reducer. The events and their parameters are defined in a type, which is a bit like a enum that would take parameters. In order to create our application that handle states, we can use the from the Html package: We can now handle an event and change the name when we click on it. You can refresh the page and try it. If we want to switch back to when we click on we can add a :|||

Service de nuages,