Many of the questions asked in #postgresql revolve around using sequences in PostgreSQL. To avoid answering the same questions again and again, I thought it would be worthwhile to summarize the basic steps involving in using sequences in PostgreSQL.

A sequence is a special kind of database object designed for generating unique numeric identifiers. It is typically used to generate artificial primary keys. Sequences are similar, but not identical, to the concept in MySQL.

Sequences are most commonly used via the pseudotype. A is a special data type that encodes the following information:

For example, this command creates both a new table and a new sequence generator, and associates the sequence with the column of the table:

In this case, the sequence is automatically assigned the name users_id_seq. To avoid hard-coding the name of the sequence in SQL queries, we can use the function, as described below.

Note that using does not implicitly create an index on the column, or mark the column as a primary key. That can be easily done, however:

If you're using , the default value for the serial column will be the next value produced by the sequence. To specify that an should take the default value for a given column, either omit that column from the 's column list, or specify the keyword as the column's value.

You can use the function, which returns the most recent value generated by a sequence for the current session. takes a single parameter: the name of the sequence. We can use the function to find the name of the sequence associated with a given serial column:

Note that if no values have been generated by the sequence yet in the current session, will yield an error.

That is, if one database client inserts a row into a table that includes a sequence-generated value, wouldn't it be possible for another insertion into the table to modify the sequence, causing a subsequent by the first client to return the wrong results?

No: sequences were designed to elegantly avoid this problem. returns the last value generated by the sequence for the current session: if concurrent database clients generate sequence values, the seen by a given session does not change (until the session generates a new sequence value, for example).

To use the method shown above, we'd need two queries: one to insert into the table, and another to fetch the sequence value assigned to the new row. Since client-server roundtrips can be expensive, this is not ideal. One way around this is to send the and the as a single query string. For example, in PHP:

This executes two queries, but does only a single roundtrip between the client and server, so the additional performance overhead of the second query should be negligible.

Alternatively, users of PostgreSQL 8.2 and later can take advantage of the clause:

which returns the value of the column for the newly-inserted row.

Sequences generate 64-bit signed integers. The pseudotype that we used above is a 32-bit signed integer: if you want to use the full 64-bit range of the underlying sequence, use the pseudotype instead.

Yes, there can. Sequences are intended for generating unique identifiers â€” not necessarily identifiers that are strictly sequential. If two concurrent database clients both attempt to get a value from a sequence (using ), each client will get a different sequence value. If one of those clients subsequently aborts their transaction, the sequence value that was generated for that client will be unused, creating a gap in the sequence.

This can't easily be fixed without incurring a significant performance penalty. For more information, see Elein Mustein's "Gapless Sequences for Primary Keys" in the General Bits Newsletter.

Sequence operations are essentially non-transactional. increments the value of the sequence and is not rolled back if its transaction is later aborted; returns the last value generated by the sequence for the current session, regardless of transaction boundaries.

The easiest way to do this is to create the sequence by hand, and then set the default clauses for the sequence-generated columns by hand, rather than using the type:

is a function that produces a new sequence value.

Note that when using sequences in this manner, the sequence won't be automatically dropped when the table is dropped, and you won't be able to use .|||

