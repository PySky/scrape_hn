Similar to the $node_id column, it is recommended that users create a unique index or constraint on the $edge_id column at the time of creation of the edge table, but if one is not created, a default unique, non-clustered index is automatically created on this column. It is also recommended, for OLTP scenarios, that users create an index on ($from_id, $to_id) columns, for faster lookups in the direction of the edge.Inserting into a node table is same as inserting into a regular tableLet's see what the output looks likeAs you can see, there is JSON in the $node_id columnThe sys.tables view has 2 new columns, is_edge and is_node. If we query the sys.tables view now for the Person table we just created, you will see that is_node = 1Here is the resultNow we will add another table, this table will have some data about DB productsAnd now it is time for our edge tables, we will have 2 of them, a likes table and a friendOf tableTo insert into the likes table, we have to say which person likes what product. The person will go into the $from_id column, the DBProduct will got into the $to_id column. You $Node_id to grab the id to populate this tableThe node_id for Person with an id of 1 will go into the $from_id column, the node_id for DBProduct with an id of 1 will go into the $to_id column. That looks like thisHere are the insert statements to populate this table

Uniquely identifies a given edge in the database. It is a generated column and the value is a combination of object_id of the edge table and a internally generated bigint value. However, when the  $edge_id  column is selected, a computed value in the form of a JSON string is displayed.  $edge_id  is a pseudo-column, that maps to an internal name with hex string in it. When you select  $edge_id  from the table, the column name will appear as  $edge_id_\<hex_string> . Using pseudo-column names in quereis is the recommended way of querying the internal  $edge_id  column and using internal name with hex string should be avoided.

There are certain limitations on node and edge tables in this release:

Let's look at what it looks like in the likes edge tableHere is what it looks like, as you can see it is a bunch of JSON.. (click on the image for a bigger version)Now we will also insert some data into the friendOf table, it is the same as with the likes table, lookup the node ids and insert the dataNow it is time to run some queriesThis query will return all the products that Denis likesname-------------SQL ServerCassandraNot surprisingly, SQL Server is in that listWhat about my friends? What DB products do they like?DBName                  name---------------         ------------SQL Server              ShidharMongoDB                 LizOkay, SQL Server and MongoDB, I can live with thatWhat about Liz, what does her friend Kevin like?DBName             name-------------FoundationDB     KevinFoundationDB? Didn't Apple buy that and then shut down the downloads?So what product is there that both friends like?To do that we specify that person1 is a friendOf person 2and both person1 and person2 like the same product. Since you cannot use the same table twice, you need to use an alias, in this case I have used l2 as an alias for the likes tableDBName        name       name-----------SQL Server    Denis      ShidharWhat a surprise, can you believe it, it is SQL Server!!Let's take a look at some meta data, this time, we are adding some columns from the sys.columns view, I have added graph_type_desc and is_edgeHere is the output from that queryYou might have noticed that SQL Graph queries use old style joinsSo instead of thisI can do this right?Yes that works, both queries return 54432 rowsWill it work with the WHERE clause?Msg 13920, Level 16, State 1, Line 164Identifier 'person1' in a MATCH clause is used with a JOIN clause or APPLY operator. JOIN and APPLY are not supported with MATCH clauses.Msg 13920, Level 16, State 1, Line 164Identifier 'friendOf' in a MATCH clause is used with a JOIN clause or APPLY operator. JOIN and APPLY are not supported with MATCH clauses.Msg 13920, Level 16, State 1, Line 164Identifier 'person2' in a MATCH clause is used with a JOIN clause or APPLY operator. JOIN and APPLY are not supported with MATCH clauses.Msg 13920, Level 16, State 1, Line 164Identifier 'person2' in a MATCH clause is used with a JOIN clause or APPLY operator. JOIN and APPLY are not supported with MATCH clauses.Msg 13920, Level 16, State 1, Line 164Identifier 'likes' in a MATCH clause is used with a JOIN clause or APPLY operator. JOIN and APPLY are not supported with MATCH clauses.Msg 13920, Level 16, State 1, Line 164Identifier 'DBProduct' in a MATCH clause is used with a JOIN clause or APPLY operator. JOIN and APPLY are not supported with MATCH clauses.Msg 13920, Level 16, State 1, Line 165Identifier 'person1' in a MATCH clause is used with a JOIN clause or APPLY operator. JOIN and APPLY are not supported with MATCH clauses.Msg 13920, Level 16, State 1, Line 165Identifier 'l2' in a MATCH clause is used with a JOIN clause or APPLY operator. JOIN and APPLY are not supported with MATCH clauses.Msg 13920, Level 16, State 1, Line 165Identifier 'DBProduct' in a MATCH clause is used with a JOIN clause or APPLY operator. JOIN and APPLY are not supported with MATCH clauses.Boooo ... that is a big fat nopeAlso keep the following in mindThis was just a first look at Graph SQL, I will have to play around with it a little more to get more familiar with it and see if there are any use cases for meIn the meantime, visit Books On Line and start playing around with SQL Graph: https://docs.microsoft.com/en-us/sql/relational-databases/graphs/sql-graph-overview|||

