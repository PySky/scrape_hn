Linux, Apache, MySQL, and PHP, or LAMP, is one of the most popular software stacks powering content on the internet. This tutorial shows you how to set up your own LAMP stack on Kubernetes. The Kubernetes cluster we will build our LAMP stack on is the Quick Start for Kubernetes on AWS. The LAMP stack takes advantage of several Kubernetes features to provide a robust starting point for a modern PHP application. Our stack supports load-balancing web traffic, horizontal scaling, data persistence, secret management, and rolling updates, among many other Kubernetes benefits. Please keep in mind that the Kubernetes cluster created by the Quick Start is suitable for non-mission critical applications and for learning how Kubernetes works. It is a single-zone cluster. Finally, the example PHP application in this tutorial is a demo application not meant for production. This tutorial is intended for readers who want to run their own LAMP application, learn what a standard software stack looks like on Kubernetes, or have a greater degree of control over configuration for a popular PHP application like WordPress. On the other hand, if you’re happy with pre-baked settings, it will be faster to install WordPress with Helm. Similar preconfigured installations exist for many popular PHP apps. This tutorial shows how to install an example LAMP stack with a demo PHP application. The last step contains a checklist for modifying the instructions to deploy your own application. During our tests, Kubernetes creation and resource provisioning took about 2-5 minutes on Amazon Web Services (AWS).

This tutorial runs from a Kubernetes Quick Start cluster on AWS. It can be deployed from four YAML files containing configurations for Kubernetes objects. The four files are , , , and . These config files and our PHP application are available on Heptio’s GitHub account. The example application runs the MySQL database server and PHP/Apache server separately, for scaling. It runs them as Kubernetes Deployments. A Deployment is a Kubernetes object which helps solve a number of devops problems, like scaling and rolling updates. The application uses a standard MySQL image and a custom PHP image, which are from the public Docker Hub images for MySQL and PHP. It uses a PersistentVolumeClaim for the database, which is a paid resource in addition to the resources for the initial cluster. It uses a LoadBalancer as a front end for the three PHP/Apache containers deployed from the custom PHP image. The LoadBalancer is another paid resource. One single file - - stores the MySQL users, passwords, and initial database name. Our stack creates a Kubernetes Secret with these values, which are then set as environment variables on the containers. This eliminates the need to store sensitive information with our application. Finally, database initialization is handled with a one-time Job that runs a (non-public) bash script from our PHP image that downloads MySQL’s Sakila sample database and keeps trying to import it to our MySQL server until it completes successfully. The Job runs only once. Since our Secret is used in our other objects, we bring it up first. Since our Job will complete successfully only after the MySQL server is up, we bring it up last. However, if we create the objects out of the recommended order, Kubernetes will keep trying to create our objects until prerequisites have come up.

1. (Optional) Build local PHP and Apache Docker image with phpinfo() and MySQL test script This tutorial calls for a PHP application. We’ve built a PHP image at heptio/example-php-dbconnect that you can download and deploy to your cluster. If you just want to see the Kubernetes cluster in action with Heptio’s demo app, please feel free to skip to the next step. The rest of this section explains how we built on the default Docker Hub PHP image to create a custom PHP application image. Follow along with the example to help you build your own app. Docker running on your local computer (install Docker). You should be able to run and get a (potentially empty) list of containers starting with , rather than an error A Docker Hub account, so you can publish and later download your application image. (It’s possible to publish to other registries, too; not just Docker Hub) You can create this directory structure now, or as you create the files. Or, take a look at this PHP project on GitHub. First, let’s take a look at our . The contains the instructions for building our custom Docker image. (For more information, please visit Docker’s documentation.) You can view the Dockerfile online in our project, but since it’s pretty short, we’ll also show the contents here: # base this image on the PHP image that comes with Apache https://hub.docker.com/_/php/ # install mysql-client and curl for our data init script # install the PHP extension pdo_mysql for our connection script # take the contents of the local html/ folder, and mount to /var/www/html/ inside the container # this is the expected web root of the default website for this server, so put your index.php here # take the contents of the local script/ folder, and mount to /tmp/ inside the container # we can run one-time scripts, downloads, and other initial processes from /tmp/ The line indicates that we’re basing our application on the default Docker Hub PHP image, and specifically, the version that includes our web server Apache along with it. We install a few utilities like and so we can initialize the database. We also install , an extension for PHP that allows us to make our database connection and queries. The application adds two of our own PHP files. One is an index file with phpinfo(), useful for viewing our server’s PHP settings and demonstrating that the PHP server is running. The second script demonstrates how to connect to our MySQL server and show a list of tables from a database. We’ll use MySQL’s Sakila sample database, a standard test database that contains data about movies. To view the scripts, please visit the project copy of index.php, which is the phpinfo() script, and mysql-connect.php, which is the database connection script. When we build the image, we import those two scripts from our local dev environment’s directory. Anything in that directory will be imported, so you can add more scripts and subdirectories to your local directory, and it will all be imported when you build your Docker image. In summary, all content stored in our local directory gets mapped to the directory inside the container, which is where Apache and PHP are expecting the content for our default website. Note: Keeping a phpinfo() page live on your site is insecure; remove after testing. We’ll also add a bash script that can connect to MySQL server and initialize our database. This is done by copying our local dev environment’s directory to in the container. Any content in the local directory will be built as part of our image. So, this is a good place to add more scripts and other one-time-use content to your image. In our case, this is a single script that downloads MySQL’s Sakila sample database and attempts to keep importing it to our MySQL server until it’s successful. Kubernetes solves some traditional devops headaches here, because it doesn’t matter if the MySQL server or the PHP server is up before this Job runs. It will keep trying to run until our MySQL server is up and the script completes successfully. The MySQL server is covered in a later step. While the script itself is part of our PHP image, it gets run from a Kubernetes Job, not the Kubernetes PHP Deployment. This Job is discussed in a later step. To view the script, please visit the project copy of mysql-sakila-data-loader.sh. Once our directory structure and files exist locally, we can build our Docker image. From the directory containing our , build the image: Let’s take a look at our PHP app locally. While not strictly necessary, it’s a good idea to check that the image does what we want it to do. This makes a container named from our Docker image named and it maps port in the container (which Apache uses to serve the content) to port outside the container. The phpinfo() page should work now, because Apache is bundled with PHP. Visit to see the home page, which shows our phpinfo(). You can also visit to see the MySQL connection test script. Right now it will show a detailed error message starting with because the database server doesn’t exist yet. Great! If everything looks in order, let’s push this image to Docker Hub so it can be available to our Kubernetes cluster. You can choose a different registry instead, if you prefer. This section provides a brief sequence of commands you can run to build and publish your PHP image. Please read Docker’s walkthrough for publishing images to Docker Hub for more detail and explanation. Note that images published to Docker Hub are public by default, so use a private registry instead if you want to keep the image private. Read our article, How to: Pull from private registries with Kubernetes, for more information. Run these commands to build and publish the image. Replace in the command below with the Docker Hub username, image name, and tag for your image. Rebuild and republish the PHP image when you update the application You should rebuild the PHP image if you change the contents of the directory, or update any of your application’s other files: Stop and remove the old container: Push the changes to Docker Hub after you make them locally. Use your own image ID. Note: We’re using for everything here, but in a more robust devops environment you would use versioning for your PHP application image, which Kubernetes supports. Next we’ll look at the Kubernetes objects required to deploy a LAMP application on our Quick Start Kubernetes cluster on AWS. We’ll start with a Kubernetes Secret that stores our MySQL credentials.

2. Use kubectl to create a Secret to store MySQL credentials A Kubernetes Secret is a more secure way to store sensitive details about our application, like our MySQL users and passwords. A Secret can be used multiple times by Kubernetes to pass details to containers running applications, or other objects that require the information. In our case, Kubernetes will pass our secrets to the MySQL server in the section of our file to set up appropriate users on the server, to the PHP server in the section of our file so our PHP script can connect to the database, and to a Job in our file so our one-time-use script can connect to the database and initialize it with actual data. If you would like to create the Secret from the secrets.yaml file and move on with the tutorial, run this command: You should see the output: That’s it. The secrets are now available to the rest of the Kubernetes cluster, and you can continue to the next step. The rest of this section explains how the secrets work, and how to create your own. Secrets get passed to containers as environment variables, so they can be referenced as environment variables from within containers. Here’s an example that shows how the secret for our database user, , is created and then used. An excerpt from our file: This is , encoded in base64. You can get the same result with: Keep in mind that Kubernetes doesn’t actively read the secret from this file every time you need it. You need to run for the Kubernetes Secret object to be created. If you change something in the file, you’ll have to run , or make a new Secret and update the references to it. (Note that if you update a Secret for something that has already been been used at the application level, Kubernetes does not know how to update a Secret below the level of other Kubernetes objects, so you would have to update it within your application separately.) The name of the Secret, in our case, is , which is also defined in the file. So, the Secret object has the specific secret , which is the encoded version of . One Secret object can have multiple secrets in it. Ours has three: the root password for MySQL, another user for MySQL, and the password for that second MySQL user. This secret is referenced in a few of our other Kubernetes objects. Take, for example, our PHP Deployment in . It has this section: This creates an environment variable for the PHP server that’s getting created in this deployment. The environment variable can be referenced as from within the PHP container. It assigns a value to from the Secret named , and chooses the value of , which in our case is ultimately . Now let’s look at how this secret makes it all the way to our application. Inside the PHP container, we can reference the environment variable , and it will work like a normal environment variable, meaning that is equivalent to . For example, in our script, we use as the MySQL username in our database connection, and it passes the value when it connects to MySQL. For more background, please read the Kubernetes documentation on Secrets. For the purposes of this tutorial, we’ve included a working secrets.yaml file in our project, which you can view at that link. It’s not secure to publish your YAML Secret in a file, but we’ve done so for the sake of the tutorial. There are actually two ways to create a Secret in Kubernetes. The first way is to create a YAML file with base64-encoded values, and run the command, as shown above. The other way is to use to generate the Secret directly on your cluster. Read the Kubernetes Secret documentation for more explanation. Verify that is in our list of secrets: The order in which you create the Kubernetes objects for this application doesn’t actually matter, but the other objects use this Secret, so they will not complete 100% until the Secret is created. Now that our credentials are ready, let’s create our MySQL server.

Let’s use kubectl to deploy MySQL server on our Kubernetes cluster. The only command we need to deploy these Kubernetes objects from our mysql.yaml file is: You’ll see the following output for a successful deployment: This creates the MySQL server with persistent data storage, and accessible from within the cluster at . The functional details for our MySQL server are in the Kubernetes YAML configuration file. Let’s unpack the configuration file, so we can understand what Kubernetes is doing to create our MySQL server. The complete file is on GitHub (view mysql.yaml here) and includes section-by-section comments. The YAML deploys three distinct Kubernetes objects, separated by in the file: A PersistentVolumeClaim, which reserves a separate disk for storing data in a more permanent way. This is so the contents of the database remain stored on the same disk, even as the pod running our MySQL server is more ephemeral. Our particular setup requests sane defaults for the storage volume from Amazon Web Services, which gives us an EBS volume. This is a paid resource. Kubernetes can provision this cloud storage resource when configured correctly with the cloud provider. The Heptio Quick Start for Kubernetes on AWS does this for you automatically. Note: If you are not using AWS or you don’t have cloudprovider=aws configured, you must create a PersistentVolumeClaim and PersistentVolume separately. Your cloud provider must support network attached volumes. You will have to name it and make sure your cluster has permission to attach it. A Deployment, which is the recommended Kubernetes object for managing containers throughout the software release cycle. Our Deployment calls for one pod with one MySQL container, imaged from the default MySQL image from Docker Hub. This is how we deploy MySQL server on our cluster. The Deployment also calls for a volume, that uses the disk from the PersistentVolumeClaim. A Service, which allows for consistent network access to our MySQL server, even as Kubernetes handles pod logistics behind the scenes. Our particular Service makes MySQL accessible to the rest of the cluster using the host and port (default MySQL port). We can use this host from other parts of our app running in the same Kubernetes cluster, like the PHP app we will deploy next. We recommend reading through the comments in mysql.yaml for a detailed look at the Kubernetes configuration. At a high level, our configuration takes advantage of Kubernetes in a few key ways. First, our MySQL installation uses default settings — it uses Docker Hub’s official MySQL image — and is independent of the data we’ll store on it (addressed in a later step). This means it’s a suitable configuration for many MySQL-backed applications. Second, it mounts a separate storage volume to within the container, so data stored on the volume stays independent of the Kubernetes pod and container. Third, it uses a Kubernetes Deployment to keep our number of MySQL pods optimized - in this case, we’re deploying just one ( ). We’ll cover updates in another article, but putting our pod in a Deployment sets us up for success in terms of versioning. Since our MySQL server is backed by an attached volume, and MySQL sharding/replication is beyond the scope of this tutorial, the only supported value for MySQL replicas is . Fourth, sensitive MySQL data is read from a different Kubernetes object, the Secret we configured earlier, and passed to the pod via environment variables. Our MySQL image expects all of these settings (root password, another user and password, and a new database); see the image documentation for details. How do I use this MySQL server? Any application running on the Kubernetes cluster can access the MySQL server over on port . For MySQL credentials, we recommend using the environment variables and , as demonstrated with our PHP application in the next step. The environment variables must be imported from the Kubernetes Secret and set in your application container(s). For testing, you can use the user and password , or user and password directly. Please generate your own users and passwords and store them in the Secret; using these defaults is not secure. You can initialize your data from a script, as is shown in a later step. Or, connect to the server from a shell to check that the MySQL server is up and access it from the command line. After running to deploy MySQL, give your cluster 2-5 minutes to deploy volumes, download the MySQL image, and finish setting things up. Check to see if the MySQL pod is up with: Optional - view the pod logs, substituting your own pod name, which can be obtained using the command above. Now, let’s check to see if the MySQL server is up, by using the command line. Create an ephemeral pod, which stays up for a few minutes for testing, and then removes itself. This one will be built with the MySQL client image, and let us connect with bash so we can run commands. Your temporary pod should start up. Press to get a command prompt. Now, connect to MySQL - the MySQL server that’s running in our other pod. Note our settings: We’re connecting on the host , which is the service we set up in our manifest file. We’re using port and the username and password from our Secret. (We’re using the username and password directly, since we didn’t pass this ephemeral pod any environment variables from our Secret.) Now you should see a MySQL prompt. Try showing our databases: This indicates that your database server is up and running, and accessible from other pods in the cluster. Run other MySQL commands as needed. However, we recommend initializing the database programatically, as shown in a later step. The ephemeral pod will remove itself after few minutes of inactivity with the following output: mysql> Session ended, resume using when the pod is running deployment deleted You can always run the command to create the MySQL client pod again, if you would like to resume testing. If you need to destroy and then recreate the deployment, here’s the whole sequence of commands. Note that this tears down the entire setup, including deleting our storage volume with all our data. This would not be the recommended way to update to a new MySQL image, since that can be handled with the Kubernetes Deployment object. Run these commands to tear down, recreate, and then connect to MySQL on Kubernetes: To tear down everything even faster, you can run this destructive command: Now that our database is in place, let’s deploy our custom PHP application. We’ll use a Kubernetes Deployment object for PHP, too.

Let’s use kubectl to deploy PHP and Apache on our Kubernetes cluster. The only command we need to deploy these Kubernetes objects from our php.yaml file is: You’ll see the following output for a successful deployment: This creates the PHP and Apache server with a load balancer named . It may take about 2-5 minutes to provision the load balancer. The functional details for our PHP server are in the Kubernetes YAML configuration file. Let’s unpack the configuration file, so we can understand what Kubernetes is doing to create our PHP server. The complete file is on GitHub (view php.yaml here) and includes section-by-section comments. The YAML deploys two distinct Kubernetes objects, separated by in the file: A Deployment, like we used for MySQL. Our Deployment calls for three pods with one PHP container each, imaged from the our custom PHP image on Docker Hub. This is how we deploy our PHP application on our cluster. A Service, which allows for consistent network access to our PHP/Apache server, even as Kubernetes handles pod logistics behind the scenes. Our particular Service is a Kubernetes LoadBalancer that uses AWS Elastic Load Balancing. This is a paid resource. It makes our application available on the internet on port (standard web port). We can use the load balancer’s DNS name to access our application over the internet. We recommend reading through the comments in php.yaml for a detailed look at the Kubernetes configuration. Our PHP application takes advantage of Kubernetes for load balancing, versioning, and security. It provisions AWS Elastic Load Balancing as a front end for the application. This works because we have cloudprovider=aws enabled on the cluster. With automatic load balancer provisioning, it’s nearly effortless to have a front end that load balances traffic to our application automatically. Our Kubernetes Deployment keeps the number of PHP pods optimized to three. This lets Kubernetes load balance traffic to the application. A Deployment also makes rolling updates relatively painless when you publish a new version of the application. Finally, we can scale out even further by updating a single line ( ) in our configuration file. For example, we could run this command to update to five replicas: . There’s also no need to store our MySQL credentials anywhere in our application code. Kubernetes reads values from the Secret we configured earlier and passes them to the pod via environment variables. We’ll go over the specific environment variables below. How do I use this PHP/Apache server? Our PHP image includes Apache, so the web server is built in. It serves content for the default website from in the container. If you go back to the first step in this tutorial, you can read how to add your own application content to this directory. If you have your own PHP image to use, replace this line in the file: Replace this with a link to your own image at your own registry. (If a full URL is not specified, Kubernetes assumes the image is on Docker Hub.) Kubernetes does not make the container accessible to the public unless we tell it to, which is where the Service part of our deployment comes in. Once the Service has provisioned our load balancer, you can get its AWS DNS name with the following command: You’ll get a lengthy DNS name in the column, which will look something like . If you visit that URL in your browser, you will see the phpinfo() page from our PHP image. If you’re not able to connect, wait a few more minutes for AWS to finish provisioning the load balancer and configure its networking. If you visit , you should see the message . This means our PHP app has connected to our database successfully. However, it is not showing any table names yet, because we haven’t initialized our database with any data. We’ll do this in the Job step below. You can use this load balancer DNS name with a CNAME DNS entry, to use your own domain for this application. To quote AWS’s advice about DNS and load balancers, Because the set of IP addresses associated with a LoadBalancer can change over time, you should never create an “A” record with any specific IP address. If you want to use a friendly DNS name for your load balancer instead of the name generated by the Elastic Load Balancing service, you should create a CNAME record for the LoadBalancer DNS name, or use Amazon Route 53 to create a hosted zone. For more information, see Using Domain Names With Elastic Load Balancing The PHP server has a few environment variables set, related to the MySQL server. , , and are all used by our database connection script in a later step. The environment variables are imported from the Kubernetes Secret and set in your application container(s) by Kubernetes when we create the Deployment. For testing access to MySQL, you can also use the user and password , or user and password directly. Please generate your own users and passwords and store them in the Secret; using these defaults is not secure. You can connect to the server from a shell to check that the web server is up and curl it from the command line or execute other bash commands. After running to deploy PHP, give your cluster 2-5 minutes to download the custom PHP image, and get the load balancer set up. Check to see if the pods are up: Optional - view one of the pod’s logs, substituting your own pod name, which can be obtained using the command above. Get a bash shell on one of the pods: Use curl to see if the web server is responsive from localhost: At this stage, you should get this response: For development, if you want to make changes to your PHP application live on the server, it could make sense to scale this Deployment to instead of . You can do this by running .That way, you’ll know you’re hitting the pod where you’re making the changes, because it’s the only pod. When you’ve got what you want, create a new application image for production use. Going into a pod on the command line is not a recommended way of updating your application. For that, you should build a new version of your image, publish it a registry, and update your Deployment to roll out the new image. We’ll discuss the recommended way to release a new version of your application in another article. For our demo application, our makes sure we always check for the latest version of the PHP image when creating the Deployment, even if the version tag is the same. In a more robust devops environment, you’d want to take advantage of Kubernetes rolling updates and image versions instead. If you need to destroy and then recreate the deployment, here’s the whole sequence of commands. Note that this tears down the entire setup, including deleting our load balancer with the static DNS name. This would not be the recommended way to update to a new PHP image, since that can be handled with the Kubernetes Deployment object. Run these commands to tear down, recreate, and then connect to a bash shell on one of your PHP pods. You will have to use your own pod name instead of . The three pod names will be listed in the output from the command: To tear down everything even faster, you can run this destructive command: Next, let’s add some data to our database, using a one-time Kubernetes Job.

Many LAMP applications need up-front database configuration. Whether you need to initialize your database schema, install a pre-existing data set, or both, you need a way to run some MySQL commands to import your data. Use to execute our data loader Job: This Job runs a script, , that’s in a new container built from the same PHP image. When it’s done, our database has been initialized. View your URL again, which should be something like , to see the effect on our application. You should see a list of table names beginning with . Our LAMP application is now complete. Our script is also part of our PHP image, and is located in the image’s directory. While it’s not necessary to have our more permanent website files and our single-use script in the same Docker image, it’s convenient to package them together. This brief bash script uses to download the compressed database files for the Sakila example database from MySQL. This is a standard test database with information about movies. View the data loader script here. It is thoroughly commented. It keeps trying to import the data to MySQL until a check on one of the tables completes successfully. The data import is done with . Because the script has , if any commands in the script fail, the whole script returns nonzero. This is relevant to the Kubernetes Job that is responsible for executing the script. You can view the Job in the data-loader-job.yaml file in our GitHub project. The file is commented section by section. The data loader Job has , which means that the Job will keep trying to run the script until the script returns successfully - that is, with zero. Once it does complete successfully, the Job will not try to run again. This means that our stack starts trying to import the data once, keeps trying until it completes successfully, and then doesn’t ever try to import the data again. One of our PHP containers is up while the Job runs, but it doesn’t stay running indefinitely like the containers in our PHP Deployment. Write your own script to import data or perform another one-time task on your stack. Run the script from an image with appropriate utilities and permissions. In the file, update the to the image your script is on, and that has the necessary utilities. Update the to run your script. If the command is short enough, you can run it from the YAML file instead of putting it in a script (see the Kubernetes documentation about Jobs). If you need to reapply the data, first make sure the database is empty. Delete the Job, and then recreate it. Our LAMP application is complete! The next two optional steps show you how to troubleshoot the PHP-to-MySQL connection a little bit, and how to customize this LAMP application further.

If you visit , you should see a simple list of database names from the Sakila test database, starting with . If the database server is down, or the connection details are not correct, the PHP connection script at shows: {"outcome":false,"message":"Unable to connect: PDOException: SQLSTATE[HY000] [2002] Connection timed out in \/var\/www\/html\/mysql-connect.php:7

Stack trace:

#0 \/var\/www\/html\/mysql-connect.php(7): PDO->__construct('mysql:host=mysq...', 'varMyDBUser', 'varMyDBPass', Array)

#1 {main}"} Note that the attempted username and password are displayed in this error message, so you would not want to be this explicit in a production environment! It does demonstrate that the secrets are being used by the script, via our environment variables. If the database connection works, but there’s no data: If the database connection works, and there is data (this is the desired state): If the connection doesn’t work at all, see if you can connect from the PHP container to the MySQL server. Get a shell to one of the PHP pods (remember to to see the specific pod names). Can you connect to the database server? The host is the service we set up in our manifest file. We’re using port and the root password , for troubleshooting. Now you should see a MySQL prompt. Try showing our databases: Does the database appear in the list? If not, you may need to run the again, as explained in an earlier step. Finally, let’s take another look at the ways we can use this example LAMP application as a springboard for your own app.|||

