Getline.in reached out to me asking to provide them with a completely working Ethereum application prototype for crowdfunded loans. The task was to create both back-end (Smart Contract) and front-end (Dapp). The end goal being a way to validate the market and understand the technology stack for further development. Since this was supposed to be quick and dirty we set-up a deadline of a week — what we build is what we end up with, no extensions. We ended up spending ~20 hours and the end-product can be seen on etherloans.netlify.com. For the website to work you need to have the Metamask plugin with an unlocked wallet (other Ethereum nodes that inject Web3 API should also work) and be on Ethereum’s test network.

First of all, what should be the high-level flow of such a loan?

After we had the basics planned we could start thinking about what technologies to use.

A quick explanation what a Dapp really is: Dapp is just a normal website that can be hosted anywhere. By using Ethereum Javascript Web3 API you can interact with an Ethereum node installed either on your client’s computer, or any other public Node set-up on internet. That Node acts as a gateway to the Ethereum network and allows you to talk to the deployed smart contracts. Since non-local Nodes don’t have information about the client’s wallet we couldn’t use cloud ones to allow investments and withdrawals and opted for requiring a Node installed on the user’s computer.

In Dapp the back-end instead of living on some company owned server is your smart contract living on the blockchain. They’re written in Solidity (there are other Contract languages, but this is one is a lot more popular and nowadays the preferred way to write contracts). While you still need write Ethereum Contracts directly, frameworks such as Truffle or Embark provide additional value with easy deployments on networks, migrations for updating existing contracts and on-chain and off-chain unit testing. We ended up using Truffle supplemented with TestRPC Node. TestRPC allows faking of the whole blockchain, it simulates all transactions locally and in a speedy way. It’s perfect for testing before real deployment.

As for the front-end itself we decided on Angular 2. Alot of the community uses Meteor.js since it nicely fits into the Dapp model, but we were time-constrained and opted for something we knew better.

Smart Contracts’ code is immutable by design. Once you deploy something, it’s going to live in it’s current form on blockchain forever. Contracts are modeled after Object Oriented Programming, and thus their internal state can be changed by calling their methods. Such method calls are a blockchain transactions, they are mined and the Contract state is changed for every participating Etherum client, and so they need to run on every computer. This is costly and due to, by-design, Turing-completeness, we can’t know if they ever finish. Ethereum solves this problem by defining that every run instruction costs some amount of Ether (for simplicity sake, there’s abit more complex abstraction called Gas).

But Contracts also support pure functions, ones that don’t change the state of the Contract, which are not run on the blockchain, only on the Dapp-used Node instead. Such pure functions are used to get data and information about the Contract, for example to display it to the user.|||

Getline.in reached out to me asking to provide them with a completely working Ethereum application prototype for crowdfunded loans. The task was to create both back-end (Smart Contract) and front-end…