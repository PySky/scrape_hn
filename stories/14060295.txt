Have you ever worked your fingers to the bone on an application development project, only to realize that the eventual software isn’t fit for purpose? You invested time, energy and money into the project – so what went wrong?

Mis-managed requirements could be the answer. Requirements management has historically been the bugbear of many a software application development project. Business Analysts have the tough job of juggling stakeholder needs and desires while getting inside the heads of users and understanding the pressures on developers. No wonder requirements management goes wrong sometimes!

Thankfully, there are a range of tools out there to help the harried BA stay on top of requirements gathering and requirements.

According to IEEE’s Glossary of Software Engineering Terminology, a requirement is:

Requirements can be functional or non-functional, meaning either directly related to a product’s technical functionality, or a criteria-based requirement.

Requirements have to be discovered, prioritized, organized and managed right through to product release, and sometimes beyond. Business Analysts do this by eliciting and tracking requirements, figuring out the impact of product changes or tests, changing requirements accordingly and explaining the changes to all relevant stakeholders.

Good requirements management requires tech savvy and kinship with designers and developers, as well as a thorough understanding of target users and impeccable organization skills.

Working with a prototyping tool can actually help Business Analysts overcome the challenges of requirements management, and streamline the workflow between stakeholders and the product team. Find out how with these three tips on managing requirements with a prototyping tool.

A lot of software development teams, and particularly BAs, reject the phrase ‘requirements gathering’. This isn’t just lexical nit-picking – ‘gathering’ implies that requirements are just kind of lying about on the office floor and BAs merely have to go pick them up. Far from it! Requirements have to be actively elicited from stakeholders and users.

Using prototypes to elicit requirements is a pretty new methodology that fits equally with agile or waterfall approaches. Here’s how it works

This iterative requirements gathering goes on until there are sufficient requirements to build out an MVP.

With prototypes, the passive requirements ‘gathering’ process becomes a more involved and critical elicitation process.

Managing requirements takes a heck of a lot of organization. You’ve got to figure out which requirements have priority, track them and communicate them clearly. In the early years of software development, BAs tried to keep on top of things by producing monster paper documents which they then distributed to all concerned. These could run over 100 pages of dense text – few stakeholders have the time or the inclination to read documentation like that.

Better to build requirements documentation into a prototyping tool, alongside the actual product iterations. Tools like Justinmind Enterprise have a Requirements tab where BAs can define and manage complete sets of requirements, which can then be customized and categorized to project needs.

Digital requirements can even be associated with prototype elements and events – stakeholders can click either on the UI element or on the requirement and see the relation between the two clearly mapped.

Every time there’s a change to requirements, relevant stakeholders know exactly what’s going on. The outcome? Communication between BA and stakeholders gets a whole lot easier.

Versioning isn’t just about maintaining a list of the changes made to requirements. It’s about tracking the evolution of changes and, most importantly, their impetus. That way decisions can be validated and backed up further down the road.

Justinmind Enterprise allows BAs to maintain a version history of requirements right there in the prototyping tool. This way, teams are always working on the latest version even if their remotely distributed – no team member is left behind working on cancelled requirements.

Also, version histories can be super useful for future projects: looking back on mistakes or changes and remember why they were made is great learning practice.

Even if you’ve got a map and a compass, it’s easy to wander off the software development mountain trail (you gotta love a requirements management metaphor!). That’s why it’s important to hold your nerve and generally know your requirements inside out. Control the requirements evolution, the iteration cycles, the design steps and the achievements. This way you won’t only know where you are, you’ll know how you got there too.

Requirements elicitation and management can make or break an application. Having a prototyping tool on your side is a great way to ensure you elicit and manage requirements in a way that works for everyone on the team.

Check out all Justinmind’s requirements features here|||

Let’s take a look at how an advanced prototyping tool like Justinmind can combine requirements management with product design.