Copyright 2011-2017 Mark Watson. All rights reserved. This book may be shared using the Creative Commons “share and share alike, no modifications, no commercial reuse” license.

This eBook will be updated occasionally so please periodically check the leanpub.com web page for this book for updates.

This is the fourth edition released May 2017.

If you found a copy of this book on the web and find it of value then please consider buying a copy at leanpub.com/lovinglisp to support the author and fund work for future updates.

Why Common Lisp? Isn’t Common Lisp an old language? Do many people still use Common Lisp?

I believe that using Lisp languages like Common Lisp, Clojure, Racket, and Scheme are all secret weapons useful in agile software development. An interactive development process and live production updates feel like a breath of fresh air if you have development on heavy weight like Java Enterprise Edition (JEE).

Yes, Common Lisp is an old language but with age comes stability and extremely good compiler technology. There is also a little inconsistency between different Common Lisp systems in such things as handling threads but with a little up front knowledge you can choose which Common Lisp systems will support your requirements.

I spent time writing this book to help you, dear reader. I release this book under the Creative Commons “share and share alike, no modifications, no commercial reuse” license and set the minimum purchase price to $4.00 in order to reach the most readers. Under this license you can share a PDF version of this book with your friends and coworkers. If you found this book on the web (or it was given to you) and if it provides value to you then please consider doing one of the following to support my future writing efforts and also to support future updates to this book:

I enjoy writing and your support helps me write new editions and updates for my books and to develop new book projects. Thank you!

The (latest) fourth edition of this book was released in May 2017 and the major changes are:

The third edition was released in October 2014. The second edition was released in 2013. the major changes made in the 2014 edition are:

I would like to thank Jans Aasman for contributing as technical editor for the fourth edition of this book. Jans is CEO of Franz.com which sells Allegro Common Lisp as well as tools for semantic web and linked data applications.

I would like to thank the following people who made suggestions for improving previous editions of this book:

I would like to also thank several people who pointed out typo errors in this book and for specific suggestions: Martin Lightheart, Tong-Kiat Tan, and Rainer Joswig.

I would like to thank Paul Graham for coining the phrase “The Secret Weapon” (in his excellent paper “Beating the Averages”) in discussing the advantages of Lisp.

I would especially like to thank my wife Carol Watson for her fine work in editing this book.

This book is intended to get you, the reader, programming quickly in Common Lisp. Although the Lisp programming language is often associated with artificial intelligence, this is not a book on artificial intelligence.

The Common Lisp program examples are distributed on the github repo for this book.

Why the title “Loving Common Lisp”? Simple! I have been using Lisp for over 30 years and seldom do I find a better match between a programming language and the programming job at hand. I am not a total fanatic on Lisp however. I like both Ruby, Java and Javascript for server side programming, and the few years that I spent working on Nintendo video games and virtual reality systems for SAIC and Disney, I found C++ to be a good bet because of stringent runtime performance requirements. For some jobs, I find the logic-programming paradigm useful: I also enjoy the Prolog language.

In any case, I love programming in Lisp, especially the industry standard Common Lisp. As I wrote the second edition of this book, I had been using Common Lisp almost exclusively for an artificial intelligence project for a health care company and for commercial product development. While working on the third edition of this book, I was not using Common Lisp professionally but since the release of the Quicklisp Common Lisp package manager I have found myself enjoying using Common Lisp more for small side projects. I use Quicklisp throughout in the new third edition example code so you can easily install required libraries.

As programmers, we all (hopefully) enjoy applying our experience and brains to tackling interesting problems. My wife and I recently watched a two-night 7-hour PBS special “Joseph Campbell, and the Power of Myths.” Campbell, a college professor for almost 40 years, said that he always advised his students to “follow their bliss” and not to settle for jobs and avocations that are not what they truly want to do. That said I always feel that when a job calls for using Java or other languages besides Lisp, that even though I may get a lot of pleasure from the job I am not following my bliss.

My goal in this book is to introduce you to one of my favorite programming languages, Common Lisp. I assume that you already know how to program in another language but if you are a complete beginner you can still master the material in this book with some effort. I challenge you to make this effort.

There are several Common Lisp compilers and runtime tools available for free on the web:

There are also fine commercial Common Lisp products:

For working through this book, I will assume that you are using SBCL.

This is a trick question! Lisp is slightly more similar to Java than C++ because of automated memory management so we will start by comparing Lisp and Java.

In Java, variables are strongly typed while in Common Lisp values are strongly typed. For example, consider the Java code:

Here, in Java, variables are strongly typed so a variable x of type Float can not legally be assigned a string value: the code in line 5 would generate a compilation error.

Java and Lisp both provide automatic memory management. In either language, you can create new data structures and not worry about freeing memory when the data is no longer used, or to be more precise, is no longer referenced.

Common Lisp is an ANSI standard language. Portability between different Common Lisp implementations and on different platforms is very good. I use Clozure Common Lisp, SBCL, Allegro Lisp (from Franz Inc), LispWorks, and Clisp that all run well on Windows,Mac OS X, and Linux. As a Common Lisp developer you will have great flexibility in tools and platforms.

ANSI Common Lisp was the first object oriented language to become an ANSI standard language. The Common Lisp Object System (CLOS) is probably the best platform for object oriented programming.

In C++ programs, a common bug that affects a program’s efficiency is forgetting to free memory that is no longer used. In a virtual memory system, the effect of a program’s increasing memory usage is usually just poorer system performance but can lead to system crashes or failures if all available virtual memory is exhausted. A worse type of C++ error is to free memory and then try to use it. Can you say “program crash”? C programs suffer from the same types of memory related errors.

Since computer processing power is usually much less expensive than the costs of software development, it is almost always worth while to give up a few percent of runtime efficiency and let the programming environment of runtime libraries manage memory for you. Languages like Lisp, Ruby, Python, and Java are said to perform automatic garbage collection.

I have written six books on Java, and I have been quoted as saying that for me, programming in Java is about twice as efficient (in terms of my time) as programming in C++. I base this statement on approximately ten years of C++ experience on projects for SAIC, PacBell, Angel Studios, Nintendo, and Disney. I find Common Lisp and other Lisp languages like Clojure and Scheme to be about twice as efficient (again, in terms of my time) as Java. That is correct: I am claiming a four times increase in my programming productivity when using Common Lisp vs. C++.

What do I mean by programming productivity? Simple: for a given job, how long it take me to design, code, debug, and later maintain the software for a given task.

We will soon see that Lisp is not just a language; it is also a programming environment and runtime environment.

The beginning of this book introduces the basics of Lisp programming. In later chapters, we will develop interesting and non-trivial programs in Common Lisp that I argue would be more difficult to implement in other languages and programming environments.

The big win in programming in a Lisp environment is that you can set up an environment and interactively write new code and test new code in small pieces. We will cover programming with large amounts of data in the Chapter on Natural Language Processing, but let me share a use this general case for work that I do that is far more efficient in Lisp:

Much of my Lisp programming used to be writing commercial natural language processing (NLP) programs for my company www.knowledgebooks.com. My Lisp NLP code uses a huge amount of memory resident data; for example: hash tables for different types of words, hash tables for text categorization, 200,000 proper nouns for place names (cities, counties, rivers, etc.), and about 40,000 common first and last names of various nationalities. If I was writing my NLP products in C++, I would probably use a relational database to store this data because if I read all of this data into memory for each test run of a C++ program, I would wait 30 seconds every time that I ran a program test. When I start working in any Common Lisp environment, I do have to load the linguistic data into memory one time, but then can code/test/code/test… for hours with no startup overhead for reloading the data that my programs need to run. Because of the interactive nature of Lisp development, I can test small bits of code when tracking down errors in the code.

It is a personal preference, but I find the combination of the stable Common Lisp language and an iterative Lisp programming environment to be much more productive than, for example, the best Java IDEs (e.g., IntelliJ Idea is my favorite) and Microsoft’s VisualStudio.Net.

The material in this chapter will serve as an introduction to Common Lisp. I have attempted to make this book a self contained resource for learning Common Lisp and to provide code examples to perform common tasks. If you already know Common Lisp and bought this book for the code examples that the text that explains the examples then you can probably skip this chapter.

For working through this chapter we will be using the interactive shell, or repl, built into SBCL and other Common Lisp systems. For this chapter it is sufficient for you to download and install SBCL. Please install SBCL right now, if you have not already done so.

When we start SBCL, we see a introductory message and then an input prompt. We will start with a short tutorial, walking you through a session using SBCL repl (other Common LISP systems are very similar). A repl is an interactive console where you type expressions and see the results of evaluating these expressions. An expression can be a large block of code pasted into the repl, using the load function to load Lisp code into the repl, calling functions to test them, etc. Assuming that SBCL is installed on your system, start SBCL by running the SBCL program:

We started by defining a new variable x in line 11. Notice how the value of the defvar macro is the symbol that is defined. The Lisp reader prints X capitalized because symbols are made upper case (we will look at the exception later).

In Lisp, a variable can reference any data type. We start by assigning a floating point value to the variable x, using the + function to add 1 to x in line 17, using the setq function to change the value of x in lines 23 and 29 first to another floating point value and finally setting x to a string value. One thing that you will have noticed: function names always occur first, then the arguments to a function. Also, parenthesis is used to separate expressions.

I learned to program Lisp in 1976 and my professor half-jokingly told us that Lisp was an acronym for “Lots-of Irritating Superfluous Parenthesis.” There may be some truth in this when you are just starting with Lisp programming, but you will quickly get used to the parenthesis, especially if you use an editor like Emacs that automatically indents Lisp code for you and highlights the opening parenthesis for every closing parenthesis that you type. Many other editors also support coding in Lisp but we will only cover the use of Emacs in this web book. Newer versions of Emacs and XEmacs also provide colored syntax highlighting of Lisp code.

Before you proceed to the next chapter, please take the time to install SBCL on your computer and try typing some expressions into the Lisp listener. If you get errors, or want to quit, try using the quit function:

As we discussed in the introduction, there are many different Lisp programming environments that you can choose from. I recommend a free set of tools: Emacs, slime, and SBCL. Emacs is a fine text editor that is extensible to work well with many programming languages and document types (e.g., HTML and XML). Slime is a Emacs extension package that greatly facilitates Lisp development. SBCL is a robust Common Lisp compiler and runtime system.

We will cover the Quicklisp package manager and using Quicklisp to setup Slime and Emacs in the next chapter.

I will not spend much time covering the use of Emacs as a text editor in this book since you can try most of the example code snippets in the book text by copying then and pasting them into a SBCL repl and by loading the book example source files directly into a repl. If you already use Emacs then I recommend that you do set up Slime sooner rather than later and start using it for development. If you are not already an Emacs user and do not mind spending the effort to learn Emacs, then search the web first for an Emacs tutorial. That said, you will be able to use the example code from this book just fine using any text editor you like with a SBCL repl. I don’t use the vi or vim editors but if vi is your weapon of choice for editing text then a web search for “common lisp vi vim repl” should get you going for developing Common Lisp code with vi or vim.

Here, we will assume that under Windows, Unix, Linux, or Mac OS X you will use one command window to run SBCL and a separate editor that can edit plain text files.

While reading the last section you (hopefully!) played with the SBCL interactive repl. If you haven’t played with the repl, I won’t get too judgmental except to say that if you do not play with the book examples as you read you will not get the full benefit from this book.

Did you notice that the backspace key does not work in the SBCL repl? The way to fix this is to install the GNU rlwrap utility. On OS X, assuming that you have homebrew installed, install rlwrap with:

If you are running Ubuntu Linux, install rlwrap using:

You can then create an alias for bash or zsh using something like the following to define a command rsbcl:

This is fine, just remember to run sbcl if you don’t need rlwrap command line editing or run rsbcl when you do need command line editing. That said, I find that I always want to run SBCL with command line editing, so I redefine sbcl on my computers using:

This alias is different on my laptops and servers, since I don’t usually install SBCL in the default installation directory. For each of my computers, I add an appropriate alias in my .zshrc file (if I am running zsh) or my .bashrc file (if I am running bash).

Although we will use SBCL in this book, any Common Lisp environment will do fine. In previous sections, we saw the top-level Lisp prompt and how we could type any expression that would be evaluated:

Notice that when we defined the function my-add-one in lines 7 and 8, we split the definition over two lines and on line 8 you don’t see the “*” prompt from SBCL – this lets you know that you have not yet entered a complete expression. The top level Lisp evaluator counts parentheses and considers a form to be complete when the number of closing parentheses equals the number of opening parentheses and an expression is complete when the parentheses match. I tend to count in my head, adding one for every opening parentheses and subtracting one for every closing parentheses – when I get back down to zero then the expression is complete. When we evaluate a number (or a variable), there are no parentheses, so evaluation proceeds when we hit a new line (or carriage return).

The Lisp reader by default tries to evaluate any form that you enter. There is a reader macro ‘ that prevents the evaluation of an expression. You can either use the ‘ character or quote:

Lisp supports both global and local variables. Global variables can be declared using defvar:

One thing to be careful of when defining global variables with defvar: the declared global variable is dynamically scoped. We will discuss dynamic versus lexical scoping later, but for now a warning: if you define a global variable avoid redefining the same variable name inside functions. Lisp programmers usually use a global variable naming convention of beginning and ending dynamically scoped global variables with the * character. If you follow this naming convention and also do not use the * character in local variable names, you will stay out of trouble. For convenience, I do not always follow this convention in short examples in this book.

Lisp variables have no type. Rather, values assigned to variables have a type. In this last example, the variable x was set to a string, then to a floating-point number. Lisp types support inheritance and can be thought of as a hierarchical tree with the type t at the top. (Actually, the type hierarchy is a DAG, but we can ignore that for now.) Common Lisp also has powerful object oriented programming facilities in the Common Lisp Object System (CLOS) that we will discuss in a later chapter.

Here is a partial list of types (note that indentation denotes being a subtype of the preceding type):

We can use the typep function to test the type of value of any variable or expression:

A useful feature of all ANSI standard Common Lisp implementations’ top-level listener is that it sets * to the value of the last expression evaluated. For example:

All Common Lisp environments set * to the value of the last expression evaluated. This example may be slightly confusing because * is also the prompt character in the SBCL repl that indicates that you can enter a new expression for evaluation. For example in line 3, the first * character is the repl prompt and the second * we type in to see that value of the previous expression that we typed into the repl.

Frequently, when you are interactively testing new code, you will call a function that you just wrote with test arguments; it is useful to save intermediate results for later testing. It is the ability to create complex data structures and then experiment with code that uses or changes these data structures that makes Lisp programming environments so effective.

Common Lisp is a lexically scoped language that means that variable declarations and function definitions can be nested and that the same variable names can be used in nested let forms; when a variable is used, the current let form is searched for a definition of that variable and if it is not found, then the next outer let form is searched. Of course, this search for the correct declaration of a variable is done at compile time so there need not be extra runtime overhead. We can nest defun special form inside each other and inside let expressions. We cam also use the special forms flet and labels to define functions inside a scoped environment. Functions defined inside a labels special form can be recursive while functions defined inside a flet special form can not be recursive. Consider the following example in the file nested.lisp (all example files are in the src directory):

We define a top level flet special form in lines 1-5 that defines two nested functions add-one and add-two and then calls each nested function in the body of the flet special form. For many years I have used nested defun special forms inside let expressions for defining local functions and you will notice this use in a few later examples. However, functions defined inside defun special forms have global visibility so they are not hidden in the local context where they are defined. The example of a nested defun in lines 7-12 shows that the function test2 has global visibility inside the current package.

Functions defined inside of a flet special form have access to variables defined in the outer scope containing the flet (also aplies to labels). We see this in lines 14-24 where the local variables x and y defined in the let expression are visible inside the function nested-function defined inside the flet.

Assuming that we started SBCL in the src directory we can then use the Lisp load function to evaluate the contents of the file nested.lisp using the load function:

The function load returned a value of t (prints in upper case as T) after successfully loading the file.

We will use Common Lisp vectors and arrays frequently in later chapters, but will also briefly introduce them here. A singly dimensioned array is also called a vector. Although there are often more efficient functions for handling vectors, we will just look at generic functions that handle any type of array, including vectors. Common Lisp provides support for functions with the same name that take different argument types; we will discuss this in some detail when we cover this in the later chapter on CLOS. We will start by defining three vectors v1, v2, and v3:

In line 1, we are defining a one-dimensional array, or vector, with three elements. In line 3 we specify the default value assigned to each element of the array v2. In line 5 I use the form for specifying array literals using the special character #. The function aref can be used to access any element in an array:

Notice how indexing of arrays is zero-based; that is, indices start at zero for the first element of a sequence. Also notice that array elements can be any Lisp data type. So far, we have used the special operator setq to set the value of a variable. Common Lisp has a generalized version of setq called setf that can set any value in a list, array, hash table, etc. You can use setf instead of setq in all cases, but not vice-versa. Here is a simple example:

When writing new code or doing quick programming experiments, it is often easiest (i.e., quickest to program) to use lists to build interesting data structures. However, as programs mature, it is common to modify them to use more efficient (at runtime) data structures like arrays and hash tables.

We will discuss symbols in more detail the Chapter on Common Lisp Packages. For now, it is enough for you to understand that symbols can be names that refer to variables. For example:

Note that the first defvar returns the defined symbol as its value. Symbols are almost always converted to upper case. An exception to this “upper case rule” is when we define symbols that may contain white space using vertical bar characters:

Lists are a fundamental data structure of Common Lisp. In this section, we will look at some of the more commonly used functions that operate on lists. All of the functions described in this section have something in common: they do not modify their arguments.

In Lisp, a cons cell is a data structure containing two pointers. Usually, the first pointer in a cons cell will point to the first element in a list and the second pointer will point to another cons representing the start of the rest of the original list.

The function cons takes two arguments that it stores in the two pointers of a new cons data structure. For example:

The first form evaluates to a cons data structure while the second evaluates to a cons data structure that is also a proper list. The difference is that in the second case the second pointer of the freshly created cons data structure points to another cons cell.

First, we will declare two global variables l1 and l2 that we will use in our examples. The list l1 contains five elements and the list l2 contains four elements:

You can also use the function list to create a new list; the arguments passed to function list are the elements of the created list:

The function car returns the first element of a list and the function cdr returns a list with its first element removed (but does not modify its argument):

Using combinations of car and cdr calls can be used to extract any element of a list:

Notice that we can combine calls to car and cdr into a single function call, in this case the function cadr. Common Lisp defines all functions of the form cXXr, cXXXr, and cXXXXr where X can be either a or d.

Suppose that we want to extract the value 5 from the nested list l1. Some experimentation with using combinations of car and cdr gets the job done:

The function last returns the last cdr of a list (i.e., the last element, in a list):

Common list supplies alternative functions to car and cdr that you might find more readable: first, second, third, fourth, and rest. Here are some examples:

The function nth takes two arguments: an index of a top-level list element and a list. The first index argument is zero based:

The function cons adds an element to the beginning of a list and returns as its value a new list (it does not modify its arguments). An element added to the beginning of a list can be any Lisp data type, including another list:

The function append takes two lists as arguments and returns as its value the two lists appended together:

A frequent error that beginning Lisp programmers make is not understanding shared structures in lists. Consider the following example where we generate a list y by reusing three copies of the list x:

When we change the shared structure referenced by the variable x that change is reflected three times in the list y. When we create the list stored in the variable z we are not using a shared structure.

Using lists is easy but the time spent accessing a list element is proportional to the length of the list. Arrays and vectors are more efficient at runtime than long lists because list elements are kept on a linked-list that must be searched. Accessing any element of a short list is fast, but for sequences with thousands of elements, it is faster to use vectors and arrays.

By default, elements of arrays and vectors can be any Lisp data type. There are options when creating arrays to tell the Common Lisp compiler that a given array or vector will only contain a single data type (e.g., floating point numbers) but we will not use these options in this book.

Vectors are a specialization of arrays; vectors are arrays that only have one dimension. For efficiency, there are functions that only operate on vectors, but since array functions also work on vectors, we will concentrate on arrays. In the next section, we will look at character strings that are a specialization of vectors.

We could use the generalized make-sequence function to make a singularly dimensioned array (i.e., a vector). Restart sbcl and try:

In this example, notice the print format for vectors that looks like a list with a proceeding # character. As seen in the last section, we use the function make-array to create arrays:

Notice the print format of an array: it looks like a list proceeded by a # character and the integer number of dimensions.

Instead of using make-sequence to create vectors, we can pass an integer as the first argument of make-array instead of a list of dimension values. We can also create a vector by using the function vector and providing the vector contents as arguments:

The function aref is used to access sequence elements. The first argument is an array and the remaining argument(s) are array indices. For example:

It is likely that even your first Lisp programs will involve the use of character strings. In this section, we will cover the basics: creating strings, concatenating strings to create new strings, for substrings in a string, and extracting substrings from longer strings. The string functions that we will look at here do not modify their arguments; rather, they return new strings as values. For efficiency, Common Lisp does include destructive string functions that do modify their arguments but we will not discuss these destructive functions here.

We saw earlier that a string is a type of vector, which in turn is a type of array (which in turn is a type of sequence). A full coverage of the Common Lisp type system is outside the scope of this tutorial introduction to Common Lisp; a very good treatment of Common Lisp types is in Guy Steele’s “Common Lisp, The Language” which is available both in print and for free on the web. Many of the built in functions for handling strings are actually more general because they are defined for the type sequence. The Common Lisp Hyperspec is another great free resource that you can find on the web. I suggest that you download an HTML version of Guy Steele’s excellent reference book and the Common Lisp Hyperspec and keep both on your computer. If you continue using Common Lisp, eventually you will want to read all of Steele’s book and use the Hyperspec for reference.

The following text was captured from input and output from a Common Lisp repl. First, we will declare two global variables s1 and space that contain string values:

One of the most common operations on strings is to concatenate two or more strings into a new string:

Notice that the first argument of the function concatenate is the type of the sequence that the function should return; in this case, we want a string. Another common string operation is search for a substring:

If the search string (first argument to function search) is not found, function search returns nil, otherwise search returns an index into the second argument string. Function search takes several optional keyword arguments (see the next chapter for a discussion of keyword arguments):

For our discussion, we will just use the keyword argument :start2 for specifying the starting search index in the second argument string and the :from-end flag to specify that search should start at the end of the second argument string and proceed backwards to the beginning of the string:

The sequence function subseq can be used for strings to extract a substring from a longer string:

Here, the second argument specifies the starting index; the substring from the starting index to the end of the string is returned. An optional third index argument specifies one greater than the last character index that you want to extract:

It is frequently useful to remove white space (or other) characters from the beginning or end of a string:

The character #\space is the space character. Other common characters that are trimmed are #\tab and #

ewline. There are also utility functions for making strings upper or lower case:

We have not yet discussed equality of variables. The function eq returns true if two variables refer to the same data in memory. The function eql returns true if the arguments refer to the same data in memory or if they are equal numbers or characters. The function equal is more lenient: it returns true if two variables print the same when evaluated. More formally, function equal returns true if the car and cdr recursively equal to each other. An example will make this clearer:

For strings, the function string= is slightly more efficient than using the function equal:

Common Lisp strings are sequences of characters. The function char is used to extract individual characters from a string:

Hash tables are an extremely useful data type. While it is true that you can get the same effect by using lists and the assoc function, hash tables are much more efficient than lists if the lists contain many elements. For example:

The second argument to function assoc is a list of cons cells. Function assoc searches for a sub-list (in the second argument) that has its car (i.e., first element) equal to the first argument to function assoc. The perhaps surprising thing about this example is that assoc seems to work with an integer as the first argument but not with a string. The reason for this is that by default the test for equality is done with eql that tests two variables to see if they refer to the same memory location or if they are identical if they are numbers. In the last call to assoc we used “:test #’equal” to make assoc use the function equal to test for equality.

The problem with using lists and assoc is that they are very inefficient for large lists. We will see that it is no more difficult to code with hash tables.

A hash table stores associations between key and value pairs, much like our last example using the assoc function. By default, hash tables use eql to test for equality when looking for a key match. We will duplicate the previous example using hash tables:

Notice that gethash returns multiple values: the first value is the value matching the key passed as the first argument to function gethash and the second returned value is true if the key was found and nil otherwise. The second returned value could be useful if hash values are nil.

Since we have not yet seen how to handle multiple returned values from a function, we will digress and do so here (there are many ways to handle multiple return values and we are just covering one of them):

Assuming that variables a and b are already declared, the variable a will be set to the first returned value from gethash and the variable b will be set to the second returned value.

If we use symbols as hash table keys, then using eql for testing for equality with hash table keys is fine:

However, we saw that eql will not match keys with character string values. The function make-hash-table has optional key arguments and one of them will allow us to use strings as hash key values:

Here, we are only interested in the first optional key argument :test that allows us to use the function equal to test for equality when matching hash table keys. For example:

It is often useful to be able to enumerate all the key and value pairs in a hash table. Here is a simple example of doing this by first defining a function my-print that takes two arguments, a key and a value. We can then use the maphash function to call our new function my-print with every key and value pair in a hash table:

The function my-print is applied to each key/value pair in the hash table. There are a few other useful hash table functions that we demonstrate here:

The function hash-table-count returns the number of key and value pairs in a hash table. The function remhash can be used to remove a single key and value pair from a hash table. The function clrhash clears out a hash table by removing all key and value pairs in a hash table.

It is interesting to note that clrhash and remhash are the first Common Lisp functions that we have seen so far that modify any of its arguments, except for setq and setf that are macros and not functions.

We have seen how we can type arbitrary Lisp expressions in the Lisp repl listener and then they are evaluated. We will see in the Chapter on Input and Output that the Lisp function read evaluates lists (or forms) and indeed the Lisp repl uses function read.

In this section, we will use the function eval to evaluate arbitrary Lisp expressions inside a program. As a simple example:

Using the function eval, we can build lists containing Lisp code and evaluate generated code inside our own programs. We get the effect of “data is code”. A classic Lisp program, the OPS5 expert system tool, stored snippets of Lisp code in a network data structure and used the function eval to execute Lisp code stored in the network. A warning: the use of eval is likely to be inefficient in non-compiled code. For efficiency, the OPS5 program contained its own version of eval that only interpreted a subset of Lisp used in the network.

I usually use Emacs, but we will briefly discuss the editor vi also. If you use vi (e.g., enter “vi nested.lisp”) the first thing that you should do is to configure vi to indicate matching opening parentheses whenever a closing parentheses is typed; you do this by typing “:set sm” after vi is running.

If you choose to learn Emacs, enter the following in your .emacs file (or your _emacs file in your home directory if you are running Windows):

Now, whenever you open a file with the extension of “lisp”, “lsp”, or “cl” (for “Common Lisp”) then Emacs will automatically use a Lisp editing mode. I recommend searching the web using keywords “Emacs tutorial” to learn how to use the basic Emacs editing commands - we will not repeat this information here.

I do my professional Lisp programming using free software tools: Emacs, SBCL, Clozure Common Lisp, and Clojure. I will show you how to configure Emacs and Slime in the last section of the Chapter on Quicklisp.

When you enter forms (or expressions) in a Lisp repl listener, you will occasionally make a mistake and an error will be thrown. Here is an example where I am not showing all of the output when entering help when an error is thrown:

Here, I first used the backtrace command :bt to print the sequence of function calls that caused the error. If it is obvious where the error is in the code that I am working on then I do not bother using the backtrace command. I then used the abort command :a to recover back to the top level Lisp listener (i.e., back to the greater than prompt). Sometimes, you must type :a more than once to fully recover to the top level greater than prompt.

Like other languages like Java and Python, Common Lisp provides garbage collection (GC) or automatic memory management.

In simple terms, GC occurs to free memory in a Lisp environment that is no longer accessible by any global variable (or function closure, which we will cover in the next chapter). If a global variable *variable-1* is first set to a list and then if we later then set *variable-1* to, for example nil, and if the data referenced in the original list is not referenced by any other accessible data, then this now unused data is subject to GC.

In practice, memory for Lisp data is allocated in time ordered batches and ephemeral or generational garbage collectors garbage collect recent memory allocations far more often than memory that has been allocated for a longer period of time.

When you start using Common Lisp for large projects, you will likely have many files to load into your Lisp environment when you start working. Most Common Lisp implementations have a function called defsystem that works somewhat like the Unix make utility. While I strongly recommend defsystem for large multi-person projects, I usually use a simpler scheme when working on my own: I place a file loadit.lisp in the top directory of each project that I work on. For any project, its loadit.lisp file loads all source files and initializes any global data for the project.

Another good technique is to create a Lisp image containing all the code and data for all your projects. There is an example of this in the first section of the Chapter on NLP. In this example, it takes a few minutes to load the code and data for my NLP (natural language processing) library so when I am working with it I like to be able to quickly load a SBCL Lisp image.

All Common Lisp implementations have a mechanism for dumping a working image containing code and data.

There are two main styles for doing Common Lisp development. Object oriented programming is well supported (see the Chapter on CLOS) as is functional programming. In a nut shell, functional programming means that we should write functions with no side effects. First let me give you a non-functional example with side effects:

This example using CLOS is non-functional because we modify the value of an argument to the function. Some functional languages like the Lisp Clojure language and the Haskell language dissuade you from modifying arguments to functions. With Common Lisp you should make a decision on which approach you like to use.

Functional programming means that we avoid maintaining state inside of functions and treat data as immutable (i.e., once an object is created, it is never modified). We could modify the last example to be function by creating a new car object inside the function, copy the attributes of the car passed as an object, change the color to “red” of the new car object, and return the new car instance as the value of the function.

Functional programming prevents many types of programming errors, makes unit testing simpler, and makes programming for modern multi-core CPUs easier because read-only objects are inherently thread safe. Modern best practices for the Java language also prefer immutable data objects and a functional approach.

In the previous chapter, we defined a few simple functions. In this chapter, we will discuss how to write functions that take a variable number of arguments, optional arguments, and keyword arguments.

The special form defun is used to define new functions either in Lisp source files or at the top level Lisp listener prompt. Usually, it is most convenient to place function definitions in a source file and use the function load to load them into our Lisp working environment.

In general, it is bad form to use global variables inside Lisp functions. Rather, we prefer to pass all required data into a function via its argument list and to get the results of the function as the value (or values) returned from a function. Note that if we do require global variables, it is customary to name them with beginning and ending * characters; for example:

Then in this example, if you see the variable *lexical-hash-table* inside a function definition, you will know that at least by naming convention, that this is a global variable.

In Chapter 1, we saw an example of using lexically scoped local variables inside a function definition (in the example file nested.lisp).

There are several options for defining the arguments that a function can take. The fastest way to introduce the various options is with a few examples.

First, we can use the &aux keyword to declare local variables for use in a function definition:

It is considered better coding style to use the let special operator for defining auxiliary local variables; for example:

You will probably not use &aux very often, but there are two other options for specifying function arguments: &optional and &key.

The following code example shows how to use optional function arguments. Note that optional arguments must occur after required arguments.

In this example, the optional argument b was not given a default value so if unspecified it will default to nil. The optional argument c is given a default value of 123.

We have already seen the use of keyword arguments in built-in Lisp functions. Here is an example of how to specify key word arguments in your functions:

It is often useful to define unnamed functions. We can define an unnamed function using lambda; for example, let’s look at the example file src/lambda1.lisp. But first, we will introduce the Common Lisp function funcall that takes one or more arguments; the first argument is a function and any remaining arguments are passed to the function bound to the first argument. For example:

In the first two calls to funcall here, we simply quote the function name that we want to call. In the third example, we use a better notation by quoting with #’. We use the #’ characters to quote a function name. Here is the example file src/lambda1.lisp:

Here, we define a function using lambda and set the value of the local variable my-func to the unnamed function’s value. Here is output from the function test:

The ability to use functions as data is surprisingly useful. For now, we will look at a simple example:

Notice that the second call to function testfn prints “100” twice: the first time as a side effect of calling the function print and the second time as the returned value of testfn (the function print returns what it is printing as its value).

Later, we will see how to use special Common Lisp macros for programming repetitive loops. In this section, we will use recursion for both coding simple loops and as an effective way to solve a variety of problems that can be expressed naturally using recursion.

As usual, the example programs for this section are found in the src directory. In the file src/recursion1.lisp, we see our first example of recursion:

This example is simple, but it is useful for discussing a few points. First, notice how the function recursion1 calls itself with an argument value of one greater than its own input argument only if the input argument “value” is less than 5. This test keeps the function from getting in an infinite loop. Here is some sample output:

Why did the call on line 24 not loop via recursion? Because the input argument is not less than 5, no recursion occurs.

We have seen that functions can take other functions as arguments and return new functions as values. A function that references an outer lexically scoped variable is called a closure. The example file src/closure1.lisp contains a simple example:

Here the function fortune is defined inside a let form. Because the local variable fortunes is referenced inside the function fortune, the variable fortunes exists after the let form is evaluated. It is important to understand that usually a local variable defined inside a let form “goes out of scope” and can no longer be referenced after the let form is evaluated.

However, in this example, there is no way to access the contents of the variable fortunes except by calling the function fortune. At a minimum, closures are a great way to hide variables. Here is some output from loading the src/closure1.lisp file and calling the function fortune several times:

For several decades managing packages and libraries was a manual process when developing Lisp systems. I used to package the source code for specific versions of libraries as part of my Common Lisp projects. Early package management systems mk-defsystem and ASDF were very useful, but I did not totally give up my practice keeping third party library source code with my projects until Zach Beane created the Quicklisp package system. You will need to have Quicklisp installed for many of the examples later in this book so please take the time to install it right now as per the instructions on the Quicklisp web site.

We will need the Common Lisp Hunchentoot library later in the Chapter on Network Programming so we will install it now using Quicklisp.

We already know the package name we want, but let’s start by using Quicklisp to search for all packages with “hunchentoot” in the package name:

We want the base package seen in line 3 and we can install the base package as seen in the following example:

In line 1, I refer to the package name using a symbol :hunchentoot but using the string “hunchentoot” would have worked the same. The first time you ql:quickload a library you may see additional printout. In most of the rest of this book, when I install or use a package by calling the ql:quickload function I do not show the output from this function when in the repl listings.

Now, we can use the fantastically useful Common Lisp function apropos to see what was just installed:

As long as you are thinking about the new tool Quicklisp that is now in your tool chest, you should install the rest of the packages and libraries that you will need for working through the rest of this book. I will show the statements needed to load more libraries without showing the output printed in the repl as each package is loaded:

You need to have the Postgres and MySQL client developer libraries installed on your system for the clsql-postgresql and clsql-mysql installations to work.

I assume that you have Emacs installed on your system. In a repl you can setup the Slime package that allows Emacs to connect to a running Lisp environment:

Pay attention to the output in the repl. On my system the output contained the following:

If you installed rlwrap and defined an alias for running SBCL, make sure you set the inferior lisp program to the absolute path of the SBCL executable; on my system I set the following in my .emacs file:

I am not going to cover using Emacs and Slime: there are many good tutorials on the web you can read.

We saw in the last chapter how the Lisp function eval could be used to evaluate arbitrary Lisp code stored in lists. Because eval is inefficient, a better way to generate Lisp code automatically is to define macro expressions that are expanded inline when they are used. In most Common Lisp systems, using eval requires the Lisp compiler to compile a form on-the-fly which is not very efficient. Some Lisp implementations use an interpreter for eval which is likely to be faster but might lead to obscure bugs if the interpreter and compiled code do not function identically.

The file src/macro1.lisp contains both a simple macro and a function that uses the macro. This macro example is a bit contrived since it could be just a function definition, but it does show the process of creating and using a macro. We are using the gensym function to define a new unique symbol to reference a temporary variable:

The backquote character seen at the beginning of line 5 is used to quote a list in a special way: nothing in the list is evaluated during macro expansion unless it is immediately preceded by a comma character. In this case, we specify ,a-list because we want the value of the macro’s argument a-list to be substituted into the specially quoted list. We will look at dolist in some detail in the next chapter but for now it is sufficient to understand that dolist is used to iterate through the top-level elements of a list, for example:

Returning to our macro example in the file src/macro1.lisp, we will try the function test that uses the macro double-list:

Another similar example is in the file src/macro2.lisp:

Here, the splicing operator ,@ is used to substitute in the list args in the macro double-args.

The function macroexpand-1 is used to transform macros with arguments into new Lisp expressions. For example:

Writing macros is an effective way to extend the Lisp language because you can control the code passed to the Common Lisp compiler. In both macro example files, when the function test was defined, the macro expansion is done before the compiler processes the code. We will see in the next chapter several useful macros included in Common Lisp.

We have only “scratched the surface” looking at macros; the interested reader is encouraged to search the web using, for example, “Common Lisp macros.”

In this chapter, we will discuss several useful macros for performing iteration (we saw how to use recursion for iteration in Chapter 2):

We saw a quick example of dolist in the last chapter. The arguments of the dolist macro are:

Usually, the dolist macro returns nil as its value, but we can add a third optional argument which will be returned as the generated expression’s value; for example:

The first argument to the dolist macro is a local lexically scoped variable. Once the code generated by the dolist macro finishes executing, this variable is undefined.

The dotimes macro is used when you need a loop with an integer loop index. The arguments of the dotimes macro are:

Usually, the dotimes macro returns nil as its value, but we can add a third optional argument that will be returned as the generated expression’s value; for example:

As with the dolist macro, you will often use a let form inside a dotimes macro to declare additional temporary (lexical) variables.

The do macro is more general purpose than either dotimes or dolist but it is more complicated to use. Here is the general form for using the do looping macro:

There is a similar macro do* that is analogous to let* in that loop variable values can depend on the values or previously declared loop variable values.

As a simple example, here is a loop to print out the integers from 0 to 3. This example is in the file src/do1.lisp:

;; example do macro use

In this example, we only declare one loop variable so we might as well as used the simpler dotimes macro.

Here we load the file src/do1.lisp:

You will notice that we do not see the return value of the do loop (i.e., the string “value-of-do-loop”) because the top-level form that we are evaluating is a call to the function load; we do see the return value of load printed. If we had manually typed this example loop in the Lisp listener, then you would see the final value value-of-do-loop printed.

We previousely used dolist to iterate over elements in lists. For efficiency we will often use vectors (one dimensinal arrays) and we can use loop to similarly handle vectors:

where testdata is a one dimensional array (a vector) and inside the do block the local variable td is assigned to each element in the vector.

In the simple examples that we have seen so far, all newly created Lisp symbols have been placed in the default package. You can always check the current package by evaluating the expression package:

As we will use in the following example, the package :cl is an alias for :common-lisp-user.

We will define a new package :my-new-package and two functions foo1 and foo2 inside the package. Externally to this package, assuming that it is loaded, we can access foo2 using my-new-package:foo2. foo1 is not exported so it can not be accessed this way. However, once again assuming this package is loaded, we can always start a symbol name with a package name and two colon characters if we want to use a symbol defined in another package so we can use my-new-package::foo1.

When I leave package :my-new-package in line 22 and return to package :cl, and try to access my-new-package:foo1 notice that an error is thrown.

On line 3 we define the alias :p1 for the packkage :my-new-package and we use this alias in line 44.

Since we specified a nickname in the defpackage expression, Common Lisp uses the nickname (in this case P1 in calling function foo2 that is exported from package :my-new-package.

Near the end of the last example, we switched back to the default package COMMON-LISP-USER so we had to specify the package name for the function foo2.

When you are writing very large Common Lisp programs, it is useful to be able to break up the program into different modules and place each module and all its required data in different name spaces by creating new packages. Remember that all symbols, including variables, generated symbols, CLOS methods, functions, and macros are in some package.

When I use a package I usually place everything in the package in a single source file. I put a defpackage expression at the top of the file immediately followed by an in-package expression to switch to the new package. Note that whenever a new file is loaded into a Lisp environment, the current package is set back to the default package COMMON-LISP-USER.

Since the use of packages is a common source of problems for new users, you might want to “put off” using packages until your Common Lisp programs become large enough to make the use of packages effective.

We will see that the input and output of Lisp data is handled using streams. Streams are powerful abstractions that support common libraries of functions for writing to the terminal, to files, to sockets, and to strings.

In all cases, if an input or output function is called without specifying a stream, the default for input stream is *standard-input* and the default for output stream is *standard-output*. These defaults streams are connected to the Lisp listener that we discussed in Chapter 2.

The function read is used to read one Lisp expression. Function read stops reading after reading one expression and ignores new line characters. We will look at a simple example of reading a file test.dat using the example Lisp program in the file read-test-1.lisp. Both of these files, as usual, can be found in the directory src that came bundled with this web book. Start your Lisp program in the src directory. The contents of the file test.dat is:

In the function read-test-1, we use the macro with-open-file to read from a file. To write to a file (which we will do later), we can use the keyword arguments :direction :output. The first argument to the macro with-open-file is a symbol that is bound to a newly created input stream (or an output stream if we are writing a file); this symbol can then be used in calling any function that expects a stream argument.

Notice that we call the function read with three arguments: an input stream, a flag to indicate if an error should be thrown if there is an I/O error (e.g., reaching the end of a file), and the third argument is the value that function read should return if the end of the file (or stream) is reached. When calling read with these three arguments, either the next expression from the file test.dat will be returned, or the value nil will be returned when the end of the file is reached. If we do reach the end of the file, the local variable x will be assigned the value nil and the function return will break out of the dotimes loop. One big advantage of using the macro with-open-file over using the open function (which we will not cover) is that the file stream is automatically closed when leaving the code generated by the with-open-file macro. The contents of file read-test-1.lisp is:

Here is the output that you will see if you load the file read-test-1.lisp and execute the expression (read-test-1):

Note: the string “the cat bit the rat” prints as a string (with quotes) because we used a ~S instead of a ~A in the format string in the call to function format.

In this last example, we passed the file name as a string to the macro with-open-file. This is not generally portable across all operating systems. Instead, we could have created a pathname object and passed that instead. The pathname function can take eight different keyword arguments, but we will use only the two most common in the example in the file read-test-2.lisp in the src directory. The following listing shows just the differences between this example and the last:

Here, we are specifying that we should look for the for the file test.dat in the subdirectory testdata. Note: I almost never use pathnames. Instead, I specify files using a string and the character / as a directory delimiter. I find this to be portable for the Macintosh, Windows, and Linux operating systems using all Common Lisp implementations.

The file readline-test.lisp is identical to the file read-test-1.lisp except that we call function readline instead of the function read and we change the output format message to indicate that an entire line of text has been read

When we execute the expression (readline-test), notice that the string contained in the second line of the input file has the quote characters escaped:

We can also create an input stream from the contents of a string. The file read-from-string-test.lisp is very similar to the example file read-test-1.lisp except that we use the macro with-input-from-string (notice how I escaped the quote characters used inside the test string):

We see the following output when we load the file read-from-string-test.lisp:

We have seen how the stream abstraction is useful for allowing the same operations on a variety of stream data. In the next section, we will see that this generality also applies to the Lisp printing functions.

All of the printing functions that we will look at in this section take an optional last argument that is an output stream. The exception is the format function that can take a stream value as its first argument (or t to indicate *standard-output*, or a nil value to indicate that format should return a string value).

Here is an example of specifying the optional stream argument:

The function print prints Lisp objects so that they can (usually) be read back using function read. The corresponding function princ is used to print for “human consumption”. For example:

Both print and princ return their first argument as their return value, which you see in the previous output. Notice that princ also does not print a new line character, so princ is often used with terpri (which also takes an optional stream argument).

We have also seen many examples in this web book of using the format function. Here is a different use of format, building a string by specifying the value nil for the first argument:

We have not yet seen an example of writing to a file. Here, we will use the with-open-file macro with options to write a file and to delete any existing file with the same name:

Here is the result of evaluating this expression (i.e., the contents of the newly created file test1.dat in the src directory):

Notice that print generates a new line character before printing its argument.

We will use Zach Beane’s vecto library for plotting data with the results written to files. Ideally we would like to have interactive plotting capability but for the purposes of this book I need to support the combinations of all Common Lisp implementations on multiple operating systems. Interactive plotting libraries are usually implementation and OS dependent.

The examples here are all contained in the source file plotlib.lisp and this code will be used in later chapters.

When I work on my macOS laptop, I leave the output graphics file open in the Preview App and whenever I rerun a program producing graphics in the REPL, making the preview App window active refreshes the graphics display.

The following listing shows the file plotlib.lisp that is a simple wrapper for the vecto Common Lisp plotting library. Please note that I only implemented wrappers for vecto functionality that I need for later examples in this book, so the following code is not particularly general but should be easy enough for you to extend for the specific needs of your projects.

This plot library is used in later examples in the chapters on search, backpropagation neural networks and Hopfield neural networks. I prefer using implementation and operating specific ploting libraires for generating interactive plots but the advantage of writing plot data to a file using the vecto library is that the code is portable across operating systems and Common Lisp implementations.

CLOS was the first ANSI standardized object oriented programming facility. While I do not use classes and objects as often in my Common Lisp programs as I do when using Java and Smalltalk, it is difficult to imagine a Common Lisp program of any size that did not define and use at least a few CLOS classes.

The example program for this chapter in the file src/HTMLstream.lisp. I used this CLOS class about ten years ago in a demo for my commercial natural language processing product to automatically generate demo web pages.

We are going to start our discussion of CLOS somewhat backwards by first looking at a short test function that uses the HTMLstream class. Once we see how to use this example CLOS class, we will introduce a small subset of CLOS by discussing in some detail the implementation of the HTMLstream class and finally, at the end of the chapter, see a few more CLOS programming techniques. This book only provides a brief introduction to CLOS; the interested reader is encouraged to do a web search for “CLOS tutorial”.

The macros and functions defined to implement CLOS are a standard part of Common Lisp. Common Lisp supports generic functions, that is, different functions with the same name that are distinguished by different argument types.

The file src/HTMLstream.lisp contains a short test program at the end of the file:

The generic function make-instance takes the following arguments:

There are four generic functions used in the function test:

The first thing to notice in the function test is that the first argument for calling each of these generic functions is an instance of the class HTMLstream. You are free to also define a function, for example, add-element that does not take an instance of the class HTMLstream as the first function argument and calls to add-element will be routed correctly to the correct function definition.

We will see that the macro defmethod acts similarly to defun except that it also allows us to define many methods (i.e., functions for a class) with the same function name that are differentiated by different argument types and possibly different numbers of arguments.

The class HTMLstream is very simple and will serve as a reasonable introduction to CLOS programming. Later we will see more complicated class examples that use multiple inheritance. Still, this is a good example because the code is simple and the author uses this class frequently (some proof that it is useful!). The code fragments listed in this section are all contained in the file src/HTMLstream.lisp. We start defining a new class using the macro defclass that takes the following arguments:

The class definition for HTMLstream is fairly simple:

Here, the class name is HTMLstream, the list of super classes is an empty list (), the list of slot specifications contains only one slot specification for the slot out and there is only one class specification: a documentation string. Most CLOS classes inherit from at least one super class but we will wait until the next section to see examples of inheritance. There is only one slot (or instance variable) and we define an accessor variable with the same name as the slot name. This is a personal preference of mine to name read/write accessor variables with the same name as the slot.

The method set-header initializes the string output stream used internally by an instance of this class. This method uses convenience macro with-accessors that binds a local set of local variable to one or more class slot accessors. We will list the entire method then discuss it:

The first interesting thing to notice about the defmethod is the argument list: there are two arguments ho and title but we are constraining the argument ho to be either a member of the class HTMLstream or a subclass of HTMLstream. Now, it makes sense that since we are passing an instance of the class HTMLstream to this generic function (or method – I use the terms “generic function” and “method” interchangeably) that we would want access to the slot defined for this class. The convenience macro with-accessors is exactly what we need to get read and write access to the slot inside a generic function (or method) for this class. In the term ((out out)), the first out is local variable bound to the value of the slot named out for this instance ho of class HTMLstream. Inside the with-accessors macro, we can now use setf to set the slot value to a new string output stream. Note: we have not covered the Common Lisp type string-output-stream yet in this web book, but we will explain its use on the next page.

By the time a call to the method set-header (with arguments of an HTMLstream instance and a string title) finishes, the instance has its slot set to a new string-output-stream and HTML header information is written to the newly created string output stream. Note: this string output stream is now available for use by any class methods called after set-header.

There are several methods defined in the file src/HTMLstream.lisp, but we will look at just four of them: add-H1, add-element, add-table, and get-html-string. The remaining methods are very similar to add-H1 and the reader can read the code in the source file.

As in the method set-header, the method add-H1 uses the macro with-accessors to access the stream output stream slot as a local variable out. In add-H1 we use the function princ that we discussed in Chapter on Input and Output to write HTML text to the string output stream:

The method add-element is very similar to add-H1 except the string passed as the second argument element is written directly to the stream output stream slot:

The method add-table converts a list of lists into an HTML table. The Common Lisp function princ-to-string is a useful utility function for writing the value of any variable to a string. The functions string-left-trim and string-right-trim are string utility functions that take two arguments: a list of characters and a string and respectively remove these characters from either the left or right side of a string. Note: another similar function that takes the same arguments is string-trim that removes characters from both the front (left) and end (right) of a string. All three of these functions do not modify the second string argument; they return a new string value. Here is the definition of the add-table method:

The method get-html-string gets the string stored in the string output stream slot by using the function get-output-stream-string:

CLOS is a rich framework for object oriented programming, providing a superset of features found in languages like Java, Ruby, and Smalltalk. I have barely scratched the surface in this short CLOS example for generating HTML. Later in the book, whenever you see calls to make-instance that lets you know we are using CLOS even if I don’t specifically mention CLOS in the examples.

We represent search space as a graph: nodes and links between the nodes. The following figure shows the simple graph that we use as an example, finding a route from node n1 to node n11:

The following example code uses a heuristic for determining which node to try first from any specific location: move to the node that is closest spatially to the goal node. We see that this heuristic will not always work to produce the most efficient search but we will still get to the goal node. As an example in which the heuristic does not work, consider when we start at node n1 in the lower left corner of the figure. The search algorithm can add nodes n2 and n4 to the nodes to search list and will search using node n4 first since n4 is closer to the goal node n11 than node n2. In this case, the search will eventually need to back up trying the path n1 to n2. Despite this example of the heuristic not working to decrease search time, in general, for large search spaces (i.e., graphs with many nodes and edges) it can dramatically decrease search time.

The main function Asearch** starting in line 5 extends to line 151 because all search utility functions are nested (lexically scoped) inside the mani function. The actual code for the main function **Asearch is in lines 150 and 151.

The data representing nodes in this implementation is globally scoped (see the definitions on lines 155-165 in the “throw away test code” near the bottom of the file) and we set the property path-list to store the nodes directy connected to each node (set in function init-path-list in lines 36-52). I originally wrote this code in 1990 which explains it non-functional style using globally scoped node variables.

The following example in the repl shows the calculation of the path that we saw in the figure of the graph search space.

There are many types of search: breadth first as we used here, depth first, with heuristics to optimize search dependent on the type of search space.

Distributed computing is pervasive: you need to look no further than the World Wide Web, Internet chat, etc. Of course, as a Lisp programmer, you will want to do at least some of your network programming in Lisp! The previous editions of this book provided low level socket network programming examples. I decided that for this new edition, I would remove those examples and instead encourage you to “move further up the food chain” and work at a higher level of abstraction that makes sense for the projects you will likely be developing. Starting in the 1980s, a lot of my work entailed low level socket programming for distributed networked applications. As I write this, it is 2013, and there are better ways to structure distributed applications.

Specifically, since many of the examples later in this book fetch information from the web and linked data sources, we will start be learning how to use Edi Weitz’s Drakma HTTP client library. In order to have a complete client server example we will also look briefly at Edi Weitz’s Hunchentoot web server that uses JSON as a data serialization format. I used to use XML for data serialization but JSON has many advantages: easier for a human to read and it plays nicely with Javascript code and some data stores like Postgres (new in versions 9.x), MongoDB, and CouchDB that support JSON as a native data format.

The code snippets in the first two sections of this chapter are derived from examples in the Drackma and Hunchentoot documentation.

Edi Weitz’s Drakma library supports fetching data via HTTP requests. As you can see in the Drakma documentation, you can use this library for authenticated HTTP requests (i.e., allow you to access web sites that require a login), support HTTP GET and PUT operations, and deal with cookies. The top level API that we will use is drakma:http-request that returns multiple values. In the following example, I want only the first three values, and ignore the others like the original URI that was fetched and an IO stream object. We use the built-in Common Lisp macro multiple-value-setq:

I manually formatted the last statement I entered in the last repl listing and I will continue to manually edit the repl listings in the rest of this book to make them more easily readable.

The following shows some of the data bound to the variables data, http-response-code, and headers:

The value of http-response-code is 200 which means that there were no errors:

The HTTP response headers will be useful in many applications; for fetching the home page of my web site the headers are:

We will use Drakma later in this book for several examples. In the next section we will write a web app using Hunchentoot and test it with a Drakma client.

Edi Weitz’s Hunchentoot project is a flexible library for writing web applications and web services. We will also use Edi’s CL-WHO library in this section for generating HTML from Lisp code. Hunchentoot will be installed the first time you quick load it in the example code for this section:

I will use only easy handler framework in the Hunchentoot examples in this section. I leave it to you to read the documentation on using custom acceptors after you experiment with the examples in this section.

The following code will work for both multi-threading installations of SBCL and single thread installations (e.g., some default installations of SBCL on OS X):

In lines 5 through 9 we create an use a new package that includes support for generating HTML in Lisp code (CL-WHO) and the Hunchentoot library). On line 11 we create an instance of an easy acceptor on port 3000 that provides useful default behaviors for providing HTTP services.

The Hunchentoot macro define-easy-handler is used in lines 15 through 28 to define an HTTP request handler and add it to the easy acceptor instance. The first argument, my-greetings in this example, is an arbitrary name and the keyword :uri argument provides a URL pattern that the easy acceptor server object uses to route requests to this handler. For example, when you run this example on your computer, this URL routing pattern would handle requests like:

In lines 17 through 28 we are using the CL-WHO library to generate HTML for a web page. As you might guess, :html generates the outer <html></html> tags for a web page. Line 19 would generate HTML like:

Lines 22 through 27 generate an HTML input form and line 28 displays any value generated when the user entered text in the input filed and clicked the submit button. Notice the definition of the argument name in line 1 in the definition of the easy handler. If the argument name is not defined, the nil value will be displayed in line 28 as an empty string.

You should run this example and access the generated web page in a web browser, and enter text, submit, etc. You can also fetch the generated page HTML using the Drakma library that we saw in the last section. Here is a code snippet using the Drakma client library to access this last example:

We will use both Drackma and Hunchentoot in the next section.

A reasonable way to build modern distributed systems is to write REST web services that serve JSON data to client applications. These client applications might be rich web apps written in Javascript, other web services, and applications running on smartphones that fetch and save data to a remote web service.

We will use the cl-json Quicklisp package to encode Lisp data into a string representing JSON encoded data. Here is a quick example:

The following list shows the contents of the file src/web-hunchentoot-json.lisp:

This example is very similar to the web application example in the last section. The difference is that this application is not intended to be viewed on a web page because it returns JSON data as HTTP responses. The easy handler definition on line 8 specifies a handler argument name. In lines 12 and 19 we check to see if the value of the argument name is “cat” or “dog” and if it is, we return the appropriate JSON example data for those animals. If there is no match, the default cond clause starting on line 26 returns a warning string as a JSON encoded string.

While running this test service, in one repl, you can ue the Drakma library in another repl to test it (not all output is shown in the next listing):

You can use the cl-json library to decode a string containing JSON data to Lisp data:

For most of my work, REST web services are “read-only” in the sense that clients don’t modify state on the server. However, there are use cases where a client application might want to; for example, letting clients add new animals to the last example.

In line 4 we are defining an additional easy handler with a handler argument json-data. This data is assumed to be a string encoding of JSON data which is decoded into Lisp data in lines 6 and 7. We save the data to the global variable animal-hash.

In this example, we are storing data sent from a client in an in-memory hash table. In a real application new data might be stored in a database.

There are good options for accessing relational databases from Common Lisp. Personally I almost always use Postgres and in the past I used either native foreign client libraries or the socket interface to Postgres. Recently, I decided to switch to CLSQL which provides a common interface for accessing Postgres, MySQL, SQLite, and Oracle databases. There are also several recent forks of CLSQL on github. We will use CLSQL in examples in this book. Hopefully while reading the Chapter on Quicklisp you installed CLSQL and the back end for one or more databases that you use for your projects. If you have not installed CLSQL yet, then please install it now:

You also need to install one or more CLSQL backends, depending on which relational databases you use:

While I often prefer hand crafting SQL queries, there seems to be a general movement in software development towards the data mapper or active record design patterns. CLSQL provides Object Relational Mapping (ORM) functionality to CLOS.

You will need to create a new database news in order to follow along with the examples in this chapter and later in this book. I will use Postgres for examples in this chapter and use the following to create a new database (my account is “markw” and the following assumes that I have Postgres configured to not require a password for this account when accessing the database from “localhost”):

We will use three example programs that you can find in the src directory in the book repository on github:

The following listing shows the file src/clsql_create_news_schema.lisp:

In this repl listing, we create the database table “articles” using the function create-articles-table that we just defined:

The following listing shows the file src/clsql_write_to_news.lisp:

You should load the file clsql_write_to_news.lisp one time in a repl to create the test data. The following listing shows file clsql_read_from_news.lisp:

Loading the file clsql_read_from_news.lisp produces the following output:

You can also embed SQL where clauses in queries:

In this example, I am using a SQL like expression to perform partial text matching.

Non-relational data stores are commonly used for applications that don’t need either full relational algebra or must scale.

Brewer’s CAP theorem states that a distributed data storage system comprised of multiple nodes can be robust to two of three of the following guarantees: all nodes always have a Consistent view of the state of data, general Availablity of data if not all nodes are functioning, and Partition tolerance so clients can still communicate with the data storage system when parts of the system are unavailable because of network failures. The basic idea is that different applications have different requirements and sometimes it makes sense to reduce system cost or improve scalability by easing back on one of these requirements.

A good example is that some applications may not need transactions (the first guarantee) because it is not important if clients sometimes get data that is a few seconds out of date.

MongoDB allows you to choose consistency vs. availability vs. efficiency.

I cover the Solr indexing and search service (based on Lucene) both because a Solr indexed document store is a type of NoSQL data store and also because I believe that you will find Solr very useful for building systems, if you don’t already use it.

We will design the examples in this chapter so that they can be reused in the last chapter in this book on Information Gathering.

The following discussion of MongoDB is based on just my personal experience, so I am not covering all use cases. I have used MongoDB for:

One of the advantages of MongoDB is that is very “developer friendly” because it supports ad-hoc document schemas and interactive queries. I mentioned that MongoDB allows you to choose consistency vs. availability vs. efficiency. When you perform MongoDB writes you can specify some granularity of what constitutes a “successful write” by requiring that a write is performed at a specific number of nodes before the client gets acknowledgement that the write was successful. This requirement adds overhead to each write operation and can cause writes to fail if some nodes are not available.

The MongoDB online documentation is very good. You don’t have to read it in order to have fun playing with the following Common Lisp and MongoDB examples, but if you find that MongoDB is a good fit for your needs after playing with these examples then you should read the documentation. I usually install MongoDB myself but it is sometimes convenient to use a hosting service. There are several well regarded services and I have used MongoHQ.

At this time there is no official Common Lisp support for accessing MongoDB but there is a useful project by Alfons Haffmans’ cl-mongo that will allow us to write Common Lisp client applications and have access to most of the capabilities of MongoDB.

The file src/mongo_news.lisp contains the example code used in the next three sessions.

The following repl listing shows the cl-mongo APIs for creating a new document, adding elements (attributes) to it, and inserting it in a MongoDB data store:

In this example, three string attributes were added to a new document before it was saved.

We will start by fetchng and pretty-printing all documents in the collection articles and fetching all articles a list of nested lists where the inner nested lists are document URI, title, and text:

Output for these two functions looks like:

By reusing the function article-results->lisp-data defined in the last section, we can also search for JSON documents using regular expressions matching attribute values:

I set the limit to return a maximum of ten documents. If you do not set the limit, this example code only returns one search result. The following repl listing shows the results from calling function search-articles-text:

I find using MongoDB to be especially effective when experimenting with data and code. The schema free JSON document format, using interactive queries using the mongo shell, and easy to use client libraries like clouchdb for Common Lisp will let you experiment with a lot of ideas in a short period of time. The following listing shows the use of the interactive mongo shell. The database news is the database used in the MongoDB examples in this chapter; you will notice that I also have other databases for other projects on my laptop:

Line 1 of this listing shows starting the mongo shell. Line 4 shows how to list all databases in the data store. In line 13 I select the database “news” to use. Line 15 prints out the names of all collections in the current database “news”. Line 18 prints out all documents in the “articles” collection. You can read the documentation for the mongo shell for more options like selective queries, adding indices, etc.

When you run a MongoDB service on your laptop, also try the admin interface on http://localhost:28017/.

CouchDB provides replication services so JSON documents you store with a CouchDB service on your laptop, for instance, can replicate to CouchDB services on your remote servers. For the rest of this chapter we will look at some code examples for using CouchDB from Common Lisp applications.

Building CouchDB from source takes a while since you need Erlang and Javascript dependencies. You can download prebuilt binaries for Windows and Mac OS X and on Linux use sudo apt-get install couchdb. I also have found it useful to use the CouchDB hosting service Cloudant. Cloudant has open sourced a major piece of their infrastructure, a distributed version of CouchDB called BigCouch that you might want to consider if you need a very large distributed document data store.

After you run a CouchDB service you can then use the web administration interface http://127.0.0.1:5984/_utils/index.html to create a new database news that we will use in these examples.

To install and use the clouchdb CouchDB client library and use the new news database:

Notice that in line 7 that the database name is “default.” We want to change the database to “news” which we do in line 13. You can in a similar way change any other attributes in the couchdb::couchdb connection structure.

CouchDB documents are stored as JSON data. The clouchdb library lets us deal with documents as Lisp lists and converts to and from JSON for us.

We can create a document passing a list of lists to the function clouchdb:create-document. The sub-lists are treated as hash table key/value pairs:

If you are still running the web administration interface you can look at database news, see one document that we just created, and inspect the data in the document:

CouchDB uses views that are pre-computed using map reduce programs written in Javascript. You don’t need to look at it right now, but if after experimenting with the examples in this chapter you decide to use CouchDB for your projects then you will need to read the CouchDB View Documentation.

The clouchdb documentation has several examples for using the parenscript library to convert Lisp to Javascript for views but I prefer just using Javascript. One reason for this is that I experiment with writing map reduce functions for creating views while inside the CouchDB Admin Web App in Javascript. I find that using parenscript is an unnecessary extra level of abstraction. The map reduce view functions I need are relatively simple, and I don’t mind writing them in Javascript.

The following listing shows a temporary view to return all documents that have an attribute title. The Javascript code in the call to clouchdb:ad-hoc-view should be all on one line, I manually reformatted it here for readability:

You can also match on substrings. The following call to clouchdb:ad-hoc-view should be all on one line (once again, I manually reformatted it here for readability):

Please note that ad-hoc views are very inefficient but useful during development. In production you will create named views for specific queries. The CouchDB service will keep the view up to date for you automatically as documents are created, modified, and removed. The following listing shows a “design” document that is used to define a view:

Note the form of the attribute _id which is important: the string “_design/” followed by the name of the view. In general, you might define multiple views in a single “design” document, but I only defined one here named “season.” Also note that the “season” view only has a map function, not a reduce function. The pattern of using only a map function is common when you want to select a set of documents based on some selection criteria. Using map and reduce functions is useful when you are aggregating data from many documents together.

The following figure shows the CouchDB admin web app while I was editing this view:

You can run this view using:

The call to function clouchdb:invoke-view on line 1 references the name of the design documents without the prefix “_design/” and the name of the view “season” that was defined in this “design” document.

If we add an additional test document with “Season” in its title and re-run the view from the last section, we now have two matching results when calling the function clouchdb:invoke-view:

The Lucene project is one of the most widely used Apache Foundation projects. Lucene is a flexible library for preprocessing and indexing text, and searching text. I have personally used Lucene on so many projects that it would be difficult counting them. The Apache Solr Project adds a network interface to the Lucene text indexer and search engine. Solr also adds other utility features to Lucene:

I hope that you will find the Common Lisp example Solr client code in the following sections helps you make Solr part of large systems that you write using Common Lisp.

Download a binary Solr distribution and un-tar or un-zip this Solr distribution, cd to the distribution directory, then cd to the example directory and run:

You can access the Solr Admin Web App at http://localhost:8983/solr/#/. This web app can be seen in the following screen shot:

There is no data in the Solr example index yet, so following the Solr tutorial instructions:

You will learn how to add documents to Solr directly in your Common Lisp programs in a later section.

Assuming that you have a fast Internet connection so downloading Solr was quick, you have hopefully spent less than five or six minutes getting Solr installed and running with enough example search data for the Common Lisp client examples we will play with. Solr is a great tool for storing, indexing, and searching data. I recommend that you put off reading the official Solr documentation for now and instead work through the Common Lisp examples in the next two sections. Later, if you want to use Solr then you will need to carefully read the Solr documentation.

The Solr REST Interface Documentation documents how to perform search using HTTP GET requests. All we need to do is implement this in Common Lisp which you will see is easy.

Assuming that you have Solr running and the example data loaded, we can try searching for documents with, for example, the word “British” using the URL http://localhost:8983/solr/select?q=British. This is a REST request URL and you can use utilities like curl or wget to fetch the XML data. I fetched the data in a web browser, as seen in the following screen shot of a Firefox web browser (I like the way Firefox formats and displays XML data):

The attributes in the returned search results need some explanation. We indexed several example XML data files, one of which contained the following XML element that we just saw as a search result:

So, the search result has the same attributes as the structured XML data that was added to the Solr search index. Solr’s capability for indexing structured data is a superset of just indexing plain text. As an example, if we were indexing news stories, then example input data might look like:

With this example, a search result that returned this document as a result would return attributes id, title, and text, and the values of these three attributes.

By default the Solr web service returns XML data as seen in the last screen shot. For our examples, I prefer using JSON so we are going to always add a request parameter wt=json to all REST calls. The following screen shot shows the same data returned in JSON serialization format instead of XML format of a Chrome web browser (I like the way Chrome formats and displays JSON data with the JSONView Chrome Browser extension):

You can read the full JSON REST Solr documentation later, but for our use here we will use the following search patterns:

As we saw in the earlier in Network Programming it is fairly simple to use the drakma and cl-json Common Lisp libraries to call REST services that return JSON data. The function do-search defined in the next listing (all the Solr example code is in the file src/solr-client.lisp) constructs a query URI as we saw in the last section and uses the Drackma library to perform an HTTP GET operation and the cl-json library to parse the returned string containing JSON data into Lisp data structures:

This example code does return the search results as Lisp list data; for example:

I might modify the search function to return just the fetched documents as a list, discarding the returned Solr meta data:

There are a few more important details if you want to add Solr search to your Common Lisp applications. When there are many search results you might want to fetch a limited number of results and then “page” through them. The following strings can be added to the end of a search query:

A query that combines skipping results and limiting the number of returned results looks like this:

In the last example we relied on adding example documents to the Solr search index using the directions for setting up a new Solr installation. In a real application, in addition to performing search requests for indexed documents you will need to add new documents from your Lisp applications. Using the Drakma we will see that it is very easy to add documents.

We need to construct a bit of XML containing new documents in the form:

You can specify whatever field names (attributes) that are required for your application. You can also pass multiple <doc></doc> elements in one add request. We will want to specify documents in a Lisp like way: a list of cons values where each cons value is a field name and a value. For the last XML document example we would like an API that lets us just deal with Lisp data like:

One thing to note: the attribute names and values must be passed as strings. Other data types like integers, floating point numbers, structs, etc. will not work.

This is nicer than having to use XML, right? The first thing we need is a function to convert a list of cons values to XML. I could have used the XML Builder functionality in the cxml library that is available via Quicklisp, but for something this simple I just wrote it in pure Common Lisp with no other dependencies (also in the example file src/solr-client.lisp) :

The macro with-output-to-string on line 2 of the listing is my favorite way to generate strings. Everything written to the variable stream inside the macro call is appended to a string; this string is the return value of the macro.

The following function adds documents to the Solr document input queue but does not actually index them:

You have noticed in line 3 that I am accessing a Solr server running on localhost and not a remote server. In an application using a remote Solr server you would need to modify this to reference your server; for example:

For efficiency Solr does not immediately add new documents to the index until you commit the additions. The following function should be called after you are done adding documents to actually add them to the index:

Notice that all we need is an empty element <commit></commit> that signals the Solr server that it should index all recently added documents. The following repl listing shows everything working together (I am assuming that the contents of the file src/solr-client.lisp has been loaded); not all of the output is shown in this listing:

Solr has a lot of useful features that we have not used here like supporting faceted search (drilling down in previous search results), geolocation search, and looking up indexed documents by attribute. In the examples I have shown you, all text fields are indexed but Solr optionally allows you fine control over indexing, spelling correction, word stemming, etc.

Solr is a very capable tool for storing, indexing, and searching data. I have seen Solr used effectively on projects as a replacement for a relational database or other NoSQL data stores like CouchDB or MongoDB. There is a higher overhead for modifying or removing data in Solr so for applications that involve frequent modifications to stored data Solr might not be a good choice.

There are more convenient languages than Common Lisp to use for accessing MongoDB and CouchDB. To be honest, my favorites are Ruby and Clojure. That said, for applications where the advantages of Common Lisp are compelling, it is good to know that your Common Lisp applications can play nicely with MongoDB and CouchDB.

I am a polyglot programmer: I like to use the best programming language for any specific job. When we design and build systems with more than one programming language, there are several options to share data:

Hopefully this chapter and the last chapter will provide most of what you need for the last option.

Natural Language Processing (NLP) is the automated processing of natural language text with several goals:

We will use a library that I wrote that performs POS tagging, categorization (classification), summarization, and detects proper names.

The example code for this chapter is contained in the file src/knowledgebooks_nlp.lisp and needs to load the data in the directory src/data. I worked on this Lisp code, and also similar code in Java, from about 2001 to 2011. While I still use my own Common Lisp library (and a newer Ruby version KBSPortal.com) I no longer actively develop my libraries for NLP. In any case I hope you find the following code interesting and useful. I am going to start in the next section with a quick explanation of how to run the example code. If you find the examples interesting then you can also read the rest of this chapter where I explain how the code works.

The approach that I used in my library for categorization (word counts) is now dated. I recommend that you consider taking Andrew Ng’s course on Machine Learning on the free online Coursera system and then take one of the Coursera NLP classes for a more modern treatment of NLP.

In addition to the code for my library you might also find the linguistic data in src/data useful.

I repackaged the NLP example code into one long file. The code used to be split over 18 source files. The code should be loaded from the src directory:

Unfortunately, it takes a few minutes to load the required linguistic data so I recommend creating a Lisp image that can be reloaded to avoid the time required to load the data:

In line 1 in this repl listing, I use the SBCL built-in function save-lisp-and-die to create the Lisp image file. Using save-lisp-and-die is a great technique to use whenever it takes a while to set up your work environment. Saving a Lisp image for use the next time you work on a Common Lisp project is reminiscent of working in Smalltalk where your work is saved between sessions in an image file.

You can now start SBCL with the NLP library and data preloaded using the Lisp image that you just created:

At the end of the file src/knowledgebooks_nlp.lisp in comments is some test code that processes much more text so that a summary is also generated; here is a bit of the output you will see if you load the test code into your repl:

The top-level function make-text-object takes one required argument that can be either a string containing text or an array of strings where each string is a word or punctuation. Function make-text-object has two optional keyword parameters: the URL where the text was found and a title.

In line 2, we check if this function was called with a string containing text in which case the function words-from-string is used to tokenize the text into an array of string tokens. Line two defines the local variable txt-obj with the value of a new text object with only three slots (attributes) defined: text, url, and title. Line 4 sets the slot text-tags to the part of speech tokens using the function part-of-speech-tagger. We use the function find-names-places in line 8 to get person and place names and store these values in the text object. In lines 11 through 17 we use the function get-word-list-category to set the categories in the text object. In line 18 we similarly use the function summarize to calculate a summary of the text and also store it in the text object. We will discuss these NLP helper functions throughout the rest of this chapter.

The function make-text-object returns a struct that is defined as:

This tagger is the Common Lisp implementation of my FastTag open source project. I based this project on Eric Brill’s PhD thesis (1995). He used machine learning on annotated text to learn tagging rules. I used a subset of the tagging rules that he generated that were most often used when he tested his tagger. I hand coded his rules in Lisp (and Ruby, Java, and Pascal). My tagger is less accurate, but it is fast - thus the name FastTag.

You can find the tagger implementation in the function part-of-speech-tagger. We already saw sample output from the tagger in the last section:

The following table shows the meanings of the tags and a few example words:

The function part-of-speech-tagger loops through all input words and initially assigns the most likely part of speech as specified in the lexicon. Then a subset of Brill’s rules are applied. Rules operate on the current word and the previous word.

As an example Common Lisp implementation of a rule, look for words that are tagged as common nouns, but end in “ing” so they should be a gerand (verb form):

You can find the lexicon data in the file src/data/FastTagData.lisp. This file is List code instead of plain data (that in retrospect would be better because it would load faster) and looks like:

I generated this file automatically from lexicon data using a small Ruby script. Notice that words can have more than one possible part of speech. The most common part of speech for a word is the first entry in the lexicon.

The code to categorize text is fairly simple using a technique often called “bag of words.” I collected sample text in several different categories and for each category (like politics, sports, etc.) I calculated the evidence or weight that words contribute to supporting a category. For example, the word “president” has a strong weight for the category “politics” but not for the category “sports.” The reason is that the word “president” occurs frequently in articles and books about politics. The data file that contains the word weightings for each category is src/data/cat-data-tables.lisp. You can look at this file; here is a very small part of it:

This file was created by a simple Ruby script (not included with the book’s example code) that processes a list of sub-directories, one sub-directory per category. The following listing shows the implementation of function get-word-list-category that calculates category tags for input text:

On thing to notice in this listing is lines 11 through 15 where I define a nested function list-sort that takes a list of sub-lists and sorts the sublists based on the second value (which is a number) in the sublists. I often nest functions when the “inner” functions are only used in the “outer” function.

Lines 2 through 9 define several local variables used in the outer function. The global variable categoryHashtables is a list of word weighting score hash tables, one for each category. The local variable category-score-accumulation-array is initialized to an array containing the number zero in each element and will be used to “keep score” of each category. The highest scored categories will be the return value for the outer function.

Lines 17 through 27 are two nested loops. The outer loop is over each word in the input word array. The inner loop is over the number of categories. The logic is simple: for each word check to see if it has a weighting score in each category’s word weighting score hash table and if it is, increment the matching category’s score.

The local variable ss is set to an empty list on line 28 and in the loop in lines 29 through 38 I am copying over categories and their scores when the score is over a threshold value of 0.01. We sort the list in ss on line 39 using the inner function and then return the categories with a score greater than the median category score.

Stemming text is often used for information retrieval tasks. Stemming maps words to the root word yielding tokens that are often not legal words. For example “president” and “presidential” would both map to “presid” so searching for the token “presid” in a stemmed token list would match either word.

The Common Lisp stemming code in the file src/knowledgebooks_nlp.lisp was written by Steven M. Haflich and is based on based on the work of Martin Porter.

As we saw in a previous example the effects of stemming:

The top level function make-text-object stems all words in input text.

The functions that support identifying people’s names and place names in text are:

I will let you read the code and just list the top level function:

In line 2 we are using the slot accessor text-text to fetch the array of word tokens from the text object. In lines 3, 4, and 5 we are doing the same for part of speech tags, place name indices in the words array, and person names indices in the words array.

In lines 6 through 11 we are using the function build-list-find-name-helper twice to construct the person names and place names as strings given the indices in the words array. We are also using the Common Lisp built-in function remove-duplicates to get rid of duplicate names.

In lines 12 through 16 we are discarding any persons names that do not contain a space, that is, only keep names that are at least two word tokens. Lines 17 through 19 define the return value for the function: a list of lists of people and place names using the function remove-shorter-names twice to remove shorter versions of the same names from the lists. For example, if we had two names “Mr. John Smith” and “John Smith” then we would want to drop the shorter name “John Smith” from the return list.

There are many applications for summarizing text. As an example, if you are writing a document management system you will certainly want to use something like Solr to provide search functionality. Solr will return highlighted matches in snippets of indexed document field values. Using summarization, when you add documents to a Solr (or other) search index you could create a new unindexed field that contains a document summary. Then when the users of your system see search results they will see the type of highlighted matches in snippets they are used to seeing in Google, Bing, or DuckDuckGo search results, and, they will see a summary of the document.

Sounds good? The problem to solve is getting good summaries of text and the technique used may have to be modified depending on the type of text you are trying to summarize. There are two basic techniques for summarization: a practical way that almost everyone uses, and an area of research that I believe has so far seen little practical application. The techniques are sentence extraction and abstraction of text into a shorter form by combining and altering sentences. We will use sentence extraction.

How do we choose which sentences in text to extract for the summary? The idea I had in 1999 was simple. Since I usually categorize text in my NLP processing pipeline why not use the words that gave the strongest evidence for categorizing text, and find the sentences with the largest number of these words. As a concrete example, if I categorize text as being “politics”, I identify the words in the text like “president”, “congress”, “election”, etc. that triggered the “politics” classification, and find the sentences with the largest concentrations of these words.

Summarization is something that you will probably need to experiment with depending on your application. My old summarization code contained a lot of special cases, blocks of commented out code, etc. I have attempted to shorten and simplify my old summarization code for the purposes of this book as much as possible and still maintain useful functionality.

The function for summarizing text is fairly simple because when the function summarize is called by the top level NLP library function make-text-object, the input text has already been categorized. Remember from the example at the beginning of the chapter that the category data looks like this:

This category data is saved in the local variable cats on line 4 of the following listing.

The nested loops in lines 8 through 33 look a little complicated, so let’s walk through it. Our goal is to calculate an importance score for each word token in the input text and to then select a few sentences containing highly scored words. The outer loop is over the word tokens in the input text. For each word token we loop over the list of categories, looking up the current word in each category hash and incrementing the score for the current word token. As we increment the word token scores we also look for sentence breaks and save sentences.

The complicated bit of code in in lines 16 through 32 where I construct sentences and their scores, and store sentences with a score above a threshold value in the list best-sentences. After the two nested loops, in lines 34 through 44 we simply sort the sentences by score and select the “best” sentences for the summary. The extracted sentences are no longer in their original order, which can have strange effects, but I like seeing the most relevant sentences first.

Text mining in general refers to finding data in unstructured text. We have covered several text mining techniques in this chapter:

In the next chapter I am going to cover another “data centric” topic: performing information gathering on the web. You will likely find some synergy between being able to use NLP to create structured data from unstructured text.

This chapter covers information gathering on the web using data sources and general techniques that I have found useful. When I was planning this new book edition I had intended to also cover some basics for using the Semantic Web from Common Lisp, basically distilling some of the data from my previous book “Practical Semantic Web and Linked Data Applications, Common Lisp Edition” published in 2011. However since a free PDF is now available for that book I decided to just refer you to my previous work if you are interested in the Semantic Web and Linked Data. You can also find the Java edition of this previous book on my web site.

Gathering information from the web in realtime has some real advantages:

There are also a few things to consider:

Wikipedia is a great source of information. As you may know, you can download a data dump of all Wikipedia data with or without version information and comments. When I want fast access to the entire Wikipedia set of English language articles I choose the second option and just get the current pages with no comments of versioning information. This is the direct download link for current Wikipedia articles. There are no comments or user pages in this GZIP file. This is not as much data as you might think, only about 9 gigabytes compressed or about 42 gigabytes uncompressed.

Wikipedia is a great resource to have on-hand but I am going to show you in this section how to access the Semantic Web version or Wikipedia, DBPedia using the DBPedia Lookup Service in the next code listing that shows the contents of the example file dbpedia-lookup.lisp:

I am only capturing the attributes for DBPedia URI, label and description in this example code. If you uncomment line 41 and look at the entire response body from the call to DBPedia Lookup, you can see other attributes that you might want to capture in your applications.

Here is a sample call to the function dbpedia-lookup (only some of the returned data is shown):

Wikipedia, and the DBPedia linked data for of Wikipedia are great sources of online data. If you get creative, you will be able to think of ways to modify the systems you build to pull data from DPPedia. One warning: Semantic Web/Linked Data sources on the web are not available 100% of the time. If your business applications depend on having the DBPedia always available then you can follow the instructions on the DBPedia web site to install the service on one of your own servers.

When you write web spiders to collect data from the web there are two things to consider:

We have already used the Drakma web client library in this book. See the files src/dbpedia-lookup.lisp (covered in the last section) and src/solr-client.lisp (covered in the Chapter on NoSQL). Paul Nathan has written library using Drakma to crawl a web site with an example to print out links as they are found. His code is available under the AGPL license at articulate-lisp.com/src/web-trotter.lisp and I recommend that as a starting point. The documentation is here.

I find it is sometimes easier during development to make local copies of a web site so that I don’t have to use excess resources from web site hosts. Assuming that you have the wget utility installed, you can mirror a site like this:

Both of these examples have a two second delay between HTTP requests for resources. The option -m indicates to recursively follow all links on the web site. The -w 2 option delays for two seconds between requests. The option -mk converts URI references to local file references on your local mirror. The second example on line 2 is more convenient.

We covered reading from local files in the Chapter on Input and Output. One trick I use is to simply concatenate all web pages into one file. Assuming that you created a local mirror of a web site, cd to the top level directory and use something like this:

You can then open the file, search for text in in p, div, h1, etc. HTML elements to process an entire web site as one file.

Apache Nutch, like Solr, is built on Lucene search technology. I use Nutch as a “search engine in a box” when I need to spider web sites and I want a local copy with a good search index.

Nutch handles a different developer’s use case over Solr which we covered in the Chapter on NoSQL. As we saw, Solr is an effective tool for indexing and searching structured data as documents. With very little setup, Nutch can be set up to automatically keep an up to date index of a list of web sites, and optionally follow links to some desired depth from these “seed” web sites.

You can use the same Common Lisp client code that we used for Solr with one exception; you will need to change the root URI for the search service to:

So the modified client code src/solr-client.lisp needs one line changed:

Early versions of Nutch were very simple to install and configure. Later versions of Nutch have been more complex, more performant, and have more services, but it will take you longer to get set up than earlier versions. If you just want to experiment with Nutch, you might want to start with an earlier version.

The OpenSearch.org web site contains many public OpenSearch services that you might want to try. If you want to modify the example client code in src/solr-client.lisp you should start with OpenSearch services that return JSON data and OpenSearch Community JSON formats web page is a good place to start. Some of the services on this web page like the New York Times service require that you sign up for a developer’s API key.

When I start writing an application that requires web data (no matter which programming language I am using) I start by finding services that may provide the type of data I need and do my initial development with a web browser with plugin support to nicely format XML and JSON data. I do a lot of exploring and take a lot of notes before I write any code.

I tried to provide some examples and advice in this short chapter to show you that even though other languages like Ruby and Python have more libraries and tools for gathering information from the web, Common Lisp has good libraries for information gathering also and they are easily used via Quicklisp.

The CL Machine-Learning (CLML) library was originally developed by MSI (NTT DATA Mathematical Systems Inc. in Japan) and is supported by many developers. You should visit the CLML web page and follow the installation directions and read about the project before using the examples in this chapter. However if you just want to quickly try the following CLML examples then you can install CLML using Quicklisp:

The installation will take a while to run but after installation using the libraries via quickload is fast.

Other resources for CLML are the tutorials and contributed extensions that include support for plotting (using several libraires) and for fetching data sets.

Although CLML is fairly portable we will be using SBCL and we need to increase the heap space when starting SBCL when we want to use the CLML library:

Assuming that you have installed CLML in the ~quicklisp/local-projects directory, you can open the following documentation file in your web browser:

This documentation lists the packages with some information for each package but realistically I keep the source code for CLML in an editor or IDE and read source code while writing code that uses CLML. I will show you with short examples how to use the KNN (K nearest neighbors) and SVM (support vector machines) APIs. We will not cover other useful CLML APIs like time series processing, Naive Bayes, PCA (principle component anaysis) and general matrix and tensor operations.

Even though the learning curve is a bit steep, CLML provides a lot of functionality for machine learning, dealing with time series data, and general matrix and tensor operations.

The CLML project uses several data sets and since the few that we will use are small files, they are included in the book’s repository in directory machine_learning_data under the src directory. The first few lines of labeled_cancer_training_data.csv are:

The first line in the CSV data files specifies names for each attribute with the name of the last column being “Class” which here takes on values benign or malignant. Later, the goal will be to create models that are constructed from training data and then make predictions of the “Class” of new input data. We will look at how to build and use machine learning models later but here we concentrate of reading and using input data.

The example file clml_data_apis.lisp shows how to open a file and loop over the values for each row:

The function read-data defined in lines 11-19 uses the utility function clml.hjs.read-data:read-data-from-file to read a CSV (comma separated value) spreadsheet file from disk. The CSV file is expected to contain 10 columns (set in lines 17-18) with the first nine columns containing floating point values and the last column text data.

The function loop-over-and-print-data defined in lines 21-26 reads the CLML data set object, looping over each data sample (i.e., each row in the original spreadsheet file) and printing it.

Here is some output from loading this file:

In the next section we will use the same cancer data training file, and another test data in the same format to cluster this cancer data into similar sets, one set for non-malignant and one for malignant samples.

We will now read the same University of Wisconsin cancer data set and cluster the input samples (one sample per row of the spreadsheet file) into similar classes. We will find after training a model that the data is separated into two clusters, representing non-malignant and malignant samples.

The function cancer-data-cluster-example-read-data defined in lines 33-47 is very simple to the function read-data in the last section except here we read in two data files: one for training and one for testing.

The function cluster-using-k-nn defined in lines 13-30 uses the training and test data objects to first train a model and then to test it with test data that was previously used for training. Notice how we call this function in line 47: the first two arguments are the two data set objects, the third is the string “Class” that is the label for the 10th column of the original spreadsheet CSV files, and the last argument is the type of distance measurement used to compare two data samples (i.e., comparing any two rows of the training CSV data file).

The following listing shows the output from running the last code example:

We will now reuse the same cancer data set but use a different way to classify data into non-malignant and malignant categories: Support Vector Machines (SVM). SVMs are linear classifiers which means that they work best when data is linearly separable. In the case of the cancer data, there are nine dimensions of values that (hopefully) predict one of the two output classes (or categories). If we think of the first 9 columns of data as defining a 9-dimensional space, then SVM will work well when a 8-dimensional hyperplane separates the samples into the two output classes (categories).

To make this simpler to visualize, if we just had two input columns, that defines a two-dimensional space, and if a straight line can separate most of the examples into the two output categories, then the data is linearly separable so SVM is a good technique to use. The SVM algorithm is effectively determining the parameters defining this one-dimensional line (or in the cancer data case, the 9-dimensional hyperspace).

What if data is not linearly separable? Then use the backpropagation neural network code in the chapter “Backpropagation Neural Networks” or the deep learning code in the chapter “Using Armed Bear Common Lisp With DeepLearning4j” to create a model.

SVM is very efficient so it often makes sense to first try SVM and if trained models are not accurate enough then use neural networks (including deep learning).

The following listing of file clml_svm_classifier.lisp shows how to read data, build a model and evaluate the model with different test data. In line 15 we use the function clml.svm.mu:svm that requires the type of kernel function to use, the training data, and testing data. Just for reference, we usually use Gaussian kernel functions for processing numeric data and linear kernel functions for handling text in natural language processing applications. Here we use a Gaussian kernel.

The function cancer-data-svm-example-read-data defined on line 40 differs from how we read and processed data earlier because we need to separate out the positive and negative training examples. The data is split in the lexically scoped function in lines 42-52. The last block of code in lines 54-82 is just top-level test code that gets executed when the file clml_svm_classifier.lisp is loaded.

The sample code prints the prediction values for the test data which I will not show here. Here are the last four lines of output showing the cumulative statistics for the test data:

The CLML machine learning library is under fairly active development and I showed you enough to get started: understanding the data APIs and examples for KNN clustering and SVM classification.

A good alternative to CLML is MGL that supports backpropagation neural networks, boltzmann machines, and gaussian processes.

In the next two chapters we continue with the topic of machine learning with backpropagation andf Hopfield neural networks.

Let’s start with an overview of how these networks work and then fill in more detail later. Backpropagation networks are trained by applying training inputs to the network input layer, propagate values through the network to the output neurons, compare the errors (or differences) between these propagated output values and the training data output values. These output errors are backpropagated though the network and the magnitude of backpropagated errors are used to adjust the weights in the network.

We will use the following diagram to make this process more clear. There are four weights in this very simple network:

Before any training the weight values are all small random numbers.

Consider a training data element where the input neurons have values [0.1, 0.9] and the desired output neuron values are [0.9 and 0.1], that is flipping the input values. If the propagated output values for the current weights are [0.85, 0.5] then the value of the first output neuron has a small error abs(0.85 - 0.9) which is 0.05. However the propagated error of the second output neuron is high: abs(0.5 - 0.1) which is 0.4. Informally we see that the weights feeding input output neuron 1 (W1,1 and W2,1) don’t need to be changed much but the neuron that feeding input neuron 2 (W1,2 and W2,2) need modification (the value of W2,2 is too large).

Of course, we would never try to manually train a network like this but it is important to have at least an informal understanding of how weights connect the flow of value (we will call this activation value later) between neurons.

In this neural network see in the first figure we have four weights connecting the input and output neurons. Think of these four weghts forming a four-dimensional space where the range in each dimension is constrained to small positive and negative floating point values. At any point in this “weight space”, the numeric values of the weights defines a model that maps the inputs to the outputs. The error seen at the output neurons is accumuated for each training example (applied to the input neurons). The training process is finding a point in this four-dimensional space that has low errors summed across the training data. We will use gradient descent to start with a random point in the four-dimensional space (i.e., an initial random set of weights) and move the point towards a local minimum that represents the weights in a model that is (hopefully) “good enough” at representing the training data.

This process is simple enough but there are a few practical considerations:

In practice using backpropagation networks is an iterative process of experimenting with the size of a network.

In the example program (in the file backprop_neural_network.lisp) we use the plotting library developed earlier to visualize neuron activation and connecting weight values while the network trains.

The following three screen shots from running the function test3 defined at the bottom of the file backprop_neural_network.lisp illustrate the process of starting with random weights, getting random outputs during initial training, and as delta weights are used to adjust the weights in a network, then the training examples are learned:

In the last figure the initial weights are random so we get random mid-range values at the output neurons.

As we start to train the network, adjusting the weights, we start to see variation in the output neurons as a function of what the inputs are.

In the last figure the network is trained sufficiently well to map inputs [0, 0, 0, 1] to output values that are approximately [0.8, 0.2, 0.2, 0.3] which is close to the expected value [1, 0, 0, 0].

The example source file backprop_neural_network.lisp is long so we will only look at the more interesting parts here. Specifically we will not look at the code to plot neural networks using plotlib.

The activation values of individual neurons are limited to the range [0, 1] by first calculating their values based on the sum activation values of neurons in the previous layer times the values of the connecting weights and then using the Sigmoid function to map the sums to the desired range. The Sigmoid function and the derivative of the Sigmoid function (dSigmoid) look like:

Here are the definitions of these functions:

The function NewDeltaNetwork creates a new neual network object. This code allocates storage for input, hidden, output layers (I sometimes refer to neuron layers as “slabs”), and the connection weights. Connection weights are initialized to small random values.

In the following listing the function DeltaLearn processes one pass through all of the training data. Function DeltaLearn is called repeatedly until the return valuen is below a desired error threshold. The main loop over each training example is implemented in lines 69-187. Inside this outer loop there are two phases of training for each training example: a forward pass propagating activation from the input neurons to the output neurons via any hidden layers (lines 87-143) and then the weight correcting backpropagation of output errors while making small adjustments to weights (lines 148-187):

The function DeltaRecall in te next listing can be used with a trained network to calculate outputs for new input values:

We saw three output plots earlier that were produced during a training run using the following code:

Here the function test3 defines training data for a very small test network for a moderately difficult function to learn: to rotate the values in the input neurons to the right, wrapping around to the first neuron. The start of the main loop in line calls the training function 3000 times, creating a plot of the network every 400 times through the main loop.

Backpropagation networks have been used sucessfully in production since for abut 25 years. In the next chapter we will look at a less practical type of network (Hopfield networks) that are still interesting because the in sme sense model how our brains work. In the final chapter we will look at deep lerning neural networks.

A Hopfield network (named after John Hopfield) is a recurrent network since the flow of activation through the network has loops. These networks are trained by applying input patterns and letting the network settle in a state that stores the input patterns.

The example we look at recognizes patterns that are similar to the patterns seen in training examples and maps input patterns to a similar training input pattern. The following figure shows output from the example program showing an original training pattern, a similar pattern with one cell turned on and onther off, and the reconstructed pattern:

To be clear, we have taken one of the original input patterns the network has learned, slightly altered it, and applied it as input to the network. After cycling the network, the slightly scrambled input pattern we just applied will (hopefully) be used as an associative memory key, look up the original pattern, and rewrite to input values with the original learned pattern. These Hopfield networks are very different than backpropagation networks: neuron activation are forced to values of -1 or +1 and not be differentiable slowly changing values) and there are no separate output neurons.

The next example has the values of three cells modified from the original and the original pattern is still reconstructed correctly:

This last example has four of the original cells modified:

The following example program shows a type of content-addressable memory. After a Hopfield network learns a set of input patterns then it can reconstruct the original paterns when shown similar patterns. This reconstruction is not always perfecrt.

The following function Hopfield-Init (in file Hopfield_neural_network.lisp) is passed a list of lists of training examples that will be remembered in the network. This function returns a list containing the data defining a Hopfield neural network. All data for the network is encapsulated in the list returned by this function, so multiple Hopfield neural networks can be used in an application program.

In lines 9-12 we allocate global arrays for data storage and in lines 14-18 the training data is copied.

The inner function adjustInput on lines 20-29 adjusts data values to values of -1.0 or +1.0. In lines 31-33 we are initializing all of the weights in the Hopfield network to zero.

The last nested loop, on lines 35-52, calculates the autocorrelation weight matrix from the input test patterns.

On lines 54-56, the function returns a representation of the Hopfield network that will be used later in the function HopfieldNetRecall to find the most similar “remembered” pattern given a new (fresh) input pattern.

The following function HopfieldNetRecall iterates the network to let it settle in a stable pattern which will (we hope) be the original training pattern most closely resembling the noisy test pattern.

The inner (lexically scoped) function deltaEnergy defined on lines 9-12 calculates a change in energy from old input values and the autocorrelation weight matrix. The main code uses the inner functions to iterate over the input cells, possibly modifying the cell at index i delta energy is greater than zero. Remember that the lexically scoped inner functions have access to the variables for the number of inputs, the number of training examples, the list of training examples, the input cell values, tempoary storage, and the Hopfield network weights.

Function test in the next listing uses three different patterns for each test. Note that only the last pattern gets plotted to the output graphics PNG file for the purpose of producing figures for this chapter. If you want to produce plots of other patterns, edit just the third pattern defined on line AAAAA. The following plotting functions are inner lexically scoped so they have access to the data defined in the enclosing let expression in lines 16-21:

The plotting functions in lines 23-62 use the plotlib library to make the plots you saw earlier. The function modifyInput in lines 64-69 randomly flips the values of the input cells, taking an original pattern and slightly modifying it.

Hopfield neural networks, at least to some extent, seem to model some aspects of human brains in the sense that they can function as content-addressable (also called associative) memories. Ideally a partial input pattern from a remembered input can reconstruct the complete original pattern. Another interesting feature of Hopfield networks is that these memories really are stored in a distributed fashion: some of the weights can be randomly altered and patterns are still remembered, but with more recall errors.

In the next chapter we will look at deep learning neural networks as well as get a practical example of mixing Common Lisp and Java code, required since the deep learning library we will use in written in Java.

This chapter both serves as a recipe for calling the Java deep learning library and also as a general example of “wrapping” other complex Java libraries that you may want to call from Common Lisp code that you write.

DeepLearning4j is a state of the art deep learning library that can handle small to medium data sets on your laptop and very large data sets using a cluster of servers controlled with Apache Spark. Here we just use DeepLearning4j with a small data set and the following examples will run on your laptop if you hav Java 8 installed. Armed Bear Common Lisp (ABCL) is implemented in Java and a compiled version is included in the example directory src/deep_learning_with_abcl so the following examples are self contained except for the Java 8 requirement.

The following listing shows the Java code in the source file Simple.java in the directory src/deep_learning_with_abcl. he first two functions modifyString and addTwoNumbers return specific types, in this case a string and an integer. The thrid function modifyArray takes advantage of ABCL’s flexible foreign function interface to Java. We can pass different supported Lisp types to this function and they will be converted automatically to Java types and in returning to Lisp are either converted to simple Lisp types or wrapped as ABCL specific types. We will see more examples of converting data types later.

The following listing of file simple.lisp shows how to call the three Java metods defined in the last listing. In lines 8, 17, and 26 we see the use of jmethod to wrap a Java class method as a function usable in ABCL. The value in variable class (defined in lines 6, 15, and 24) references the name of the class in the Java code, in this case the class was Simple. To call into Java code we use jcall (lines 9, 18, and 27). The first two calls to jcall are simple because we are passing native Java types (int and java.lang.String). The third example on line 27 is more complicated because we need to convert a Common Lisp list to a Java array.

Instead of running the following commands manually, you can use the Makefile and run “make simple” to compile Simple.java and start a ABCL repl. I show the commands individually here for reference:

Note that Java arrays must have elements of the same type so we could not make a call like:

because an error would be thrown that would look like:

This example uses both the DeepLearning4j library and also a slightly modified version of an example program in my book Power Java. You can read the book for free online and you might want to read the chapter “Deep Learning Using Deeplearning4j” for background. All required Java code is included in the repository for this book but to run this example you will need to have both Java 8 and maven installed.

The sample data we will use is the University of Wisconsin cancer data.

We need a JAR file that contains both the required DeepLearning4j code and also the Java wrapper code that provides an easier interface to call using the Java foreign function interface in ABCL.

In the git repository top level directory, change directory to:

You need Java 8 and maven installed to build an uber jar (that is a jar with the Java code and all required jar files, including DeepLearning4j dependencies used in the Java code for this project):

You should now have a new jar file uber-lisp-deep-learning.jar in the deep_learning_with_abcl directory. If you are curious about the contents of this JAR file then try this:

You are seeing compiled code for the wrapper from my Power Java book (modified slighty here to make it easier to call from Lisp), DeepLearning4j, and all other required dependencies. If you want to wrap other Java libraries for use with ABCL then hopefully the code and maven pom.xml configuration file in the subdirectory java_code_for_jar_library will serve as a useful example.

There is a Makefile that builds the local Java client code and starts up ABCL Lisp (following listing has been edited to avoid line wraps so als look at the file Makefile):

The following listing of file deep-learning.lisp shows the Common Lisp wrapper code for this example. The function train (lines 4-18) has arguments defining the size of the neural network (number of neurons in the input layer, in all the hidden layers, and the number of neurons in the output layer. These values should be compatible with the input training comma separated values (CSV) file (i.e., the value for numInput should be the number of columns in the CSV file minus one and the value of labelColumnIndex should be the column index for the output label.)

ABCL has a contributed library JSS and I copied the utility function jarray-to-list to convert Java arrays to Common Lisp lists. The function evaluateData (lines 27-34) can be used to try the trained model on new data sets. Using files to pass data is convenient for development and testing and is okay for deployed systems since the overhead of writing and reading files is negligible compared to computation costs of training and using deep learning models.

You can run the code with the sample data using (a lot of printout is not shown here):

In the last output, zero values indicate non-malignant while one values indicate a prediction of malignant for each test data sample.

The DeepLearning4J library implements several types of networks and here we just looked at a simple example that also serves as an example for calling Jaca libraries. While it is often more practical to use languages like Java or Python for deep learning because of available libraries written in these languages, I think a case can be made for hybrid Common Lisp and Java systems, taking advantage of Common Lisp for general programming, knowledge management, symbolic processing, etc., while using neural models for recognizing images, classifying text, linguistic processing, and other use cases that deep learning excels in.

I love programming in Lisp languages with concise code and a bottom-up approach to development. I hope you now also share this enthusiasm with me.

Common Lisp is sometimes criticised as not having as many useful libraries as some newer languages like Python and Java, and this is a valid criticism. That said, I hope the wide variety of examples in this book will convince you that Common Lisp is a good choice for many types of programming projects.

I would like to thank you for reading my book and I hope that you enjoyed it. As I mentioned in the Introduction I have been using Common Lisp since the mid-1980s, and other Lisp dialects for longer than that. I have always found something almost magical developing in Lisp. Being able to extend the language with macros and using the development technique of building a mini-language in Lisp customized for an application enables programmers to be very efficient in their work. I have usually found that this bottom-up development style helps me deal with software complexity because the lower level functions tend to get well tested while the overall system being developed is not yet too complex to fully understand. Later in the development process these lower level functions and utilities almost become part of the programming language and the higher level application logic is easier to understand because you have fewer lines of code to fit inside your head during development.

I think that unless a programmer works in very constrained application domains, it often makes sense to be a polyglot programmer. I have tried, especially in the new material for this fourth edition, to give you confidence that Common Lisp is good for both general software development language and also as “glue” to tie different systems together.

Thank you for buying and reading my book!|||

