Working in a UI environment is not that straightforward anymore, especially in the modern era dominated by complex front-end applications. And it’s not always fun. With the “arrival” of React, things changed a lot, especially in the way of thinking about UI in terms of components. But what about testing? Wait, testing JavaScript? Who does that? Well, that might have been the case 10 years ago, nowadays it’s a completely different story. As we all know testing such complex UIs and applications is very crucial. And stop with excuses such as “I had a tight deadline and couldn’t find the time for writing tests”. Writing tests is usually the first thing you should start with, even if you don’t strictly follow TDD. Enough with the jibber-jabber, let’s have a look at some tips and best practices we have found to be useful when testing UI / React components. Because at the end, testing should not be a pain or a burden, it’s a necessary piece of software development and you should feel comfortable as well as having fun doing it. First of all I’m going to use Jest as the test runner. Most of the things described in this article can easily be done with any other test runner, but some of them are possible because of Jest features. If you’re not using Jest, we strongly recommend to switch to it. It really steps up in terms of “Testing eXperience” and it has a lot of awesome powerful features. I’m also going to assume that you use Enzyme as a React test library. I think this speaks for itself. At this point you’re ready to start writing tests. If you do TDD that’s what you do anyway to start with. It’s a good practice to “describe” your test steps and assertions, just like you do when you write a check list. It’s good for having a mental picture of what you want to test as well as for preparing the different test setups and simply to have a list to follow. You are going to do that using “describes” and “its” (or whatever the test runner of your choice provides). That’s good, but we can do a lot better. For example, the main describe “Core::Buttons::LinkButton” might be useful to “uniquely” identify this specific test in the test runner output. Fortunately with Jest (and probably with other test runners as well) this is not necessary anymore. Jest groups all tests by their filenames. If a test fails you will then get the “path” to the failed assertion, as well as a lot of useful information. That’s one of the things I love the most about Jest, they really did an amazing job.

As you can see having targeted test assertions is really helpful. It not only makes the test easier to read but also easier to identify the specific assertion. So don’t be afraid of nesting different “describes” and to split your assertions across multiple “it” blocks. We found that is beneficial when each “it” block only contains one assertion. This allows to properly document each test using the “it” block instead of using the assertion message. What we also do is to group the main “describes” by some sort of context, which usually looks something like this: In general, you should structure your test steps by nesting them in a way that they are readable. This implies nesting “describes” on many levels. Don’t be afraid of that, it’s perfectly fine to do it, even more so if we consider the point above of having one “it” block per assertion. “describes” are meant to explain conditions, whereas “its” are meant to explain the expected output. Example of describing your test with nested blocks It’s very easy to read and to understand what’s going on. It also allows to have specific setups in each nested “describe” (e.g. rendered component props, mocked imports, etc) using “beforeEach”. Speaking about “beforeEach”, it becomes really helpful when you are testing different states of your component. Look at this: Using “beforeEach” in a nested block to have a specific setup Things to remember if you are using Jest prevent order-of-execution errors — be careful not to mix code sitting next to “describes” and “its” with “beforeEach” hooks. Because hooks are async, Jest will execute the synchronous code first instead of the “beforeEach”, as you would expect. In the first example the order-of-execution is wrong, the second example is the correct one prevent dependent tests — make sure that each “it” block can be run in isolation. The latest Jest version provides also an easy command in “watch” mode to run specific tests within a test suite. If use use iTerm, you can “cmd + click” on the file path in the stacktrace, in case the test fails, to jump into the file on the specific line. Go to “Preferences > Profiles > {profile} > Advanced > Semantic History” and provide (in case you are using Atom): You’ve got your test structure set up. You can now start testing your React component. If you are just getting started with testing in React you probably face one dilemma: how to render the component for testing it? Enzyme provides a “shallow” and a “mount” function. Which one should you use? This is really easy to answer: use “shallow”! 99% of the time it’s what you want. There has to be a damn good reason to use “mount”. You could even see it as a code smell. Why should you not use “mount”? Because tests should be isolated. When testing a component we only want to test the logic of that specific component and that component only. If you use “mount” you are automatically exposed to the logic of all components in your render tree making it impossible to only test the component in question.

Additionally, “mount” requires JSDOM and therefore slows down your tests dramatically. Even if you want to test a component in its mounted state you don’t need to use “mount”: This is more of a best practice we’ve adopted rather than a rule. Instead of passing each single prop to the component we are testing, we define a function that creates test props. Then you just spread the props when rendering the test component. Use a factory function to create default props for your component tests This approach allows us to clearly see the common props that the component expects, it keeps the test setup small and is flexible enough to easily add / override those props for special cases. Writing unit tests means testing something in isolation. When we test React components, we test them in isolation using shallow rendering. We are not interested in what sits outside of the component we are testing, therefore we define mocks to abstract away the real implementation. Furthermore, you want to check that all your functions passed as props are being called throughout the tests. To do that it’s a good practice to always provide a spy for props that are functions. You can do a lot with spies. With Jest when you call “jest.fn()” you can pass an implementation of that function that does / returns whatever you need it to do. In the example below, the “fetchData” function provides a callback that is called when the data fetching is done. We can use “jest.fn()” to simulate the success of the data fetching by executing the callback manually. This allows us to test whatever code runs as a result of a successful data fetching (e.g. show a notification, update the state, redirect to another route, etc). Example of “jest.fn()” implementation to test callback functions If you don’t use Jest, you should probably use sinon as your spy/mocking library. If you do use Jest, you have all of this out of the box. Additionally, Jest provides a really powerful module mocking system built-in. What about snapshot testing? Couldn’t we have simply tested all of the rendered components with a snapshot test? True, but that’s not always what you want. Snapshot testing is great and we should use it but we should do so with care and only when it makes sense. In general, I would say that we should be explicit on what elements are rendered or what props are passed to those elements — even if it’s a bit verbose. In the example below, we want to make sure that the “Button” is disabled if a certain limit is reached. If we explicitly test for it, we see how the output log helps us understanding the context (“rendering > <Button> > when limit is reached > should disable the <Button>”).

Nevertheless, in many simple test scenarios, it’s more than enough to just use snapshot testing. Snapshot testing is great when you want to validate the structure of something like a component or an object. Even better is to use them in combination with normal test cases: you get the benefits of snapshot testing as well as the fine-grained control of targeted assertions. lose the ability of doing TDD — well, you can’t have a snapshot of something that doesn’t exist yet lose the ability of doing RDD — the test file no longer describes what is important to be rendered in the component don’t know what the actual output “should be”, you only know what it “was” before. There are cases when the component your are testing renders a component that has a prop in the shape of a React element or a function that returns one. Example of elements rendering props that return a React element So how would you test those props? In the example above, the component renders “Table” or “Button”, but because of shallow rendering everything beyond that won’t get rendered.

This is how you can solve it — it just requires a bit more configuration. Example of testing a React element returned from a prop You simply shallow render it as a normal react component. The same thing applies for the prop being a function, you just pass the arguments based on whatever it is that you want to test. You probably already heard about this: Function as Child components. If you don’t there are plenty of articles explaining what this is / does. Or you’ve seen this before but you didn’t know it was called like this. Example of how to render a Function as Child component The “Collapsible” component basically manages the toggle state and returns a “isOpen” boolean flag to indicate the current state as well as a “toggle” function to, you know, update the state. Imagine wanting to test a “CollapsiblePanel” component which uses the “Collapsible” component. Since you’re testing the “CollapsiblePanel” component with shallow rendering, the child function of “Collapsible” won’t be executed. How do you test this then? This is how you can solve it: extract the child function into a function on the component instance, then test the function directly. Example of a component using the “Collapsible” component Now all you have to do is to call the “renderPanel” function directly and test the returned value as a normal React component. Example of testing React elements inside a Function as Child component Testing React components is not difficult. If combined with a test runner like Jest it provides a really powerful experience. Furthermore, if you follow some guidelines and have a proper structure, people in your team will write tests more consciously, resulting in higher quality, faster iterations, less bugs and more productivity. I hope the tips in this article will help you achieve that and improve your development time.|||

Working in a UI environment is not that straightforward anymore, especially in the modern era dominated by complex front-end applications. And it’s not always fun. With the “arrival” of React, things…