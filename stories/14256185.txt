You can also easily the Node REPL:

Code generated by the compiler relies on a simple runtime API that can be explained through a series of examples. While you do not have to write this API by hand, it is designed to be easily human readable and writable, in part because that makes it easier to explain.

I will explain the method first, then the method after that. Note that this is the constructor of the CommonJS object, and the and methods are custom additions to .

Here we go:

All setter functions are called synchronously before returns, with whatever values are immediately available. However, when there are import cycles, some setter functions may be called again, when the exported values change. Calling these setter functions one or more times is the key to implementing live bindings, as required by the ECMAScript 2015 specification.

While most setter functions only need to know the value of the exported symbol, the name of the symbol is also provided as a second parameter after the value. This parameter becomes important for imports (and exports, but we'll get to that a bit later):

The setter function for imports is called once for each symbol name exported from the module. If any individual value happens to change after the call to , the setter function will be called again to update that particular value. This approach ensures that the actual object is never exposed to the caller of .

Notice that this compilation strategy works equally well no matter where the declaration appears:

See for a much more detailed discussion of why nested declarations are worthwhile.

What about declarations? One option would be to transform them into CommonJS code that updates the object, since interoperability with Node and CommonJS is certainly a goal of this approach.

However, if takes a object and a map of setter functions, then it seems natural for to be method that registers getter functions. Given these getter functions, whenever is called by a parent module, the getters for the module will run, updating its object, so that the method has access to the latest exported values.

The method is called with a single object literal whose keys are exported symbol names and whose values are getter functions for those exported symbols. So, for example,

This code registers getter functions for the variables , , ..., so that can easily retrieve the latest values of those variables at any time. It's important that we register getter functions rather than storing computed values, so that other modules always can import the newest values.

Note that the call is "hoisted" to the top of the block where it appears. This is safe because the getter functions work equally well anywhere in the scope where the exported variable is declared, and a good idea because the hoisting ensures the getters are registered as early as possible.

What about declarations? It would be a mistake to defer evaluation of the expression until later, so wrapping it in a getter function is not exactly what we want.

The important point to understand here is that does not assume a getter function has been registered by for every imported symbol. Instead, only really cares about the contents of . While the method helps keep up to date, that level of sophistication isn't strictly necessary in every situation, and exports are one such situation:

Now, suppose you change the value of an exported local variable after the module has finished loading. Then you need to let the module system know about the update, and that's where comes in. The module system calls this method on your behalf whenever a module finishes loading, but you can also call it manually, or simply let generate code that calls for you whenever you assign to an exported local variable.

Calling with no arguments causes any setters that depend on the current module to be rerun, but only if the value a setter would receive is different from the last value passed to the setter.

If you pass an argument to , the value of that argument will be returned as-is, so that you can easily wrap assignment expressions with calls to :

Note that does not actually use . However, by having return unmodified, we can run setters immediately after the assignment without interfering with evaluation of the larger expression.

Because runs any setters that have new values, it's also useful for potentially risky expressions that are difficult to analyze statically:

What about declarations? The key insight here is that declarations with a clause are really just declarations that update the object instead of updating local variables:

While these examples have not covered every possible syntax for and declarations, I hope they provide the intuition necessary to imagine how any declaration could be compiled.

When I have some time, I hope to implement a live-compiling text editor to enable experimentation.|||

reify - Enable ECMAScript 2015 modules in Node today. No caveats. Full stop.