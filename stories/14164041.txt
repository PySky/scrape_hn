Kallax is a PostgreSQL typesafe ORM for the Go language.

It aims to provide a way of programmatically write queries and interact with a PostgreSQL database without having to write a single line of SQL, use strings to refer to columns and use values of any type in queries.

For that reason, the first priority of kallax is to provide type safety to the data access layer. Another of the goals of kallax is make sure all models are, first and foremost, Go structs without having to use database-specific types such as, for example, . Support for arrays of all basic Go types and all JSON and arrays operators is provided as well.

The recommended way to install is:

Imagine you have the following file in the package where your models are.

Then put the following on any file of that package:

Now all you have to do is run and a file will be generated with all the generated code for your model.

If you don't want to use , even though is the preferred use, you can just go to your package and run yourself.

Sometimes you might want to use the generated code in the same package it is defined and cause problems during the generation when you regenerate your models. You can exclude files in the package by changing the comment to the following:

A model is just a Go struct that embeds the type. All the fields of this struct will be columns in the database table.

A model also needs to have one (and just one) primary key. That is whatever field of the struct with the struct tag , which can be for a non auto-incrementable primary key or for one that is auto-incrementable. More about primary keys is discussed at the primary keys section.

First, let's review the rules and conventions for model fields:

Kallax also provides a struct that contains and that will be managed automatically.

Let's see an example of models with all these cases:

Primary key types need to satisfy the Identifier interface. Even though they have to do that, the generator is smart enough to know when to wrap some types to make it easier on the user.

The following types can be used as primary key:

If you need another type as primary key, feel free to open a pull request implementing that.

Kallax generates a constructor for your type named . But you can customize it by implementing a private constructor named . The constructor generated by kallax will use the same signature your private constructor has. You can use this to provide default values or construct the model with some values.

If you implement this constructor:

Kallax will generate one with the following signature:

IMPORTANT: if your primary key is not auto-incrementable, you should set an ID for every model you create in your constructor. Or, at least, set it before saving it. Inserting, updating, deleting or reloading an object with no primary key set will return an error.

If you don't implement your own constructor it's ok, kallax will generate one for you just instantiating your object like this:

Events can be defined for models and they will be invoked at certain times of the model lifecycle.

To implement these events, just implement the following interfaces. You can implement as many as you want:

Kallax generates a bunch of code for every single model you have and saves it to a file named in the same package.

For every model you have, kallax will generate the following for you:

Automatic for models and migrations is not yet supported, even though it will probably come in future releases.

A global variable will be created in your , that contains a field with the name of every of your models. Those are the schemas of your models. Each model schema contains all the fields of that model.

So, to access the username field of the user model, it can be accessed as:

For all of the following sections, we will assume we have a store for our model's type.

To insert a model we just need to use the method of the store and pass it a model. If the primary key is not auto-incrementable and the object does not have one set, the insertion will fail.

If our model has relationships, they will be saved (note: saved as in insert or update) as well. The relationships of the relationships will not, though. Relationships are only saved with one level of depth.

If there are any relationships in the model, both the model and the relationships will be saved in a transaction and only succeed if all of them are saved correctly.

To insert a model we just need to use the method of the store and pass it a model. It will return an error if the model was not already persisted or has not an ID.

By default, when a model is updated, all its fields are updated. You can also specify which fields to update passing them to update.

If our model has relationships, they will be saved (note: saved as in insert or update) as well. The relationships of the relationships will not, though. Relationships are only saved with one level of depth.

If there are any relationships in the model, both the model and the relationships will be saved in a transaction and only succeed if all of them are saved correctly.

To save a model we just need to use the method of the store and pass it a model. is just a shorthand that will call if the model is not yet persisted and if it is.

If our model has relationships, they will be saved as well. The relationships of the relationships will not, though. Relationships are only saved with one level of depth.

If there are any relationships in the model, both the model and the relationships will be saved in a transaction and only succeed if all of them are saved correctly.

To delete a model we just have to use the method of the store. It will return an error if the model was not already persisted.

Relationships of the model are not automatically removed using .

For that, specific methods are generated in the store of the model.

For one to many relationships:

For one to one relationships:

To perform a query you have to do the following things:

Next will automatically close the result set when it hits the end. If you have to prematurely exit the iteration you can close it manually with .

You can query just a single row with .

You can also get all of the rows in a result without having to manually iterate the result set with .

By default, all columns in a row are retrieved. To not retrieve all of them, you can specify the columns to include/exclude. Take into account that partial records retrieved from the database will not be writable. To make them writable you will need to the object.

Kallax generates a for every field of your model for which it makes sense to do so. What is a ? It is a shorthand to add a condition to the query for a specific field.

Consider the following model:

Four s will be generated for this model:

That way, you can just do the following:

Why are there three different types of methods generated?

Instead of passing the query to or , you can pass it to to get the number of rows in the resultset.

By default, no relationships are retrieved unless the query specifies so.

For each of your relationships, a method in your query is created to be able to include these relationships in your query.

One to one relationships:

One to one relationships are always included in the same query. So, if you have 4 one to one relationships and you want them all, only 1 query will be done, but everything will be retrieved.

One to many relationships:

To avoid the N+1 problem with 1:N relationships, kallax performs batching in this case. So, a batch of users are retrieved from the database in a single query, then all the posts for those users and finally, they are merged. This process is repeated until there are no more rows in the result. Because of this, retrieving 1:N relationships is really fast.

The default batch size is 50, you can change this using the method all queries have.

NOTE: if a filter is passed to a method we can no longer guarantee that all related objects are there and, therefore, the retrieved records will not be writable.

If, for example, you have a model that is not writable because you only selected one field you can always reload it and have the full object. When the object is reloaded, all the changes made to the object that have not been saved will be discarded and overwritten with the values in the database.

Reload will not reload any relationships, just the model itself. After a the model will always be writable.

You can query arbitrary JSON using the JSON operators defined in the kallax package. The schema of the JSON (if it's a struct, obviously for maps it is not) is also generated.

To execute things in a transaction the method of the model store can be used. All the operations done using the store provided to the callback will be run in a transaction. If the callback returns an error, the transaction will be rolled back.

The fact that a transaction receives a store with the type of the model can be a problem if you want to store several models of different types. Kallax has a method named that initializes a store of the type you want to have the same underlying store as some other.

can be used inside a transaction, but it does not open a new one, reuses the existing one.

Kallax can generate migrations for your schema automatically, if you want to. It is a process completely separated from the model generation, so it does not force you to generate your migrations using kallax.

Sometimes, kallax won't be able to infer a type or you will want a specific column type for a field. You can specify so with the struct tag on a field.

You can see the full list of default type mappings between Go and SQL.

To generate a migration, you have to run the command .

The command accepts the following flags:

Additionally, there is a file where schema of the last migration is store to diff against the current models.

To run a migration you can either use or . will upgrade your database and will downgrade it.

These are the flags available for and :

Any other type must be explicitly specified.

You can create custom operators with kallax using the and functions.

creates an operator with the specified format. It returns a function that given a schema field and a value returns a condition.

The format is a string in which will get replaced with the schema field and will be replaced with the value.

does exactly the same as the previous one, but it accepts a variable number of values.

This function already takes care of wrapping with parenthesis.

If you need further customization, you can create your own custom operator.

You need these things:

Imagine we want a greater than operator that only works with integers.

For most of the operators, and are enough, so the usage of these functions is preferred over the completely custom approach. Use it only if there is no other way to build your custom operator.

It is possible to debug the SQL queries being executed with kallax. To do that, you just need to call the method of a store. This returns a new store with debugging enabled.

This will log to stdout using .

You can use a custom logger (any function with a type using the method instead.

Here are some benchmarks against GORM, SQLBoiler and . In the future we might add benchmarks for some more complex cases and other available ORMs.

As we can see on the benchmark, the performance loss is not very much compared to raw , while GORMs performance loss is very big and the memory consumption is way higher. SQLBoiler, on the other hand, has a lower memory footprint than kallax, but a bigger performance loss (though not very significant in most cases).

Source code of the benchmarks can be found on the benchmarks folder.

Kallax is a code generation tool, so it obviously has not been tested with all possible types and cases. If you find a case where the code generation is broken, please report an issue providing a minimal snippet for us to be able to reproduce the issue and fix it.

Kallax is a very opinionated ORM that works for us, so changes that make things not work for us or add complexity via configuration will not be considered for adding. If we decide not to implement the feature you're suggesting, just keep in mind that it might not be because it is not a good idea, but because it does not work for us or is not aligned with the direction we want kallax to be moving forward.

For obvious reasons, an instance of PostgreSQL is required to run the tests of this package.

By default, it assumes that an instance exists at with an user, password and database name all equal to .

If that is not the case you can set the following environment variables:|||

go-kallax - Kallax is a PostgreSQL typesafe ORM for the Go language.