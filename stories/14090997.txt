Every developer knows the importance of keeping the code as much decoupled as possible. Loosely coupling drives your code to smaller responsibilities and, consequently, granular objects which bring us fast understanding and easy maintenance. Sometimes, one of the strategies which can aid you to achieve this is to use events to make those granular objects communicate each other without necessarily know each other. However, bad implementation of some points of event-driven programming may lead you to a terrible nightmare when you need to revisit any part of those flows. Yes, event-driven programming has some traps and into three of them I have already fallen.

The first trap could be set when you are naming the event. It should say what happened, not what must happen. The component that is publishing some event should never know anything outside it. Though it might be so clear now, it can be easily get messy. So, always ensure the event you’re publishing is saying what happened, not what other part of your code needs to do. More about event names here.

Some implementations of pub/sub pattern could offer the possibility to target your event. In other words, you can avoid some parts of your application to listen an event in favor of other ones. Taking this approach, you may fall in the second trap. To get confused about who is and who isn’t listening some event. I definitely see no sense in this kind of implementation, because when publishing some event it should reach your whole application and every part interested in listening it should be notified. Yes, it should be omnidirectional and the fact it gets broadcasted to all directions should not produce any side effect. Remembering, an event just says what happened, not what must happen. The fact the event to be published globally should not be an issue for any other part of your application.

Event names are constants. The name of any event will not change in the runtime. So, write them in constants. These days, I use to write a dedicated module to store a hash containing event names. Doing so, I even take the benefit of having all events listed in just one place. It helps me understand which are all the events my application is making use of. Also, it prevents name collision and make naming conventions explicit for everyone. When you link your events with constants, you make them more consistent and avoid the trap of spreading out plain words that can be misspelled leading the application to an unexpected behavior. From now on, you can avoid three traps that event-driven programming might set to you. Do you know a couple more traps? Please, don’t hesitate in use the comments section to share.|||

Every developer knows the importance of keeping the code as much decoupled as possible. Loosely coupling drives your code to smaller responsibilities and, consequently, granular objects which bring…