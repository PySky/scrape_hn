The following should be considered 1) incomplete, and 2) REQUIRED READING. I don't always agree with the style written by the authors below, but one thing is certain: They are consistent. Furthermore, these are authorities on the language.

Projects should always attempt to include some generic means by which source can be linted, tested and compressed in preparation for production use. For this task, grunt by Ben Alman is second to none and has officially replaced the "kits/" directory of this repo.

Projects must include some form of unit, reference, implementation or functional testing. Use case demos DO NOT QUALIFY as "tests". The following is a list of test frameworks, none of which are endorsed more than the other.

The following sections outline a reasonable style guide for modern JavaScript development and are not meant to be prescriptive. The most important take-away is the law of code style consistency. Whatever you choose as the style for your project should be considered law. Link to this document as a statement of your project's commitment to code style consistency, readability and maintainability.

if/else/for/while/try always have spaces, braces and span multiple lines (condition) (); (condition) iterating ; ( i ;i ;i ) (); ( condition ) { } ( condition ) { } ( i ; i ; i ) { } i, length ; ( i ; i length; i ) { } i , length ; ( ; i length; i ) { } prop; ( prop object ) { } ( ) { } { } foo , num , undef; array [], object {}; Using only one `var` per scope (function) or one `var` for each variable, promotes readability and keeps your declaration list free of clutter. Using one `var` per variable you can take more control of your versions and makes it easier to reorder the lines. One `var` per scope makes it easier to detect undeclared variables that may become implied globals. Choose better for your project and never mix them. foo , bar ; qux; foo ; bar ; qux; foo , bar , qux; foo , bar , quux; var statements should always be in the beginning of their respective scope (function). () { bar , qux; } () { bar , qux; all statements after the variables declarations. } const and let, from ECMAScript 6, should likewise be at the top of their scope (block). () { foo, bar; ( condition ) { bar ; } } () { foo; ( condition ) { bar ; } } ( , ) { } ( arg1, argN ); ( ) { number number; } ( ); ( , ) { ( number number ); } ( , ( ) { }); ( ) { number number; }; This preferred form has the added value of being able to call itself and have an identity in stack traces: ( ) { ( number ) { ; } number ( number ); }; ( ) { . options; } fooBar ({ a }); . ; ( () { Note there is no extra space between the first paren of the executing function call and the word "function" }); ([ , ]); ({ a , b }); ( ); ( ( obj) ) { obj ( . defaults). ; } In sections 2.A-2.C, the whitespace rules are set forth as a recommendation with a simpler, higher purpose: consistency. It's important to note that formatting preferences, such as "inner whitespace" should be considered optional, but only one style should exist across the entire source of your project. Whether you prefer single or double shouldn't matter, there is no difference in how JavaScript parses them. What ABSOLUTELY MUST be enforced is consistency. Never mix quotes in the same project. Pick one style and stick with it. Whitespace can ruin diffs and make changesets impossible to read. Consider incorporating a pre-commit hook that removes end-of-line whitespace and blanks spaces on empty lines automatically. Consider the implications of the following... `foo` has been declared with the value `0` and its type is `number` foo ; Somewhere later in your code, you need to update `foo` with a new value derived from an input element foo . ( ). ; If you were to test `typeof foo` now, the result would be `string` This means that if you had logic that tested `foo` like: ( foo ) { (); } `importantTask()` would never be evaluated, even though `foo` has a value of "1" You can preempt issues by using smart coercion with unary + or - operators: foo . ( ). ; ^ unary + operator will convert its right side operand to a number ( foo ) { (); } Here are some common cases along with coercions: array [ , , ]; . ( ); . ( ); . ( ); . ( ); Note that the above should be considered "unnecessarily clever" Prefer the obvious approach of comparing the returned value of ( . ( ) ) { } num ; ( num, ); num; num ; num ; Keep in mind however, that negative numbers will be treated differently... neg ; ( neg, ); neg; neg ; neg ; When only evaluating that an array has length, ( . ) ( . ) When only evaluating that an array is empty, ( . ) ( . ) When only evaluating that a string is not empty, ( string ) ( string ) When only evaluating that a string _is_ empty, ( string ) ( string ) When only evaluating that a reference is true, ( foo ) ...evaluate like you mean it, take advantage of built in capabilities: ( foo ) When evaluating that a reference is false, ( foo ) ( foo ) ...Be careful, this will also match: 0, "", null, undefined, NaN If you _MUST_ test for a boolean false, then use ( foo ) When only evaluating a ref that might be null or undefined, but NOT false, "" or 0, ( foo foo ) ...take advantage of == type coercion, like this: ( foo ) Remember, using == will match a `null` to BOTH `null` and `undefined` but not `false`, "" or 0 ALWAYS evaluate for the best, most accurate result - the above is a guideline, not a dogma. Prefer `===` over `==` (unless the case requires loose type evaluation) === does not coerce type, which means that: ; == does coerce type, which means that: ; , , , , , , , ( ( ) { Module ( () { data ; { This is some boolean property bool , string , array [ , , , ], object { lang }, () { get the current value of `data` data; }, ( ) { set the value of `data` and return it ( data value ); } }; })(); Other things might happen here expose our module to the global object . Module; })( ); ( ( ) { ( ) { . foo; ; } . . () { . ; }; . . ( ) { ( . val ); }; To call constructor's without `new`, you might do this: ( ) { ( foo ); }; expose our constructor to the global object . ctor; })( ); A. You are not a human code compiler/compressor, so don't try to be one. The following code is an example of egregious naming: Example of code with poor names ( ) { . (s); } i,a [],els ( ); (i ;i . ;i ){ . (els[i]);} Without a doubt, you've written code like this - hopefully that ends today. Here's the same piece of logic, but with kinder, more thoughtful naming (and a readable structure): Example of code with improved names ( ) { . ( selector ); } idx , elements [], matches ( ), length . ; ( ; idx length; idx ) { . ( matches[ idx ] ); } is a string is an array strings camelCase; and var declarations PascalCase; constructor rDesc = functionNamesLikeThis; variableNamesLikeThis; ConstructorNamesLikeThis; EnumNamesLikeThis; methodNamesLikeThis; SYMBOLIC_CONSTANTS_LIKE_THIS; Beyond the generally well known use cases of and , always prefer or a functional equivalent, for creating definitions for later invocation. Only resort to aliasing when no preferable option is available. ( ) { . ; this will be called continuously . ( . , ( ) { with the most recent value from the . data; }. ( ) ); Throttle the frequency of events emitted from ( () { . ( ); }. ( ), . ); } When unavailable, functional equivalents to exist in many modern JavaScript libraries. As a last resort, create an alias to using as an Identifier. This is extremely bug prone and should be avoided whenever possible. Several prototype methods of ES 5.1 built-ins come with a special signature, which should be used whenever possible obj; obj { f , b , q }; . ( obj ). ( ( ) { |this| now refers to `obj` . ( [ key ] ); }, obj ); <-- the last arg is `thisArg` can be used with , , , , This section will serve to illustrate ideas and concepts that should not be considered dogma, but instead exists to encourage questioning practices in an attempt to find better ways to do common JavaScript programming tasks. A. Using should be avoided, modern method tracing will blacklist functions with switch statements There seems to be drastic improvements to the execution of statements in latest releases of Firefox and Chrome. http://jsperf.com/switch-vs-object-literal-vs-module Notable improvements can be witnessed here as well: https://github.com/rwldrn/idiomatic.js/issues/13 ( foo ) { : (); ; : (); ; : something to default to ; } A alternate approach that supports composability and reusability is to use an object to store "cases" and a function to delegate: cases, delegator; Example returns for illustration only. cases { () { [ , . ]; }, () { [ , . ]; }, () { [ , . ]; } }; () { args, key, delegate; args []. . ( ); shift the case key from the arguments key . (); delegate . ; Derive the method to delegate operation to ( . ( key ) ) { delegate cases[ key ]; } The scope arg could be set to something specific, in this case, |null| will suffice . ( , args ); }; Put the API in 7.A.1.2 to work: ( , , , , , ); Of course, the `case` key argument could easily be based on some other arbitrary condition. caseKey, someUserInput; someUserInput ; ( someUserInput ) { caseKey ; } { caseKey ; } caseKey someUserInput ; ( caseKey, someUserInput ); (); The basic principle here is: Don't do stupid shit and everything will be ok. To reinforce this concept, please watch the following presentation: Single line above the code that is subject Programs should be written in one language, whatever that language may be, as dictated by the maintainer or maintainers.

Any project that cites this document as its base style guide will not accept comma first code formatting, unless explicitly specified otherwise by that project's author.



Principles of Writing Consistent, Idiomatic JavaScript by Rick Waldron and Contributors is licensed under a Creative Commons Attribution 3.0 Unported License.

Based on a work at github.com/rwldrn/idiomatic.js.|||

idiomatic.js - Principles of Writing Consistent, Idiomatic JavaScript