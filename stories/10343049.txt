Perl 6 is a highly capable, feature-rich programming language made for at least the next hundred years.

The primary Perl 6 compiler is called Rakudo, which runs on the JVM and the MoarVM.

Meta-note : the triple pound signs are here to denote headlines, double paragraphs, and single notes.

# subroutines or functions as most other languages call them are # created with the `sub` keyword. { } ( ) { # You can provide the type of an argument # and it'll be checked at compile-time. ; } ## It can also have optional arguments: ( ?) { "I might return `(Any)` (Perl's 'null'-like value) if I don't have an argument passed, or I'll return my argument" ; ; } ; (); ( ); ## You can also give them a default value when they're not passed: ( = ) { ; } ; (); ( ); ## You can also, by using a syntax akin to the one of hashes # They're optional, and will default to "Any". ( , : ) { + ; } ( , => ); # There's one gotcha to be aware of, here: # If you quote your key, Perl 6 won't be able to see it at compile time, # and you'll have a single Pair object as a positional parameter, ( , => ); ( , : ( )); # To make a named argument mandatory, you can use `?`'s inverse, `!` (: !) { ; } ( => ); ; ( ); ( , : ) { ; } # ... you can use the same "short boolean" hash syntax: ( , : ); ( , :! ); ## You can also provide your named arguments with defaults: (: = ) { ; } ; ( => ); # Since you can omit parenthesis to call a function with no arguments, # you need "&" in the name to store `say-hello` in a variable. = ; = { } # A sub can have a "slurpy" parameter, or "doesn't-matter-how-many" ( , * ) { #`*@` (slurpy) will "take everything else" # Note: you can have parameters *before* a slurpy one (like here), . ( ) ~ ; } ( , , ); # Note that the splat (the *) did not ## You can call a function with an array using the # (it's not actually the only role of this operator, but it's one of them) ( , , ) { ; } (| ); # `@array` got "flattened" as a part of the argument list

## Since Perl languages are very much operator-based languages, ## Perl 6 operators are actually just funny-looking subroutines, in syntactic ## categories, like infix:<+> (addition) or prefix:<!> (bool not). # - "prefix": before (like `!` in `!True`). # - "postfix": after (like `++` in `$a++`). # - "infix": in between (like `*` in `4 * 3`). # - "circumfix": around (like `[`-`]` in `[1, 2]`). # - "post-circumfix": around, after another term (like `{`-`}` in `%hash{'key'}`) ## The associativity and precedence list are explained below. == ; != ; ; ; ! ; ( , ) ( , ); # Aliases the left hand side to $_ and then evaluates the right hand side. # Here are some common comparison semantics: ~~ ; ~~ ; # Regex - For matching a regular expression against the left side. # Returns a (Match) object, which evaluates as True if regexp matches. = ~~ ; ; . ; ~~ ; # Type - Checks if left side "has type" (can check superclasses and roles) ~~ ; # Smart-matching against a boolean always returns that boolean (and will warn). ~~ ; ~~ ; # For a complete list of combinations, use this table: # You also, of course, have `<`, `<=`, `>`, `>=`. # Their string equivalent are also avaiable : `lt`, `le`, `gt`, `ge`. > ; .. ; # `^` on either side them exclusive on that side : ^..^ ; # This also works as a shortcut for `0..^N`: ^ ; # This also allows us to demonstrate that Perl 6 has lazy/infinite arrays, # using the Whatever Star: = ..*; # 1 to Infinite ! `1..Inf` is the same. [^ ]; # you can pass arrays as subscripts and it'll return # an array of results. This will print # "1 2 3 4 5 6 7 8 9 10" (and not run out of memory !) # Note : when reading an infinite list, Perl 6 will "reify" the elements # it needs, then keep them in memory. They won't be calculated more than once. # It also will never calculate more elements that are needed. # An array subscript can also be a closure. # It'll be called with the length as the argument ( , [ ..*]); # which is equivalent to: ( , [-> { .. }]); # Note: if you try to do either of those with an infinite array, # You can use that in most places you'd expect, even assigning to an array = ^ ; # Here numbers increase by "6"; more on `...` operator later. = , ... * > ; [ ..*] = , ... *; # even though the sequence is infinite, # only the 15 needed values will be calculated. ; && ; # 4, which is Truthy. Calls `.Bool` on `4` and gets `True`. || ; ## * Short-circuit (and tight) versions of the above # Returns the first argument that evaluates to False, or the last argument. ( , , ) = , , ; && && ; # Returns 0, the first False value # || Returns the first argument that evaluates to True || ; # And because you're going to want them, # you also have compound assignment operators: *= ; %%= ; .= ; # calls the `sort` method and assigns the result back

# It's the ability to "extract" arrays and keys (AKA "destructuring"). # It'll work in `my`s and in parameter lists. ( , ) = , ; ; ($, $, ) = , , ; ; ( , * ) = , , ; # Yes, it's the same as with "slurpy subs" (* ) = ; ( [ , ]) { "My first is $fst, my second is $snd ! All in all, I'm @array[]." ; # (^ remember the `[]` to interpolate the array) } ( ); #=> My first is 2, my second is 3 ! All in all, I'm 2 3 # If you're not using the array itself, you can also keep it anonymous, (@ [ ]) { } ( ); ( ); # Throws an error "Too many positional parameters passed" # (which means the array is too big). # You can also use a slurp ... (@ [ , * ]) { # You could keep `*@rest` anonymous + . ; # Here, `@rest` is `(3,)`, since `$fst` holds the `2`. } ( ); # You could even extract on a slurpy (but it's pretty useless ;-).) (*@ [ ]) { ; } ( ); ( , ); # errors with "Too many positional parameters passed" # You can also destructure hashes (and classes, which you'll learn about later !) # The hash can stay anonymous if you only need the values you extracted. (% (: ( ), : ( ))) { ; } # Then call it with a hash: (you need to keep the brackets for it to be a hash) ({ => , => }); #key-of(%hash); # the same (for an equivalent `%hash`) ## The last expression of a sub is returned automatically # (though you may use the `return` keyword, of course): ( ) { + ; } = ( ); # This is true for everything, except for the looping constructs # (due to performance reasons): there's reason to build a list # if we're just going to discard all the results. # If you still want to build one, you can use the `do` statement prefix: # (or the `gather` prefix, which we'll see later) ( ) { ^ { # note the use of the range-to prefix operator `^` (`0..^N`) } } = ( );

## You can create a lambda with `-> {}` ("pointy block") or `{}` ("block") = -> { "The argument passed to this lambda is $argument" } # `-> {}` and `{}` are pretty much the same thing, except that the former can # take arguments, and that the latter can be mistaken as a hash by the parser. # We can, for example, add 3 to each value of an array using map: = ({ + }, ); # A sub (`sub {}`) has different semantics than a block (`{}` or `-> {}`): # A block doesn't have a "function context" (though it can have arguments), # which means that if you return from it, # you're going to return from the parent function. Compare: ( , ) { # this will `return` out of the `is-in` sub # once the condition evaluated to True, the loop won't be run anymore ({ == }, ); } ( ) { # this will produce an array of `True` and `False`: # (you can also say `anon sub` for "anonymous subroutine") ( ( ) { { } { } }, ); # ^ the `return` only returns from the anonymous `sub` } # You can also use the "whatever star" to create an anonymous function # (it'll stop at the furthest operator in the current expression) = (*+ , ); # `*+3` is the same as `{ $_ + 3 }` = (*+*+ , ); (*/ )( ); ((*+ )/ )( ); # But if you need to have more than one argument (`$_`) # in a block (without wanting to resort to `-> {}`), # you can also use the implicit argument syntax, `$^` : ({ + + }, ); ( ( , ) { + + }, );

# By using `try` and `CATCH` you can contain and handle exceptions without # disrupting the rest of the program. `try` will set the last exception to # the special variable `$!` Note: This has no relation to $!variables. ; ; #> Well, I tried! Failed to open file #foo: no such file or directory # Now, what if we want more control over handling the exception? # Unlike many other languages, in Perl 6, you put the `CATCH` block *within* # the block to `try`. Similar to how $_ was set when we 'disarmed' the # exception with orelse, we also use $_ in the CATCH block. # Note: ($! is only set *after* the `try` block) # By default, a `try` has a `CATCH` block that catches { = ( %% ); { } } #=> Something happened: Attempt to divide by zero using infix:<%%> # You can redefine it using `when`s (and `default`) # to handle the exceptions you want: { ; { # In the `CATCH` block, the exception is set to $_ :: { } #=>Error: Failed to open file /dir/foo: no such file or directory # Any other exception will be re-raised, since we don't have a `default` # Basically, if a `when` matches (or there's a `default`) marks the # "handled" so that it doesn't get re-thrown from the `CATCH`. # You still can re-throw the exception (see below) by hand. } } # There are also some subtleties to exceptions. Some Perl 6 subs return a # `Failure`, which is a kind of "unthrown exception". They're not thrown until # you tried to look at their content, unless you call `.Bool`/`.defined` on # (the `.handled` method is `rw`, so you can mark it as `False` back yourself) # You can throw a `Failure` using `fail`. Note that if the pragma `use fatal` # is on, `fail` will throw an exception (like `die`). ; # We're not trying to access the value, so no problem. { ; { { "It threw because we tried to get the fail's value!" } } } # There is also another kind of exception: Control exceptions. # Those are "good" exceptions, which happen when you change your program's flow, # using operators like `return`, `next` or `last`. # You can "catch" those with `CONTROL` (not 100% working in Rakudo yet).

# In Perl 6, you get different behaviors based on how you declare a variable. # You've already seen `my` and `has`, we'll now explore the others. ## * `our` declarations happen at `INIT` time -- (see "Phasers" below) # It's like `my`, but it also creates a package variable. # (All packagish things (`class`, `role`, etc) are `our` by default) { = ; # Note: you can't put a type constraint like Int on an = ; { { # If you try to make inner `sub`s `our`... # Better know what you're doing (Don't !). "Don't do that. Seriously. You'll get burned." ; } { # `my sub` is the default "Can't access me from outside, I'm 'my'!" ; } ++ ; # Increment the package variable and output its value } } ; ; #=> (Any) This will not work. ; ; #=> 3 # Notice how the value of $our-var was ; # You can use the `constant` keyword to declare a compile-time variable/symbol: = ; = ; # And if you're wondering, yes, it can also contain infinite lists. = , ... *; [^ ]; ## * `state` (happens at run time, but only once) # State variables are only initialized one time # (they exist in other langages such as C as `static`) { = ; ; } ^ ; # will print the same number 10 times # Note, however, that they exist separately in different enclosing contexts. # If you declare a function with a `state` within a loop, it'll re-create the # variable for each iteration of the loop. See: ^ -> { { = ; # This will be a different value for every value of `$a` } ^ -> { ; # This will print the same value 5 times, but only 5. } }

# Phasers in Perl 6 are blocks that happen at determined points of time in your # program. They are called phasers because they mark a change in the phase # of a program. For example, when the program is compiled, a for loop runs, # you leave a block, or an exception gets thrown. (`CATCH` is actually a phaser !) # Some of them can be used for their return values, some of them can't # (those that can have a "[*]" in the beginning of their explanation text). { "[*] Runs at compile time, as soon as possible, only once" } { "[*] Runs at compile time, as late as possible, only once" } { "[*] Runs at run time, as soon as possible, only once" } { "Runs at run time, as late as possible, only once" } { } { "Runs everytime you leave a block, even when an exception } { before ENTER (especially useful for loops)" } { { > } # This is going to blow up with "Precondition failed" } { after LEAVE (especially useful for loops)" } { { < } # This is going to blow up with "Postcondition failed" } { { "Runs when you exit a block successfully (without throwing an exception)" } { "Runs when you exit a block unsuccessfully (by throwing an exception)" } } ^ { { "[*] The first time the loop is run, before ENTER" } { } { } } { "When a role is composed into a class. /!\ NOT YET IMPLEMENTED" } # They allow for cute tricks or clever code ...: ~ ( - ) ~ ; { . ; . ; # commit the transaction if all went well . ; # or rollback if all hell broke loose }

# Okay, you've been reading all of that, so I guess I should try # to show you something exciting. # I'll tell you a little secret (or not-so-secret): # In Perl 6, all operators are actually just funny-looking subroutines. # You can declare an operator just like you declare a sub: ( ) { # (yes, it's the "words operator" `<>`) ; } ; # you can still call the sub with its "full name" [*] 2..$n; # using the reduce meta-operator ... See below ;-) ! # Postfix operators (after) have to come *directly* after the term. # No whitespace. You can use parentheses to disambiguate, i.e. `(5!)!` ( , ) { ^ { (); # You need the explicit parentheses to call the function in `$r`, # else you'd be referring at the variable itself, like with `&r`. } } -> { }; # For circumfix and post-circumfix ones ( ) { ** } [ ]; # circumfix is around. Again, no whitespace. ( , ) { # "after a term, around something" . ( , ); } { }; # after the term `"abc"`, and around the index (1) # This really means a lot -- because everything in Perl 6 uses this. # For example, to delete a key from a hash, you use the `:delete` adverb { }: ; ( , , : ); # (you can call operators like that) # It's *all* using the same building blocks! # - used to build the language - are available to you. # (you are, obviously, recommended against making an operator out of # *everything* -- with great power comes great responsibility)

# Oh boy, get ready. Get ready, because we're delving deep # into the rabbit's hole, and you probably won't want to go # back to other languages after reading that. # (I'm guessing you don't want to already at that point). # Meta-operators, as their name suggests, are *composed* operators. # It's a prefix meta-operator that takes a binary function and # one or many lists. If it doesn't get passed any argument, # it either returns a "default value" for this operator # (a meaningless value) or `Any` if there's none (examples below). # Otherwise, it pops an element from the list(s) one at a time, and applies # the binary function to the last result (or the list's first element) # To sum a list, you could use the reduce meta-operator with `+`, i.e.: [+] , , ; [*] ; # You can reduce with any operator, not just with mathematical ones. # For example, you could reduce with `//` to get # the first defined element of a list: [//] , , , , ; [*] (); [+] (); [//]; # There's no "default value" for `//`. # You can also call it with a function you made up, using double brackets: ( , ) { + } [[ ]] , , ; # This one is an infix meta-operator than also can be used as a "normal" # operator. It takes an optional binary function (by default, it just creates # a pair), and will pop one value off of each array and call its binary function # on these until it runs out of elements. It returns an array with all of these ( , ) ( , ); # ((1, 3), (2, 4)), since by default, the function makes an array + ; # Since `Z` is list-associative (see the list above), # you can use it on more than one list ( , ) || ( , ) || ( , ); # And, as it turns out, you can also use the reduce meta-operator with it: [ ||] ( , ), ( , ), ( , ); ## And to end the operator list: # The sequence operator is one of Perl 6's most powerful features: # it's composed of first, on the left, the list you want Perl 6 to deduce from # (and might include a closure), and on the right, a value or the predicate # that says when to stop (or Whatever for a lazy infinite list). = , , ... ; #my @list = 1, 3, 6 ... 10; # this dies because Perl 6 can't figure out the end = , , ...^ ; # as with ranges, you can exclude the last element # (the iteration when the predicate matches). = , , ... * > ; # you can use a predicate # (with the Whatever Star, here). = , , ... { > }; # (equivalent to the above) = , , *+* ... *; = , , -> , { + } ... *; # (equivalent to the above) = , , { + } ... *; #(... also equivalent to the above) # $a and $b will always take the previous values, meaning here # they'll start with $a = 1 and $b = 1 (values we set by hand). # then $a = 1 and $b = 2 (result from previous $a+$b), and so on. [^ ]; # (using a range as the index) # Note : as for ranges, once reified, elements aren't re-calculated. # That's why `@primes[^100]` will take a long time the first time you print

# I'm sure a lot of you have been waiting for this one. # Well, now that you know a good deal of Perl 6 already, we can get started. # First off, you'll have to forget about "PCRE regexps" (perl-compatible regexps). # IMPORTANT: Don't skip them because you know PCRE. They're different. # Some things are the same (like `?`, `+`, and `*`), # but sometimes the semantics change (`|`). # Make sure you read carefully, because you might trip over a new behavior. # Perl 6 has many features related to RegExps. After all, Rakudo parses itself. # We're first going to look at the syntax itself, # then talk about grammars (PEG-like), differences between # `token`, `regex` and `rule` declarators, and some more. # Side note: you still have access to PCRE regexps using the `:P5` modifier. # (we won't be discussing this in this tutorial, however) # The pecking order for ambiguous parses is determined by a multi-level # - Longest token matching. `foo\s+` beats `foo` (by 2 or more positions) # - Declaration from most-derived to less derived grammars ~~ ; ~~ ; #=> True # More readable with some spaces! # In all our examples, we're going to use the smart-matching operator against # a regexp. We're converting the result using `so`, but in fact, it's # returning a `Match` object. They know how to respond to list indexing, # The results of the match are available as `$/` (implicitly lexically-scoped). # You can also use the capture variables which start at 0: # You can also note that `~~` does not perform start/end checking # (meaning the regexp can be matched with just one char of the string), # we're going to explain later how you can do it. # In Perl 6, you can have any alphanumeric as a literal, # everything else has to be escaped, using a backslash or quotes. ~~ ; # `True`. Wouldn't mean the same if `|` wasn't escaped ~~ ; # `True`. Another way to escape it. # The whitespace in a regexp is actually not significant, # unless you use the `:s` (`:sigspace`, significant space) adverb. ~~ ; #> `False`. Space is not significant here ~~ ; #> `True`. We added the modifier `:s` here. # If we use only one space between strings in a regex, Perl 6 will warn us: ~~ ; #> 'False' #> Space is not significant here; please # use quotes or :s (:sigspace) modifier (or, to suppress this warning, omit the # space, or otherwise change the spacing) # To fix this and make the spaces less ambiguous, either use at least two # spaces between strings or use the `:s` adverb. # As we saw before, we can embed the `:s` inside the slash delimiters, but we can # also put it outside of them if we specify `m` for 'match': ~~ ; # By using `m` to specify 'match' we can also use delimiters other than slashes: ~~ ; # Use the :i adverb to specify case insensitivity: ~~ ; # It is, however, important as for how modifiers (that you're gonna see just below) ~~ ; ~~ ; ~~ ; # ... As you read just before, whitespace is important because it determines # which part of the regexp is the target of the modifier: ~~ ; # `False`. Only the `c` is optional ~~ ; ~~ ; # `True`. The whole "abc" group is optional. # Here (and below) the quantifier applies only to the `b` ~~ ; # `False`; `+` wants at least one matching ~~ ; ~~ ; ~~ ; ~~ ; ~~ ; ~~ ; # If you squint hard enough, you might understand # why exponentation is used for quantity. ~~ ; ~~ ; # `True` (one to three times) ~~ ; ~~ ; ~~ ; # Character classes are the equivalent of PCRE's `[]` classes, but # they use a more perl6-ish syntax: ~~ ; ~~ ; # Just like in normal regexes, if you want to use a special character, escape it # (the last one is escaping a space) ~~ ; # You'll get a warning if you put duplicate names # (which has the nice effect of catching the wrote quoting:) ~~ ; # You can also negate them ... (equivalent to `[^]` in PCRE) ~~ ; ~~ ; # False (any letter except f and o) ~~ ; # True (no letter except f and o) ~~ ;

# Group: you can group parts of your regexp with `[]`. # These groups are *not* captured (like PCRE's `(?:)`). ~~ ; # `True`. The grouping does pretty much nothing ~~ ; # We match the "012" 1 or more time (the `+` was applied to the group). # But this does not go far enough, because we can't actually get back what # Capture: We can actually *capture* the results of the regexp, using parentheses. ~~ ; # `True`. (using `so` here, `$/` below) # So, starting with the grouping explanations. # As we said before, our `Match` object is available as `$/`: ; # Will print some weird stuff (we'll explain) (or "Nil" if nothing matched). # As we also said before, it has array indexing: [ ]; # Here, we have an array of these. ; # Our capture is `$0` because it's the first and only one capture in the regexp. # You might be wondering why it's an array, and the answer is simple: # Some capture (indexed using `$0`, `$/[0]` or a named one) will be an array # IFF it can have more than one element # (so, with `*`, `+` and `**` (whatever the operands), but not with `?`). # Let's use examples to see that: ~~ ; [ ]; . ; # It can't be more than one, so it's only a single match object. ~~ ; . ; # This capture did not match, so it's empty ~~ ; . ; # A specific quantifier will always capture an Array, # may it be a range or a specific value (even 1). # The captures are indexed per nesting. This means a group in a group will be nested # under its parent group: `$/[0][0]`, for this code: ~~ ; [ ]. ; [ ][ ]. ; # This stems from a very simple fact: `$/` does not contain strings, integers or arrays, # it only contains match objects. These contain the `.list`, `.hash` and `.Str` methods. # (but you can also just use `match<key>` for hash access [ ]. . ; # We can see it's a list of Match objects. Those contain # a bunch of infos: where the match started/ended, # the "ast" (see actions later), etc. # You'll see named capture below with grammars. ## Alternatives - the `or` of regexps # WARNING: They are DIFFERENT from PCRE regexps. ~~ ; ~~ ; # The difference between this `|` and the one you're used to is LTM. # LTM means "Longest Token Matching". This means that the engine will always # try to match as much as possible in the strng ~~ ; # To decide which part is the "longest", it first splits the regex in two parts: # The "declarative prefix" (the part that can be statically analyzed) # sub-rule calls (not yet introduced), literals, characters classes and quantifiers. # The latter include everything else: back-references, code assertions, # and other things that can't traditionnaly be represented by normal regexps. # Then, all the alternatives are tried at once, and the longest wins. / \ + [ || ] /; / \ * [ \ & ] [ | ] /; # However, closures and recursion (of named regexps) are procedural. # ... There are also more complicated rules, like specificity # Note: the first-matching `or` still exists, but is now spelled `||` ~~ ;

# It's considered by now you know the Perl6 basics. # This section is just here to list some common operations, # but which are not in the "main part" of the tutorial to bloat it up # They return one value of the `Order` enum : `Less`, `Same` and `More` # (which numerify to -1, 0 or +1). <=> ; ; ; ; ; # Like `or` and `||`, but instead returns the first *defined* value : // // // ; # Returns `True` if one (and only one) of its arguments is true ^^ ; # The flip flop operators (`ff` and `fff`, equivalent to P5's `..`/`...`). # are operators that take two predicates to test: # They are `False` until their left side returns `True`, then are `True` until # Like for ranges, you can exclude the iteration when it became `True`/`False` # by using `^` on either side. # Let's start with an example : <well met young hero we shall meet later> { ^ { # Won't enter the if for "met" . } == == { "This ... probably will never run ..." ; } } # This will print "young hero we shall meet" (excluding "met"): # the flip-flop will start returning `True` when it first encounters "met" # (but will still return `False` for "met" itself, due to the leading `^` # on `ff`), until it sees "meet", which is when it'll start returning `False`. # The difference between `ff` (awk-style) and `fff` (sed-style) is that # `ff` will test its right side right when its left side changes to `True`, # and can get back to `False` right away # (*except* it'll be `True` for the iteration that matched) - # While `fff` will wait for the next iteration to # try its right side, once its left side changed: . ; # because the right-hand-side was tested # "B"s are printed since it matched that time # (it just went back to `False` right away). . ; # (and thus did not match instantly). # A flip-flop can change state as many times as needed: <test start print it stop not printing start print again stop not anymore> { . ^ ^ ; } # you might also use a Whatever Star, # which is equivalent to `True` for the left side or `False` for the right: ( , , , , , ) { # Note: the parenthesis are superfluous here . > *; # Once the flip-flop reaches a number greater than 50, # it'll never go back to `False` } # You can also use this property to create an `If` # that'll not go through the first time : { . * ^ *; # the flip-flop is `True` and never goes back to `False`, # but the `^` makes it *not run* on the first iteration } # - `===` is value identity and uses `.WHICH` on the objects to compare them # - `=:=` is container identity and uses `VAR()` on the objects to compare them

If you want to go further, you can:

Got a suggestion? A correction, perhaps? Open an Issue on the Github Repo, or make a pull request yourself!

Originally contributed by vendethiel, and updated by 21 contributor(s).|||

