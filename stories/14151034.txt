Now let’s assemble hexagons into a grid. With square grids, there’s one obvious way to do it. With hexagons, there are multiple approaches. I recommend using cube coordinates as the primary representation. Use either axial or offset coordinates for map storage, and displaying coordinates to the user. The most common approach is to offset every other column or row. Columns are named or . Rows are named or . You can either offset the odd or the even column/rows, so the horizontal and vertical hexagons each have two variants. Another way to look at hexagonal grids is to see that there are three primary axes, unlike the two we have for square grids. There’s an elegant symmetry with these. Let’s take a cube grid and slice out a diagonal plane at . This is a weird idea but it helps us make hex grid algorithms simpler. In particular, we can reuse standard operations from cartesian coordinates: adding coordinates, subtracting coordinates, multiplying or dividing by a scalar, and distances. Notice the three primary axes on the cube grid, and how they correspond to six hex grid diagonal directions; the diagonal grid axes corresponds to a primary hex grid direction. Because we already have algorithms for square and cube grids, using cube coordinates allows us to adapt those algorithms to hex grids. I will be using this system for most of the algorithms on the page. To use the algorithms with another coordinate system, I’ll convert to cube coordinates, run the algorithm, and convert back. Study how the cube coordinates work on the hex grid. Selecting the hexes will highlight the cube coordinates corresponding to the three axes. 

 Switch to or back to hexagons. Each direction on the cube grid corresponds to a line on the hex grid. Try highlighting a hex with at 0, 1, 2, 3 to see how these are related. The row is marked in blue. Try the same for (green) and (purple). Each direction on the hex grid is a combination of two directions on the cube grid. For example, on the hex grid lies between the and , so every step involves adding 1 to and subtracting 1 from . The cube coordinates are a reasonable choice for a hex grid coordinate system. The constraint is that so the algorithms must preserve that. The constraint also ensures that there’s a canonical coordinate for each hex. There are many different valid cube hex coordinate systems. Some of them have constraints other than . I’ve shown only one of the many systems. You can also construct cube coordinates with , and that has its own set of interesting properties, which I don’t explore here. “But Amit!” you say, “I don’t want to store 3 numbers for coordinates. I don’t know how to store a map that way.” The axial coordinate system, sometimes called “trapezoidal”, is built by taking two of the three coordinates from a cube coordinate system. Since we have a constraint such as , the third coordinate is redundant. Axial coordinates are useful for map storage and for displaying coordinates to the user. Like cube coordinates, you can use the standard add, subtract, multiply, divide operations from cartesian coordinates. 

 Switch to or back to hexagons. There are many cube coordinate systems, and many axial coordinate systems. I’m not going to show all of the combinations in this guide. I’m going to pick two variables, for “column” and as “row”. In the diagrams on this page, is aligned with and is aligned with but this alignment is arbitary, as you can rotate and flip the diagrams to make many different alignments. The advantage of this system over offset grids is that the algorithms are cleaner. The disadvantage of this system is that storing a rectangular map is a little weird; see the map storage section for ways to handle that. There are some algorithms that are even cleaner with cube coordinates, but for those, since we have the constraint , we can calculate the third implicit coordinate and use that for those algorithms. In my projects, I name the axes , , so that I have the constraint , and then I can calculate when needed. Offset coordinates are the first thing people think of, because they match the standard cartesian coordinates used with square grids. Unfortunately one of the two axes has to go “against the grain”, and ends up complicating things. The cube and axial systems go “with the grain” and have simpler algorithms, but slightly more complicated map storage. There’s also another system, called interlaced or doubled, that I haven’t explored here; some people say it’s easier to work with than cube/axial. The axis is the direction in which that coordinate increases. Perpendicular to the axis is a line where that coordinate stays constant. The grid diagrams above show the perpendicular line.

It is likely that you will use axial or offset coordinates in your project, but many algorithms are simpler to express in cube coordinates. Therefore you need to be able to convert back and forth. Axial coordinates are closely connected to cube coordinates. Axial discards the third coordinate and cube calculates the third coordinate from the other two: Determine which type of offset system you use; *-r are pointy top; *-q are flat top: Implementation note: I use (bitwise and) instead of (modulo) to detect whether something is even (0) or odd (1), because it works with negative numbers too. See a longer explanation on my implementation notes page.

Given a hex, which 6 hexes are neighboring it? As you might expect, the answer is simplest with cube coordinates, still pretty simple with axial coordinates, and slightly trickier with offset coordinates. We might also want to calculate the 6 “diagonal” hexes. Moving one space in hex coordinates involves changing one of the 3 cube coordinates by +1 and changing another one by -1 (the sum must remain 0). There are 3 possible coordinates to change by +1, and 2 remaining that could be changed by -1. This results in 6 possible changes. Each corresponds to one of the hexagonal directions. The simplest and fastest approach is to precompute the permutations and put them into a table of at compile time: As before, we’ll use the cube system as a starting point. Take the table of and convert into a table of : With offset coordinates, the change depends on where in the grid we are. If we’re on an offset column/row then the rule is different than if we’re on a non-offset column/row. As above, we’ll build a table of the numbers we need to add to and . However this time there will be two arrays, one for odd columns/rows and one for even columns/rows. Look at on the grid map above and see how and change as you move in each of the six directions. Then do this again for . The tables and code are different for each of the four offset grid types, so pick a grid type to see the corresponding code. Using the above lookup tables is the easiest way to to calculate neighbors. It’s also possible to derive these numbers, for those of you who are curious. Moving to a “diagonal” space in hex coordinates changes one of the 3 cube coordinates by ±2 and the other two by ∓1 (the sum must remain 0). As before, you can convert these into axial by dropping one of the three coordinates, or convert to offset by precalculating the results.

In the cube coordinate system, each hexagon is a cube in 3d space. Adjacent hexagons are distance 1 apart in the hex grid but distance 2 apart in the cube grid. This makes distances simple. In a square grid, Manhattan distances are . In a cube grid, Manhattan distances are . The distance on a hex grid is half that: An equivalent way to write this is by noting that one of the three coordinates must be the sum of the other two, then picking that one as the distance. You may prefer the “divide by two” form above, or the “max” form here, but they give the same result: In the diagram, the max is highlighted. Also notice that each color indicates one of the 6 “diagonal” directions. In the axial system, the third coordinate is implicit. Let’s convert axial to cube to calculate distance: If your compiler inlines and , it will generate this code: There are lots of different ways to write hex distance in axial coordinates, but no matter which way you write it, axial hex distance is derived from the Mahattan distance on cubes. For example, the “difference of differences” described here results from writing as , and using “max” form instead of the “divide by two” form of . They’re all equivalent once you see the connection to cube coordinates. As with axial coordinates, we’ll convert offset coordinates to cube coordinates, then use cube distance. We’ll use the same pattern for many of the algorithms: convert hex to cube, run the cube version of the algorithm, and convert any cube results back to hex coordinates (whether axial or offset).

Given a location and a distance, what is visible from that location, not blocked by obstacles? The simplest way to do this is to draw a line to every hex that’s in range. If the line doesn’t hit any walls, then you can see the hex. Mouse over a hex to see the line being drawn to that hex, and which walls it hits. This algorithm can be slow for large areas but it’s so easy to implement that it’s what I recommend starting with. There are many different ways to define what’s “visible”. Do you want to be able to see the center of the other hex from the center of the starting hex? Do you want to see any part of the other hex from the center of the starting point? Maybe any part of the other hex from any part of the starting point? Are there obstacles that occupy less than a complete hex? Field of view turns out to be trickier and more varied than it might seem at first. Start with the simplest algorithm, but expect that it may not compute exactly the answer you want for your project. There are even situations where the simple algorithm produces results that are illogical. Clark Verbrugge’s guide describes a “start at center and move outwards” algorithm to calculate field of view. Also see the Duelo project, which has an an online demo of directional field of view and code on Github. Also see my article on 2d visibility calculation for an algorithm that works on polygons, including hexagons. For grids, the roguelike community has a nice set of algorithms for square grids (see this and this and this); some of them might be adapted for hex grids.

For hex to pixel, it’s useful to review the size and spacing diagram at the top of the page. For axial coordinates, the way to think about hex to pixel conversion is to look at the basis vectors. In the diagram, the arrow A→Q is the q basis vector and A→R is the r basis vector. The pixel coordinate is . For example, B at (1, 1) is the sum of the q and r basis vectors. If you have a matrix library, this is a simple matrix multiplication; however I’ll write the code out without matrices here. For the axial grid I use in this guide, the conversion is: The matrix approach will come in handy later when we want to convert pixel coordinates back to hex coordinates. All we will have to do is invert the matrix. For cube coordinates, you can either use cube basis vectors (x, y, z), or you can convert to axial first and then use axial basis vectors (q, r). For offset coordinates, we need to offset either the column or row number (it will no longer be an integer). Unfortunately offset coordinates don’t have basis vectors that we can use with a matrix. This is one reason pixel-to-hex conversions are harder with offset coordinates. Another approach is to convert the offset coordinates into cube/axial coordinates, then use the cube/axial to pixel conversion. By inlining the conversion code then optimizing, it will end up being the same as above.

One of the most common questions is, how do I take a pixel location (such as a mouse click) and convert it into a hex grid coordinate? I’ll show how to do this for axial or cube coordinates. For offset coordinates, the simplest thing to do is to convert the cube to offset at the end. First we invert the hex to pixel conversion. This will give us a fractional hex coordinate, shown as a small blue circle in the diagram. Then we find the hex containing the fractional hex coordinate, shown as the highlighted hex in the diagram. To convert from hex coordinates to pixel coordinates, we multiplied by basis vectors to get . You can think of this as a matrix multiply. Here’s the matrix for “pointy top” hexes: Converting from pixel coordinates back to hex coordinates is straightforward. We can invert the matrix: This calculation will give us fractional axial coordinates (floats) for and . The hex_round() function will convert the fractional axial coordinates into integer axial hex coordinates. And here’s the code for “flat top” axial hexes: That’s three lines of code to convert a pixel location into an axial hex coordinate. If you use offset coordinates, use . There are many other ways to convert pixel to hex; see this page for the ones I know of.

Sometimes we'll end up with a floating-point cube coordinate , and we’ll want to know which hex it should be in. This comes up in line drawing and pixel to hex. Converting a floating point value to an integer value is called rounding so I call this algorithm . With cube coordinates, , even with floating point cube coordinates. So let’s round each component to the nearest integer, . However, although , after rounding we do not have a guarantee that . So we reset the component with the largest change back to what the constraint requires. For example, if the y-change is larger than and , then we reset . This guarantees that . Here’s the algorithm: function cube_round(cube): var rx = round(cube.x) var ry = round(cube.y) var rz = round(cube.z) var x_diff = abs(rx - cube.x) var y_diff = abs(ry - cube.y) var z_diff = abs(rz - cube.z) if x_diff > y_diff and x_diff > z_diff: rx = -ry-rz else if y_diff > z_diff: ry = -rx-rz else: rz = -rx-ry return Cube(rx, ry, rz) For non-cube coordinates, the simplest thing to do is to convert to cube coordinates, use the rounding algorithm, then convert back: Implementation note: and take float coordinates instead of int coordinates. If you’ve written a Cube and Hex class, they’ll work fine in dynamically languages where you can pass in floats instead of ints, and they’ll also work fine in statically typed languages with a unified number type. However, in most statically typed languages, you’ll need a separate class/struct type for float coordinates, and will have type . If you also need , it will be , using helper function instead of . In languages with parameterized types (C++, Haskell, etc.) you might define where is either or . Alternatively, you could write to take three floats as inputs instead of defining a new type just for this function.

One of the common complaints about the axial coordinate system is that it leads to wasted space when using a rectangular map; that's one reason to favor an offset coordinate system. However all the hex coordinate systems lead to wasted space when using a triangular or hexagonal map. We can use the same strategies for storing all of them. Notice in the diagram that the wasted space is on the left and right sides of each row (except for rhombus maps) This gives us three strategies for storing the map: Ignore the problem. Use a dense array with nulls or some other sentinel at the unused spaces. At most there’s a factor of two for these common shapes; it may not be worth using a more complicated solution. Use a hash table instead of dense array. This allows arbitrarily shaped maps, including ones with holes. When you want to access the hex at you access instead. Encapsulate this into the getter/setter in the grid class so that the rest of the game doesn’t need to know about it. Slide the rows to the left, and use variable sized rows. In many languages a 2D array is an array of arrays; there’s no reason the arrays have to be the same length. This removes the waste on the right. In addition, if you start the arrays at the leftmost column instead of at 0, you remove the waste on the left. To do this for arbitrary convex shaped maps, you’d keep an additional array of “first columns”. When you want to access the hex at you access instead. Encapsulate this into the getter/setter in the grid class so that the rest of the game doesn’t need to know about it. In the diagram is shown on the left side of each row. If your maps are fixed shapes, the “first columns” can be calculated on the fly instead of being stored in an array. For rectangle shaped maps, , and you’d end up accessing , which turns out to be equivalent to converting the coordinates into offset grid coordinates. For triangle shaped maps as shown here, , so you’d access — how convenient! For triangle shaped maps that are oriented the other way (not shown in the diagram), it’s . For hexagon shaped maps of radius , where , we have . You’d access . However, since we’re starting with some values of , we also have to offset the row, and use For rhombus shaped maps, everything matches nicely, so you can use .|||

