You should not be surprised why your program does not compile if the error is purely syntactic, nor should you spend any significant time trying to solve it. A good metric for this is whether you’re able to write code without an IDE and it will pass the compilation or interpretation stage without syntax errors. I’m generally an advocate for using an IDE because we, as developers, usually have more work to do than we can get through in a usual day, so any productivity boost should be welcomed, not excluded for any subjective reasons. However if you always use an IDE you may miss out on learning how to correctly write code by yourself. An IDE also may have shortcuts for repetitive and boring code (commonly named “boilerplate”) and you may be tempted to use them simply because they’re available.

I need to make a note here; languages evolve over time. If you check out the latest standard of JavaScript, ECMAScript 6, and the first edition ever published, you will notice there are many, many changes. This begs the question of should you feel that because you’ve mastered the syntax of a language at some point in time, but you haven’t worked with it at all for months or years, does that mean you’re no longer knowledgeable? I’m going to answer no, and here’s why.

Everything changes in software development. The landscape is shifting constantly, new languages are added every year, and the sector is probably one of the most dynamic and competitive in the world. If you have invested time to learn a programming language, and consider yourself productive, no amount of time can cancel that out. Imagine you’ve spent working 5 or 6 years in C++. You can’t even remember the standard that was in place at that time. It doesn’t really matter. You have a huge advantage over everyone starting out with C++ 17 (the latest revision of the standard at the time I’m writing this), because you’ve taken the time to master it at one point, and you will be able to approach the design changes with a lot more confidence than a novice. Myself, I wrote a lot of PHP years ago, starting out with version 4 (for the nostalgic among you, remember writing almost OOP code?), then moved on to 5. Version 6 does not exist, for reasons that would take too much time to explain. Now, PHP is at version 7. Because I haven’t kept up with it, I obviously have no idea what has changed in the language, from a syntactic point of view (I did hear that lambdas were added, which is awesome). One thing is certain, though, I’m confident in my ability to pick up PHP 7 if I had to, because I invested a lot of time to work with it in the past.

This requirement is very important because it enables you to use the right tool for the job. You will have to know and accept the limitations of the language and not try and coerce it into doing something that’s not idiomatic. Think of trying to write a triple A game engine in Pascal, or a CRUD backend in Bash. Think that’s too contrived? How about writing a library that enables static type annotations in Python, a language that is designed to be dynamically typed, and is one of its strongest features. I actually wrote this while working at a startup, and it took me some time to understand why it was a terrible idea.

It helps to know that some languages are so called “general purpose”, which means they can be depended on to solve problems across all of the domains within computing. The prime examples are C and C++. Other languages are more niched, and they wouldn’t make good candidates for solving certain problems, such as Swift or R. There is however a lot of power in specialization.

I cannot stress this enough. You will never truly master a language unless you learn how to use its standard APIs.

Be mindful of the fact that you will not be able to fully understand and work with all of them, though. Some languages such as Objective-C come with a frankly huge set of APIs associated with the iOS operating system (even though you can write Objective-C code anywhere, it is most often associated with iOS and macOS development).

Try not to focus too much on memorizing functions and packages though, this does not scale well at all as you progress through your career. I remember obsessively reading the Java API spec years ago trying to learn as many APIs as I could by heart in case I’ll ever use them. Guess what? I only used a handful on a regular basis.

There are also some languages, such as JavaScript, that come with a fairly limited standard library. Historically this has been the reason why so many third-party libraries stepped in to fill the gaps, leading to an incredibly fragmented and fragile ecosystem. Consider the fact that most JavaScript developers started out by learning jQuery, a library that, at one point, had become so pervasive, you could be forgiven for thinking that it was a programming language in and of itself. This doesn’t mean you get a pass, though. Regardless of how badly written or unintuitive these APIs may be, they are the building blocks with which every library and framework is built, and ignoring them will relegate you to a downstream user of them. Besides that, the limited APIs may be a temporary situation. Java’s Collections API, for example, has received numerous updates in its 8th version, and the Calendar API, once one of the most hated aspects of writing date/time focused code, has also been massively improved (with the help of a third-party lib called Joda Time).

Once you’ve mastered this requirement you will be able to author your own libraries to solve very specific problems that you encounter. Don’t take this into consideration, though, when evaluating your skills. You don’t need to be the author and maintainer of a popular library or framework to be able to say you’re proficient. The reverse is also true.|||

You may have been driven to study it by a tangible need such as moving to a different country, or creating new business connections. Or you may simply have decided it’s a challenge worth taking on…