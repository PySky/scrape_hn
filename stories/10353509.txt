This post is part of my Tech Hiring and Team Building series. You can find the next post here.

“Computer science is no more about computers than astronomy is about telescopes.” ~ Edsger Dijkstra

If you write software for a living (or for fun) ask yourself this: When was the last time you calculated the Big O (for the uninitiated, “Big O” is a measure of the worst case efficiency of an algorithm)on something you wrote? Now remove all the times you did it so that some interviewer could show off the fact that he knew what O(n log n) was to his teammates. In over 20 years of writing software both as a hobby and professionally, I can tell you that for me, that number can be counted on the fingers of 1 hand.

People often conflate computer science and writing software. They are related, but quite different animals. Writing software is not just the application of computer science any more than writing a symphony is just the application of acoustics.

Like acoustics describes the physics of sound, computer science describes the mathematics of algorithms. It describes how and why a bubble sort is far less efficient than a heap sort. This is not to say that software engineers don’t need to understand the fundamentals of computer science, they most certainly do. Imagine a composer who didn’t know what sounds his instruments made. Could they create some music? Maybe. Could they be great? Probably not.

A composer has a fixed set of instruments that are capable of making a fixed range of sounds. They choose which instruments come in, which stay out, which become the focus and which become the background. In doing so they turn noise into something elegant and emotionally evocative.

Writing software, when done properly, also has this same properties. Our instruments are the algorithms. We play them on the disk, the network, and the screen. Their combinations and permutations in the hands of an engineer can be made to focus on raw speed, size or time constraints, or creating something visually delightful. Even if you’re not an engineer, the ultimate result can be equally elegant and emotionally evocative.

Dark sky in the background, check. Stars in sky, check. City under sky, check. Lots of art checks off these boxes. Not a lot of it is Starry Night. Checking off check boxes may make sure your code doesn’t do terrible things, but it will never make your code do great things. For that you need experience and talent. The more talent you have (and assuming you have a degree of humility that lets you learn from others), the faster experience gained will make you better. Talent alone is not enough. Talent is an acorn, it has the potential to become a mighty oak. Experience is fertile soil, water, sunlight and time.

If you haven’t gotten to that conclusion yet, there it is in black(ish) and white. What’s my point here? There are 2 parts to my point. First, is to remind those of us that got into writing software because we had a passion for making great things, but maybe have been just paying the bills that there’s still more art to be created. The second is to lay the groundwork for the next few blog posts I’m going to write in my Tech Hiring and Team Building series. It’s important to realize that there’s a lot of experience and talent that goes into writing software, and like the acorn to the oak, the more you invest the better your returns.

I’m a polyglot developer deeply interested in high performance, scalability, software architecture and generally solving hard problems. You can follow me on Medium where I blog about software engineering, follow me on Twitter where I occasionally say interesting things, or check out my contributions to the FOSS community on GitHub.

If you enjoyed this post, I’d really appreciate a recommend (just click the heart below).|||

If you write software for a living (or for fun) ask yourself this: When was the last time you calculated the Big O (for the uninitiated, “Big O” is a measure of the worst case efficiency of an…