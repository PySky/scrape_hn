Elixir always compiles and always executes source code. Both and do both things.

You read that right, always, compilation and execution. compiles (in addition to execute), executes (in addition to compile).

Both and work the same way:

There is some nesting in this process that explains the loop illustrated in the picture above. This is due to the way module definition is implemented, but we’ll leave it here.

Both and do the same. executes top-level and module-level code like does, it is the same code path.

For example, you can conditionally define a function while compiling. Why? Because the code is being executed. The other way around, is able to invoke functions in modules defined in the same script. Why? Because they are compiled and loaded into the VM on the fly.

Since programs executed by are compiled, they run at the speed of compiled modules. Compilation has a penalty, of course, the wall clock time is different, but the code itself runs equally fast.

The main difference between and is that produces a .beam file per module as a side-effect of module definition. It does so by dumping the binary returned by . That’s about it.

Extensions in file names do not matter, .ex and .exs are only conventions.

You can also compile a file that contains five modules, and you’ll get five different .beam files, each named after the module name (regardless of the name of the file defining the modules).

Top-level code or module-level code that does not end in a persisted module attribute or a function is gone in the .beam files. Those files contain module definitions for the VM expressed in object code, Elixir is gone there, those are BEAM programs that could have technically been generated by some other tool.

PS: Thanks a lot to José Valim for reviewing a draft of this post ❤️.|||

You read that right, always, compilation and execution. elixir compiles (in addition to execute), elixirc executes (in addition to compile). There is some nesting in this process that explains the…