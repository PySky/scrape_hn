Want the TL;DR version? Here’s a gist of all three examples.

Async generators and async iteration have arrived! Err, they’ve reached Stage 3, which means they are likely to ship in a future version of JavaScript. Until then, you can enable Stage 3 proposals in Babel to try them out in your own projects.

The web is essentially a decentralized app runtime, so subpar language additions have permanent consequences since future standards must remain backwards compatible. So for a feature to be accepted into the ECMAScript standard, it has to be incredibly compelling—it takes more than snazzy syntax or theoretical elegance for a feature to make the cut.

With that in mind, we should expect async generators and iteration to substantially influence how we architect our future code, yet address a contemporary problem. Let’s investigate how async generators work and examine the challenges of using them in “real” codebases.

In a nutshell, async generators are like regular generator functions, but they yield Promises. If you aren’t familiar with ES2015 generator functions, check out Chris Aquino’s blog, then watch Jafar Husain’s excellent talk on Async Programming.

To recap, regular generator functions are basically a cross between the Iterator and Observer patterns. A generator is a pausable function that you can “step” through by calling . You can pull a value out of a generator multiple times with , or push a value into the same function multiple times with . This dual interface allows you to imitate both an Iterator and Observer with the same syntax!

However, generators have a disadvantage: they must immediately (synchronously) return data when is invoked. Put another way, the code that consumes the data by calling is in control of data flow. This is fine when the generator can generate new data on demand, but generators are not a good fit for iterating over asynchronous (or temporal) data sources, where the source itself controls when the next chunk of data is available.

WebSocket messages are a good example of an asynchronous data source. If we had a list of all the messages we would ever receive, we could iterate over them synchronously. But of course, we can’t know when messages will be received, so we need a mechanism to iterate lazily over messages as they arrive. Async generators and async iteration let us do just that!

TL;DR: generator functions are for data sources where the data consumer is in control, whereas async generators allow the data source itself to be in control.

Let’s exercise our async chops with an example. We want to write an async generator function that repeatedly generates a new number after waiting a random number of milliseconds. Over a period of several seconds it might generate five or so numbers starting from 0. Let’s first write a helper function that generates a Promise to represent a timer:

Calling returns a Promise that will resolve in 5 seconds. Now we’re ready to write an async generator:

So much complexity hiding behind such elegance! Our async generator function waits a random amount of time, then s the next number in the count-up. If we didn’t have async generators, we could try using a regular generator function to Promises like this:

However, there are some edge cases and boilerplate we’d have to handle, so it’s nice to have a dedicated function type! Now we’re ready to write the consuming code; because we need the operator, we’ll create an async function.

What magic, and in under 20 lines of code! First, we invoke the async generator function, which returns a special object. Then we use the loop syntax—called “asynchronous iteration”—to loop over numbers one-by-one as generates them.

But we can level up: suppose we want to square the numbers generated by . We could square directly inside the loop, but it’d be better to “transform” the stream of values outside the loop, similar to using to transform an array of values. It’s quite straightforward:

Then we just need to add a line to the function:

Now when we everything:

Impressive! But perhaps generating counting numbers isn’t especially innovative.

The usual way to respond to incoming WebSocket messages is to attach an event listener:

But if we treated WebSocket messages as a stream, it seems natural to “iterate” over messages as they arrive. Unfortunately, WebSockets are not yet async iterable, but we can write our own polyfill in just a few lines. Here’s what our function will look like:

Now for that polyfill. You may recall from Chris Aquino’s blog series that, for an object to be iterable with the loop, you must define the property on that object. Similarly, to make an object async iterable with the loop, its property must be defined. Here’s an implementation:

This async iterator waits to receive a message, then s the attribute of the WebSocket’s . The function is a bit of a hack: it returns a Promise that resolves when an event occurs, then immediately unsubscribes:

It seems inefficient, but it really tidies up our async iterator. If you have a chatty WebSocket server running at http://localhost:3000, you can watch messages stream in by invoking :

Now for the ultimate challenge. Functional reactive programming (FRP) is all the rage in UI programming, and in JavaScript, RxJS is the most popular library for this programming style. RxJS models event sources as s—they’re like an event stream or lazy array that can be modified with familiar array idioms like and .

Since FRP complements JavaScript’s non-blocking philosophy, it’s possible an RxJS-like API will make it to a future version of JavaScript. Meantime, we can write our own RxJS clone with async generators in just 80 lines of code! Here’s the challenge:

This type of problem is right in RxJS’s wheelhouse, so we’ll try to replicate its approach. Here’s how we’ll exercise our implementation:

To make this work, we need to write six functions: , , , , and .

is just like the WebSocket async iterator: uses to listen once for an event, then resolves the Promise. By looping with , we can listen for events indefinitely.

only s events that pass the test. is almost identical:

Instead of testing before yielding, simply transforms the event before yielding. shows one of the superpowers of async generators: they can persist state with local variables!

Last, the mighty function resembles : it tracks the timestamp of the last event and only s it if a certain amount of time has passed since the last ed event.

Finally, we need to print out the click event and counter for every event that made it this far. is trivial: it just loops over every event and runs the callback, no s necessary.

And with that, we’ve written our own functional reactive pipeline!

Check out the gist if you want to try out any of these examples.

Async generators are pretty awesome. Whereas generator functions allow us to pull data out of an iterator, async generators let us iterate over data that is “pushed” to us. They’re a great abstraction for asynchronous data structures. However, there are some caveats.

First, implementing support for the on objects is a bit gnarly unless you avoid and . Notably, converting anything with is tricky because you can’t use the operator within the callback:

Similarly, you can’t use within or other functional methods. This is an inherent limitation since there’s no guarantee won’t be used after the generator has already finished.

To sidestep this, we wrote the helper. Apart from potential performance issues, it’s important to note that Promise callbacks always execute after the current callstack has finished. In browsers that run Promise callbacks as microtasks, this shouldn’t cause issues, but some Promise polyfills won’t run the callbacks until the next run of the event loop. Consequently, invoking the method may have no effect since the DOM event may have already bubbled to the browser.

JavaScript now has several asynchronous stream datatypes: , and eventually . While all three fall into the continuum of “pushed” data sources, there are subtle semantic differences in how they handle back pressure and control the underlying resource. If you’re interested in the finer facets of functional reactive semantics, check out the General Theory of Reactivity.

In the arms race for language features, JavaScript is no slacker. Destructuring in ES2015, async functions in ES2016, and now async iteration enable JavaScript to elegantly tackle the complexities of UI and I/O programming without resorting to the usual unpredictability of multi-threading.

And there’s much more to come! So keep an eye on the blog and the TC39 proposals repo for new goodies. Meantime, you can start using async generator functions in your own code by enabling Stage 3 proposals in Babel.

Interested in learning next-generation JavaScript for the web platform? Come to the Front-end Essentials bootcamp at one of our Ranches, or we can come to you with our corporate training!|||

Async generators and async iteration are likely to ship before too long. Let’s investigate how async generators work and examine the challenges of using them.