Note (Nov 2): I’ve been informed that the RobustIRC authors are aware of these things, and that my characterization of RobustIRC is incorrect. RobustIRC is structured in a request-response fashion, and nodes on the losing half of a partition will cancel all current requests and refuse all new ones until they again become part of the majority. This architecture allows clients to fail over gracefully to a usable node. However, I think the article still has value as a perspective on the pros and cons of choosing consistency over availability in IRC implementations, and I’ve left it intact.

I feel like it’s been a while since people have cared about scrutinizing RobustIRC, but I’ve been doing some unrelated research lately and it has occurred to me that RobustIRC not only offers little to no improvement over existing IRC server-to-server protocols, but that it is actually a regression of IRC robustness in general. RobustIRC claims to solve the netsplit problem once and for all. While it’s strictly true that a RobustIRC cluster will never react to any network event with something resembling a netsplit, RobustIRC is not free from netsplit-like events and, in such events, leads to a service level worse than that of existing IRC implementations under the same conditions.

First, I’ll briefly explain how RobustIRC works (as I understand it): the basic idea is to synchronize a single message log across nodes in the cluster using the Raft consensus protocol. All incoming IRC messages are appended to this log and, when committed, acted on. PRIVMSG and NOTICE, the commands that IRC exists to support, receive no special treatment. (Feel free to correct me if I’m wrong, I probably am.)

Consider a network partition event. During a network partition, Raft ensures that only nodes on the larger half can make progress. The nodes on the smaller half will repeatedly try to elect a leader unsuccessfully, and will be unable to make changes to the log. For the entire duration of the partition, users on the smaller half will be paralyzed, unable to communicate or make changes to the network state. When the partition is finally healed, the nodes on the small half receive the new log of events, which includes everything that was committed on the large half. They update their state, relay messages to their clients, and use of the network continues as normal.

On a traditional IRC network, during a network partition, the dreaded “netsplit” will happen. Users on the large half of the split will see QUIT messages for every user on the small half, and vice versa. However, users on both halves of the partition will still be able to make changes and communicate. When the halves of the network are joined again, the IRC implementation merges the diverged network states (sometimes in an admittedly halfhearted and, in some corner cases, buggy way), sending JOIN message for every newly visible user, and chatting continues as normal.

Returning to the RobustIRC case, it’s clear that users on the small half have a worse experience than in the traditional IRC case. To try to bring RobustIRC to feature parity, suppose for the sake of argument that nodes on either half can detect that a partition has occurred. (This is not really a valid assumption to make, and Raft provides no way to detect this, but that’s outside the scope of this post.) To make the network usable again for the users on the smaller half, and to ensure that every client is notified of the course of action, some netsplit-like behavior must be implemented. I’ll leave the reader to think through some scenarios, such as establishing a temporary domain of consensus on the smaller half, or forcing users to reconnect to the larger half.

Ultimately, the netsplit mechanism serves a very important purpose. IRC networks have been designed from the beginning to be split apart and rejoined, (something very important to networks which must exist, stay connected, and be usable for months on end), and netsplit and netjoin events allow every client and server on each half of the network to be on the same page as the network changes shape. A netsplit is used to inform users and servers that some other set of users and servers has become unreachable, an event that is simply a reality of networking. To claim that RobustIRC has eliminated netsplits is to claim that RobustIRC has eliminated unreachability, which is clearly ignoring basic assumptions of distributed systems.

The real problem with current IRC topologies, and the one that RobustIRC almost entirely fails to address, is that since nodes are connected in a tree, every server-server link is a netsplit waiting to happen. A truly robust IRC network solution will allow every node to master shared state (like they currently do), tolerate state divergences that can span arbitrary periods of time (like they currently do), and reduce the number of ways a node may become unreachable (like they currently do not). As it is used in RobustIRC, Raft is not a solution to this, and applying it to IRC in this way demonstrates an oversight at best, and a lack of understanding at worst.

It’s regrettable to me that RobustIRC has gotten the attention it has, but my opinions on this trend are outside the scope of this article. Find me on IRC as ‘aji’ if snark is your thing and you’d like to know more.|||

Note (Nov 2): I’ve been informed that the RobustIRC authors are aware of these things, and that my characterization of RobustIRC is incorrect. RobustIRC is structured in a request-response fashion…