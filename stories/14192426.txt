Traditional web apps give you a lot of flexibility but have high costs. From hosting, to maintenance, to security, maintaining your own server for your application can be expensive, time-consuming, and highly technical work that can require a DevOps organization to manage effectively — adding another expense to the bottom line. In this series of posts, we'll walk through creating a serverless app using Backand.com. This post will cover serverless app architecture, the project we'll be building, and what Backand has to offer.

While serverless architectures have been around in some form for several years, it was the launch of AWS Lambda at re:Invent 2014 that truly kicked off the trend — and the buzzword. Serverless applications are not truly serverless, but rather outsource the provisioning and hosting of an application's functionality to a third-party provider. This manifests as a number of different patterns; from dynamically launching Docker containers with your app in an on-demand fashion, to deploying only single functions that have their outputs combined together by a client-side app that acts more like a service orchestrator than a traditional web application.

The two predominant paradigms in serverless app development are single-provider serverless apps and Function-as-a-Service serverless apps. A single-provider serverless app simply replaces the server in a traditional client-server application with a third-party API. The developer in this application uses administrative tools with the third party to construct their data model, manage their app's business logic, and secure their application. Much of the traditional server-side logic is moved to the front-end code, or emulated via features like server-side code execution.

Function-as-a-Service serverless apps take this a step farther. Instead of working with a single monolithic backend provider, the app is broken into individual functional areas. These functions are then uploaded to a service like AWS Lambda, and called via triggers — the most common being AWS API Gateway (in the AWS Ecosystem, at least). The provider handles the challenges of making this code always-available, scaling the code in response to demand, and securing the execution and operation environment. While this preserves the server-side component in a more understandable and controllable fashion than a sole-provider serverless app, it requires a lot of error handling and service orchestration code to be implemented in the client side, bloating the client app size.

I've included a summary graphic above that tries to highlight the primary differences between the three approaches. It's important to note that this list of web application architectures is not exhaustive — translating other architectures to a serverless pattern can require some extensive work to ensure all functionality is covered, and will vary in complexity based on the underlying graphic. We will primarily focus on sole-provider serverless for the remainder of this series, but it's important to note that the two serverless patterns are not mutually exclusive — you can use a single-provider architecture with a Function-as-a-Service app, for example, or you can mix-and-match patterns by incorporating other third-party providers to supplement functionality in your application.

In this tutorial, we'll build a fairly simple ToDo list application. We'll simply implement an interface that allows a user to log-in, manage their to-do items, then log out. We'll take an iterative approach, starting with the most basic code that we can to accomplish the task for the current article. In fact, some articles, like this one, won't require any coding at all — that's the power of a serverless development platform. We'll be using Backand to provide the server-side functionality, but the same concepts can be applied to any serverless platform.

Backand is a powerful serverless development, deployment, and hosting platform. Backand replaces the server and database in a web application, allowing developers to focus on their front-end code. By leaving the headaches of the server to Backand, development teams are free to focus on application functionality without having to be distracted by dealing with deployment and configuration tasks that may lie outside of their expertise. Backand also allows you to bring a pre-existing SQL database — they use SQL reflection to analyze the DB structure and dynamically build a REST API around it. Backand also provides several tools that address the shortcomings in Function-as-a-Service serverless applications, such as simple deployment and debugging of AWS Lambda functions. Using these tools, developers can focus on their application's look, feel, and behavior — leaving the security, scaling, and configuration aside.

The first step of creating a serverless application is to register with - and create an app for - your chosen service provider. To accomplish this with Backand, it's as easy as 1-2-3:

As this tutorial will stay relatively superficial, we won't need to make any changes to the application we create at first. The default data model for every Backand application consists of two objects: items, and users. We'll use these to implement a basic to-do list and modify the schema as we move forward.

Now that we've reviewed serverless architectures and created a Backand application, we're ready to start coding! The next post in this series will cover designing a UI, and connecting the client-side code to Backand to retrieve a list of items. Posts that follow will then cover CRUD functionality, user authentication, and more. By the completion of this series, you'll have both a healthy understanding of serverless development, and a sample application to add to your portfolio. Tune into our next post for more details or, if you're impatient, hit the docs at https://docs.backand.com to get started on your own.|||

Let's dig into serverless app development by covering the different types of architecture and seeing how Backand can provide server-side functionality.