Parabol creates software to help distributed teams work together seamlessly. Our product syncs your entire team with a quick 30-minute multiplayer meeting, reports what’s been accomplished to the team’s stakeholders, and lets you prioritize your projects across teams and organizations. It’s Agile for enterprise. The entire UI is collaborative and real-time. It feels alive, like a Google doc.

There are good reasons why so few applications are real-time and multiplayer. Distributing state and changes across clients and servers quickly, reliably, and without conflict is wickedly hard. It’s why you don’t see application experiences like Google Docs, Quip, and Trello every day. But, few things worth doing are easy.

To implement our application, we had to be careful in choosing our initial technologies. When choosing a back end, we decided on Node.js as a server, GraphQL as a data transport, and RethinkDB as the database. We like Node because it allows us to use the same language on the front end as on the back end. And we love GraphQL because it is declarative, frees us from a constrained set of REST endpoints, and replaces our ORM with something that is DB agnostic, which means we could afford to take a chance on RethinkDB.

So why RethinkDB? In short, ReQL, changefeeds, and the highest production-grade implementation of a NoSQL database.

ReQL is a query language so good that it is worth building a database around (the only other query language worthy of that praise is GraphQL, and in fact, a graph database has been built around that language: https://dgraph.io/). Suppose you wanted to show a user a history of major document revisions. However, if the document was edited in real-time, you want to avoid creating a new version for each and every character typed. The below query updates an existing document unless a minimum time has elapsed between updates. Magic!

(For the curious, `r.branch` is nothing more than a comma-separated if/then/else clause).

As the old saying goes, there are only two hard things in Computer Science: cache invalidation and naming things. RethinkDB has solved the invalidation problem with their famous changefeeds. By ending a query with  , a static query is transformed into an observable that will send an update whenever queried data is stale.

RethinkDB isn’t the first data store to do this. Back in 2012, Meteor accomplished this with MongoDB through a technique called Oplog Tailing. Unfortunately, it also choked with as few as a couple hundred concurrent users. The group has since moved on to evented subscriptions, which is the same strategy folks like Facebook use. This means that when a client sends a mutation, there is something sitting on the server that hands a mutation to the database, requests the changes, and then passes those changes to a message queue. This is exactly what RethinkDB gives us for free and, most importantly, it just works. Since the process is internalized by the database, it’s always fresh, whether it comes from a client, a server cron job, a 3rd party API, or even an employee manually making an adjustment through RethinkDB’s data explorer (a database debugger’s paradise). If data changes in the DB, it is propagated to the listeners.

Let’s address an elephant in the room: it’s possible RethinkDB may have failed as a commercial entity because the market didn’t see a big enough difference between it and MongoDB. RethinkDB may have overspent on technology and underspent on sharing the story of where it’s superior. For one, RethinkDB is linearizable, which is both fun to say and mathematically proves that you cannot have a stale read. This is critical to anyone who, well, needs to trust their data. RethinkDB allows you to performs joins across shards (scale!), which will one day be critical for scaling our startup. Finally, while the MongoDB community has hopped around data tools like MongoChef, RoboMongo, etc. RethinkDB has provided an elegant dashboard and data explorer that starts up natively within the database. Confronted with the choice between a popular database and a robust one, we’ll take robust every time.

For the most part, we’ve been surprised by how little we’ve needed to learn in order to support our application. But here are a few tips.

This is not a SQL database, so don’t treat it like one. In 2017 we are still reading NoSQL vs. SQL benchmark comparisons where developers throw a workload better suited for SQL (that is to say, structured data) at RethinkDB and see it lag behind in performance (specifically query latency and bytes on-disk). If you’re electing to use RethinkDB because schema flexibility is important to you, great. If you’re electing RethinkDB because ReQL solves some interesting problems for you, wonderful. If you don’t have a reason; stop, think, and make an informed decision. And remember, just because you can be schema-less it doesn’t mean you should be!

Denormalize. Memory and disk space are cheap. CPU cycles aren’t. Expose your changefeeds to run without pseudo-joins. It’ll minimize latency and maximize performance.

Shuttle changefeed data via a message broker. We use socketcluster to move messages between RethinkDB, other servers, and our clients. However, RabbitMQ is also a fine choice. Rather than send raw changefeed updates, we calculate a more compact (and useful) diff. How do we do it? Have a look at our implementation.

Migrations. As your application evolves you’ll inevitably need to forward migrate your data — adding new tables, indexes, and mutating the shape of existing data — both for development and production. We use a set of data migration scripts (managed by a utility called migrate-rethinkdb) to help us.|||

Parabol creates software to help distributed teams work together seamlessly. Our product syncs your entire team with a quick 30-minute multiplayer meeting, reports what’s been accomplished to the…