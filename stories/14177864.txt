Linux offers the capability of raw sockets which allows you to directly create an raw L3/L2 packet bypassing the protocol headers normally generated by OS socket. This means you can generate your own link layer or IP layer packets directly from scratch, a very useful capability for inspecting traffic on your network, or for crafting packets from scratch

Raw sockets can be used on Linux using the syscall by using the socket type (this requires the process to have the capability, or be run as root). Go doesn’t directly support raw sockets through the net package, however, syscalls are available through the syscall package

Not surprisingly, the program fails with an access error

There are two options here: run the program as root, or to grant the capability to the executable using setcap:

The Address Resolution Protocol (ARP) is a request/response protocol used for determining the mapping between IP addresses and link layer (MAC) addresses. Devices use ARP to obtain the MAC address of a device for which they have the IP address, and vice versa

For instance, consider the following exchange: To find the MAC address of , broadcasts an ARP request to all devices. , located at responds back with it’s MAC address:

When receives the response, it stores the IP address and it’s associated MAC address for future reference in the ARP table. You can view the contents of the ARP table by examining the contents of

ARP is generally used in a request/response manner, with one device requesting for information about a particular IP/MAC. However, there is a class of ARP requests/responses for which a response is not expected: the gratuitous ARP request. Gratuitous ARP requests have many uses, of which particularly interesting is the usecase to announce changes in hardware config: in this case, a device sends a broadcast request packet (or response packet) specifying it’s new IP and MAC address - any devices receiving these requests are expected to update thier ARP table with the updated MAC address. This opens up an interesting avenue of attack known as ARP Spoofing: a locally connected device can easily spoof such a request for another machine with it’s own MAC address, and thus receive all traffic meant for that machine.

Linux by default ignores all gratuitous requests for devices not present in the ARP table, however, it accepts requests for IPs already present in the table, potentially allowing us to redirect traffic meant for a particular IP to any device of out choice

Let’s write a program in Go to utilize raw sockets to send an ARP update to a device connected over Ethernet

Let’s consider a setup of 3 devices connected in a local LAN: Machine A, located at 10.10.10.1 (the attacker), 10.10.10.2 (the victim) and 10.10.10.3, the original machine to which data is meant to be sent

Initially, Machine B can access both A and C, as seen from the ARP table:

In a raw socket, the packet which we provide will be directly passed as is to the device driver. Hence, we need to wrap our ARP packet in the lower layer protocol frame (here Ethernet) as well

RFC 826 gives us the structure of the packet:

This can easily be represented in a struct in CGo :

We can fill in all fields of the packet (note that this must be done from CGo, as recommended by the Go wiki ):

Allocate and prepare the packet, and use the Sendto syscall to send it to Machine B

After sending the packet, let’s look at Machine B’s ARP table:

Success! We can see that we have successfully bamboozled Machine B to believe that Machine A has changed it’s location - we can see that Machine A (10.10.10.1) is actually receiving packets meant for Machine C (10.10.10.3):

In this case, we don’t handle the packets received at Machine A originally meant for Machine C, hence it keeps on responding with a ICMP redirect till Machine B finally resends an ARP request for Machine C. However, it would be quite trivial to respond to the packets, or even perform some kind of man-in-the-middle attack

The entire program is shared here|||

Linux offers the capability of raw sockets which allows you to directly create an raw L3/L2 packet bypassing the protocol headers normally generated by OS so...