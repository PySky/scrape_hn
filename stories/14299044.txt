The hashes are later used by the web server to build the CDN URLs for any particular static content file.

Application web server

 The build pipeline produces two different versions for each file: raw and Brotli compressed. We implemented a special content negotiation mechanism in the application web server to decide which one to serve.

The initial request to www.linkedin.com is handled by the application web server. It sends back a base HTML document that contains URLs to all JavaScript and CSS needed to bootstrap the app on the browser. Those URLs are generated on the server side based on the value of the Accept-Encoding header sent by the client. If the value, br, is included in the header, we choose the .br variant of static content from the JSON mapping generated by the build pipeline, lookup hash keys, and generate CDN URLs using the hash keys. Otherwise, we fall back to the raw files, which will be compressed with gzip on the fly in the static content server. For example, the static content URLs we generate for Safari are different from those for Chrome/Firefox because Safari does not support Brotli.

Working around CDN limitations

 We encountered some problems when making CDNs work with Brotli. Here’s how we solved them.

1. CDNs normalize the incoming Accept-Encoding header. Normally CDNs want to limit the number of cache entries by normalizing the header to gzip/non-gzip cases. Brotli is so new, CDNs haven’t caught up yet. Our static content server never gets Accept-Encoding: br header from CDN-forwarded requests.

We solved this by using separate URLs for Brotli objects, instead of the same URL as raw objects accompanied by Vary: Accept-Encoding. Even if br is absent from Accept-Encoding, we serve it anyway. This effectively makes the CDN think of the object as binary. We trust the application web server to make the right decision: if a Brotli object is chosen over the raw object, we can guarantee that the client can decompress it. Generally speaking, using a separate URL for a Brotli object is a cleaner and safer option than using the same URL with Vary: Accept-Encoding header. CDNs have different opinions on Vary regarding caching, but they always treat different URLs as different cache entries.

2. CDNs handle Brotli object caching differently. We encountered a problem where Brotli objects could not be cached by some of our CDN providers. The culprit was that the static content server sent back Content-Encoding: br in the response, and the CDN couldn’t handle it.

To solve this problem, we set up uniform behavior for Brotli objects across all our CDNs. In order to identify the Brotli response from the origin, other than looking at Content-Encoding, we added a path segment /sc/h/br for serving Brotli objects (see figure below). We set up some rules on CDNs by matching the path /sc/h/br to Brotli objects. If the path matches, we strip Content-Encoding: br on the way in, cache the Brotli object, and later add the header back to the response to the client.|||

