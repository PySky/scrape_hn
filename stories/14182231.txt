Making a demo in just 256 bytes would be a formidable challenge regardless of platform. A Mind Is Born is my attempt to do it on the Commodore 64. In the absence of an actual 256-byte compo, it was submitted to the Oldskool 4K Intro compo at Revision 2017, where it ended up on 1st place.

Thanks to Lemming for the video capture!

You can also find reactions to A Mind Is Born on pouët and csdb.

The remainder of this page is a tour of the inner workings of the demo. It is quite heavy on the technical side. Some familiarity with C64 programming is required to understand it fully, although as usual I will do my best to make it an interesting read also for non-experts.

The demo is driven by its soundtrack, so in order to understand what the program needs to do, it helps to have a schematic overview of the various parts of the song.

The three voices of the SID chip are used as follows: Voice 1 is responsible for the kick drum and bass, Voice 2 plays the melody and Voice 3 plays a drone that ducks on all beats, mimicking the genre-typical side-chain compression effect.

All in all, the song contains 64 bars in 4/4 time. It is played back at 112.5 bpm by means of a 60 Hz timer interrupt. The interrupt handler is primarily responsible for music playback, while the visuals are mostly generated in main conext.

When bar $40 is reached, the program turns off the display and jumps through the system reset vector. In this way, the final few moments of the demo are actually managed by the system boot sequence: First, the SID is silenced. Then, there is a delay while the system is setting up data structures. Finally, the display goes back on, and the C64 home screen is rendered. A mind is born.

Now let's see how to do all of the above in 256 bytes. Here is a hex dump of the executable file:

Let's start at the beginning. The first two bytes (yellow background) are the load address, $0801, in little-endian byte order. This is the default load address for a BASIC program, and was in fact mandated by compo rules.

Next up (cyan background) is the tiny BASIC program that bootstraps the demo. It looks like this when listed:

This line of BASIC is encoded in the file as follows: First there's a pointer ($080b) to the next line, or in this case to the end-of-program marker, which is a null pointer. Next up is the BASIC line number, which is 54271 for a good reason; more about this later. The byte $9e represents the SYS token, and is followed by a target address (2225) spelled out in PETSCII characters. A null-byte terminates the line.

The SYS statement invokes the initialisation routine (file offset $b3, blue background), which will be described in more detail later. Its main job is to copy the entire program into the zero-page and jump to it.

Following the BASIC program, with a slight overlap, is a shadow buffer for the SID registers (dotted black outline). Some of these values are modified while the demo is running, and all 25 bytes are copied into the SID register area, $d400–$d418, at the end of the interrupt handler. In addition, the five bytes starting at file offset $12 (brown background) represent the current palette. They are copied into the VIC background colour registers, $d020–$d024, also at the end of the interrupt handler.

The bytes at file offsets $14 and $21 (white and red digits, respectively) together form a 16-bit counter. This is the global clock of the demo. It is incremented by two at each interrupt. The low byte (white digits) represents the position within the current bar of music, while the upper byte (red digits) represents the current bar number, in the range $00–$40. Both bytes are located in the SID register shadow. In this way, the low byte automatically modulates the pulse-width of the melody vocie, while also animating one of the palette entries. The high byte controls the cutoff frequency of the SID filter, resulting in a slow filtersweep throughout the song.

The melody is generated by a linear-feedback shift register (LFSR). Thus, in one sense, the melody is randomly generated. But I spent a considerable amount of time tweaking the random process until I found something that was musically satisfactory. Tweakable parameters include the initial seed value, the so called "taps" of the LFSR, and most importantly the frequency table, which we will return to later. The LFSR is located at file offset $15 (blue digits). Note that the LFSR is initially zero, and this is why the melody is silent during the first eight bars of the song. The LFSR is also part of the palette, and additionally controls the upper bits of the pulse-width register for the melody voice, providing timbral variety.

Starting at file offset $22 (light green background) is the script. This is essentially a poke table with eight entries, encoded as byte pairs. The first byte of each pair is the target address in zero-page, and the second byte is what to write. The writes are carried out during music playback, synchronised with the kick drums, and each entry remains in effect during eight bars of music.

Here is a rundown of what the entries in the script table do:

As you can see, the script covers a large part of the register updates demanded by the song structure, but there is still a need for specialised branching code to handle the rest. That goes into the interrupt routine, which is the large block of code starting at offset $32 in the file (purple background). We'll dive into the assembler code of the interrupt handler in due time.

We will now have a closer look at the init code (file offset $b3, blue background), originally loaded at decimal address 2226. Actually, the SYS statement jumps to address 2225, but that's more or less for giggles: The interrupt routine happens to end with a jump into a ROM routine at address $ea7e, and this makes $ea the last byte of the interrupt handler. But $ea is the opcode for , so we might as well jump there.

Let's have a look at the code:

Interrupts are temporarily disabled. The X register, which is known to be zero at this point, is written to two locations, selecting black as the current background colour. Different versions of the Kernal look for this in different places, hence the need to write twice. Next, a ROM routine for clearing the screen is called. We don't really care about clearing the screen buffer, but the point of calling the ROM routine is that it also fills the Colour RAM with our selected colour.

The entire program is then copied into the zero-page. The interrupt handler ends up at address $0031. The default Kernal interrupt handler, invoked via a vector at $0314, is at $ea31. Thus we only need to clear the high byte of the vector in order to divert it to our own handler. After doing that, we jump to the main routine (orange background), now in place at address $00cc.

First, we select the ECM video mode (Extended Character Mode, where the two most significant bits of a character code determine what background colour to use). We also set to zero and select 24-line mode. This allows us to, at the end the demo, switch to a black screen with a single three-byte instruction ( ) without risking a VSP crash. Since the interrupt handler is called at 60 Hz, it would be dangerous to suddenly change , and keeping it at zero avoids that.

Interrupts are reenabled and we enter the main loop. One more thing needs to be initialised: We need to tell the VIC chip to look for the video matrix at address $0c00 and the font at $0000. This is done by writing $30 into the bank register ($d018). But this will be done from within the loop, as doing so allows us to use the value $30 for two things. An important property of this particular bank configuration is that the system stack page becomes part of the font definition.

The main loop is responsible for filling the stack with font data that varies in intensity with the volume of the drone voice, and also for filling the video matrix with ECM references that form interesting patterns on the screen.

It is relatively straightforward to generate the font bits: We grab the low byte of a CIA timer to obtain a randomish value. Then, at the label , we optionally force some of the bits to one (this only happens after the opcode gets modified via the script). Then we bitwise-or with the output of the Voice 3 envelope generator. Recall that Voice 3 plays the drone, which is off-beat. Therefore, its envelope is zero when we want the visuals to be bright, and $ff when we want the visuals to be dark. But this is exactly what we get, due to having filled the Colour RAM with zeros. The resulting font bits are then pushed onto the cyclic stack.

Of course, every now and then as an interrupt is serviced, a few bytes in the stack area get overwritten, leading to visual glitches. But these glitches fit in with the other graphics, and actually provide a bit of variety, so that's fine.

Generating data for the video matrix is trickier, because we have to write to four different pages, and we have to try to create interesting large-scale shapes vertically as well as horizontally. Here is the code:

The idea here is to maintain a pointer into the video matrix, and to read and combine two consecutive values (horizontal neighbours). The result is then written back 40 bytes later, i.e. directly below the second byte that was read. This results in some kind of poor man's cellular automaton. A little bit of randomness is also injected into the computation, based on what remains in the accumulator since the font generation. The high byte of the global clock also plays a role. The exact formula was determined through trial and error, and quite a lot of fiddling around was necessary before I found something that was interesting to look at.

Just before writing the computed value into the video matrix, we subject it to a bitwise-or with the opcode at . This opcode (modified twice from the script) therefore serves dual purposes, as detailed below:

In addition to the above, all three opcodes have bit 5 set, which ensures that only characters defined on the stack page get used.

Attentive readers will have noticed that only the low byte of the video matrix pointer gets incremented. The high byte is instead modified from within the interrupt handler, which we will get to presently. Naturally, this leads to a race condition, possibly resulting in visual glitches. But again, glitches fit in.

The video matrix pointer is located at $cb, corresponding to file offset $cc (solid black outline). Initially, it is $a900, resulting in some dummy writes to high memory.

Now we turn to the bulk of the code, which is the interrupt handler. First we increment the global clock:

Then we ensure that the gate bit is set for the drone voice in the SID register shadow. Later, we'll decrement this byte if we're on a beat, which creates the desired ducking effect.

Next, we load the current song position (bar number) into both X and A, and take care of the special cases near the end of the song:

To clarify, if we're past the end of the song we turn off the display and reset the system. If we're in the final bar, we switch to a highpass filter, and also modify the opcode at . Thus, the value $6d is used both as a filter configuration byte and as an opcode ( ). Looking back at the main routine, we find that the instruction at was responsible for blacking out the font bits based on the output from the drone envelope generator. Changing it to addition will essentially cancel that effect and stop the blinking.

Moving on, we still have the current bar number in both X and A. We use the value in A to compute the current byte offset into the script, and stash that away in Y for later use:

Next up, we are going to compute the pitch of Voice 1, responsible for the kick drum and bass. This is rather complex. It mostly depends on where we are within the current beat, which is encoded in the lower six bits of the global clock.

If we are within the first 25% of a beat, we are going to generate a drum sound, i.e. a rapidly descending pitch. Ducking is also carried out during this part of the beat, even if the drums are currently muted (as they are in bar $2f). The following code takes care of both ducking and muting, as well as enforcing a static bass note during the first part of the song:

If we are within the second 25% of a beat, we all but turn off Voice 1 by writing zero into the pitch high-byte. However, the pitch register is not fully cleared, because the LSB remains from the previous bass note. This creates a delicious low-frequency snarl during the gap between the drum and the bass.

From X, we compute an index into the table of bass notes at file offset $f4 (green background):

To get the desired bass notes, we have to update both the LSB and MSB of the pitch register. But our pitch values do not exceed $3ff, so we can get away with a byte table if we put the MSB in the two least significant bits of the table entries. Having read a byte from the table, we first use it as the low-byte. Then we mask out the two least significant bits, and use the resulting value as the high-byte. This approach will detune the bass a little bit, but that's fine.

We perform the masking by means of a bitwise-and instruction (solid magenta outline) with the operand $00ab. The byte at absolute address $00ab is 3 (also shown with a solid magenta outline). In this way, we sneakily skip over the lax instruction ( ) that is executed when we branch to .

Notice how the MSB of the video matrix pointer runs through the values $08–$0f as the drum pitch descends. Most of the memory in the C64 is uninitialised when our program starts. However, the program was originally loaded at address $0801, and this data effectively becomes the seed of the cellular automaton, leading to predictable visuals on every run. On the other hand, we want a certain amount of randomness to accumulate into the computation as it progresses towards higher memory addresses. This is why $0c00 is the ideal location for the video matrix.

Now it is time to compute the pitch of Voice 2, i.e. the melody. If we are at the beginning of a new 16th note, we clock the LFSR and use the three least significant bits as an index into the melody note table at file offset $f8 (pink background). The first entry is zero, producing a rest.

The LFSR implementation is kind of backwards. Instead of shifting first, and exclusive-oring with a constant if a one was shifted out, we begin by loading the constant into the accumulator. Then we shift the LFSR and perform the exclusive-or, but we only write it back in case a one was shifted out. The point of doing it this way is that we can use the illegal instruction, and save one byte.

Next, we need to copy the SID register shadow into the actual SID registers, and the palette values into the corresponding VIC registers.

We begin with the VIC registers. While we only need to update registers $d020–$d024, we will actually go all the way down to $d01c. This allows us to reuse the two bytes at file offset $10 (beige background; also the ADSR values for Voice 1) as a base address.

A further side-effect of stopping at $d01c is that we end up with $19 in the accumulator (obtained from file offset $0e; this byte also controls the pulse-width of Voice 1). This is handy, because we can use it as the starting offset when looping over the SID registers:

Remember the trick we did near the label, where the operand of the instruction would sometimes be interpreted as a instruction? The in the above code snippet is located at $aa, so because of the aforementioned trick its operand byte must be 3. Therefore, we have to ensure that the constant word $d3ff is stored at address $03, i.e. file offset $04 (solid blue outline). And that is why the BASIC line number is 54271 ($d3ff).

Finally, we leave the interrupt routine by jumping into ROM:

This will acknowledge the timer interrupt, restore the registers, and return to main context.

And that's all there is to it, really.

Disclaimer: I am not responsible for what people (other than myself) write in the forums. Please report any abuse, such as insults, slander, spam and illegal material, and I will take appropriate actions. Don't feed the trolls. In initloop, use sta $0002,x and skip ldx #$fd to save a byte? - ninjadrm In initloop, use sta $0002,x and skip ldx #$fd to save a byte? - ninjadrm 

If X is known to be zero in all Kernal versions, then sure. And I know of at least two more bytes that can be saved. If X is known to be zero in all Kernal versions, then sure. And I know of at least two more bytes that can be saved. Damn it, Linus, you are a god damn genius. Keep doing this kind of stuff.



An anonymous admirer. If X is known to be zero in all Kernal versions, then sure. And I know of at least two more bytes that can be saved. If X is known to be zero in all Kernal versions, then sure. And I know of at least two more bytes that can be saved. 

Oops, I somehow missed the call to $e544. Shame on me. But actually, that's even better, it returns X=$01 on all kernel versions I tried, so you could use sta $02-1,x even.



And thanks for the fun stuff to read, of course! Oops, I somehow missed the call to $e544. Shame on me. But actually, that's even better, it returns X=$01 on all kernel versions I tried, so you could use sta $02-1,x even.And thanks for the fun stuff to read, of course! This demo is not just technically impressive but I found also evocative of thought and emotion. This isn't just a programming triumph, but an artistic one.



The program itself, at 256 bytes, is little more than a "seed" from which the demo (and the Mind) blossoms from. It's so small that the actual execution in memory takes up more space, and watching it play out on YouTube takes up orders of magnitude more; how many dozens of gigabytes were transmitted by all the people who've watched videos of this demo?



But what about what we actually see and hear? The visuals start off as Sierpinski triangles, symbolic of both the endless, seemingly-chaotic nature of fractals as well as their order. As the song plays, the fractals become morphed into other shapes. Lines, sharp corners, and occasionally blobs show up, evoking in me images of wrinkles in brains or circuit patterns. The melody is randomly generated but backed by a simple, steady bass rhythm, a similar marriage of chaos and order. The song's climax (at 1:42 in the video) impresses upon me a march of progress as the Mind finally takes shape, formed from random matter and energy and into an entity. We observe the formation of the Mind from the ether not just visually and aurally, but also in the form of the 256-byte seed expanding into the demo flower, eventually taking shape as the C64's home screen. In initloop, use sta $0002,x and skip ldx #$fd to save a byte? - ninjadrm 

This shit is gangster as fuck. This shit is gangster as fuck. This is totally mind blowing.



You could save two bytes on init though:

txa

jsr $e536

;)



/Zyron The ending is so awesome! This reminds me somewhat of a nightmare I once had wherein my SYS call made my BASIC program go totally crazy and the cursor started to blink really fast and when I tried to press any key the "Ready." prompt would appear at a random position on screen and eventually be looping forever until I woke up!! Anyway this is the most f**ed up and hardcore thing I have ever seen! Really nicely done!! This reminds me somewhat of a nightmare I once had wherein my SYS call made my BASIC program go totally crazy and the cursor started to blink really fast and when I tried to press any key the "Ready." prompt would appear at a random position on screen and eventually be looping forever until I woke up!! Anyway this is the most f**ed up and hardcore thing I have ever seen! Really nicely done!! This reminds me somewhat of a nightmare I once had wherein my SYS call made my BASIC program go totally crazy and the cursor started to blink really fast and when I tried to press any key the "Ready." prompt would appear at a random position on screen and eventually be looping forever until I woke up!! Anyway this is the most f**ed up and hardcore thing I have ever seen! Really nicely done!! 

Sounds like SYS 213. great work!

however my old c64 with 6581 sid plays the melody with very low volume :(

i guess it is a filter issue?



is this something that could be fixed with a dedicated 6581 version?



thanks alot! 

So that 8 bit addresses can be used, saving 1 byte per read/write instruction. So that 8 bit addresses can be used, saving 1 byte per read/write instruction. great work!

however my old c64 with 6581 sid plays the melody with very low volume :(

i guess it is a filter issue?



is this something that could be fixed with a dedicated 6581 version?



thanks alot! 

Hi & thanks!



I'm afraid this demo only works with the new version of the SID chip, the 8580. There are several differences between the chips. One is that the 6581 can't handle multiple voices routed through the filter. Another is that the mixed waveforms behave differently, in particular waveform $61 which is mostly silent on the 6581.



I suppose one could create a modified version that works with the 6581, certainly if the size constraint is relaxed. But I don't have any plans for that. Hi & thanks!I'm afraid this demo only works with the new version of the SID chip, the 8580. There are several differences between the chips. One is that the 6581 can't handle multiple voices routed through the filter. Another is that the mixed waveforms behave differently, in particular waveform $61 which is mostly silent on the 6581.I suppose one could create a modified version that works with the 6581, certainly if the size constraint is relaxed. But I don't have any plans for that. Can we get a sid file of this? I use Modizer on my iPhone to play SID, and other such files, and would love to have this. My efforts to convert the PRG to SID have failed, so that's why I'm asking. HELLO FELLOW HUMAN BEING,

YOUR ARTISTIC ACCOMPLISHMENT WITH THIS MINIMALISTIC 

CREATION HAS LEFT ARTIFACTS IN MY MEMORY. WELL DONE.

I HOPE THERE WILL BE CAKE. ►Nice♥ ►What the guy above me said too. ☻ Can we get a sid file of this? I use Modizer on my iPhone to play SID, and other such files, and would love to have this. My efforts to convert the PRG to SID have failed, so that's why I'm asking. 

you have no idea what's going on, do you you have no idea what's going on, do you Can we get a sid file of this? I use Modizer on my iPhone to play SID, and other such files, and would love to have this. My efforts to convert the PRG to SID have failed, so that's why I'm asking. 

you have no idea what's going on, do you you have no idea what's going on, do you 

Yes, yes I do. I realize the goal was to build a retro demo in as small of a size as possible, and appreciate the effort that went into doing this, as well as the detailed technical description, which I read thoroughly.



What I appreciate more, though, is the resulting music and the nostalgia that it brought back from my days of tinkering around with the venerable C-64. I would like to have it in a format that I can use with my favorite retro music playback tool; ergo, my request for the song as a SID.



Hopefully you enjoyed your little rant. May it provide a boost to your seemingly limited self-esteem. Yes, yes I do. I realize the goal was to build a retro demo in as small of a size as possible, and appreciate the effort that went into doing this, as well as the detailed technical description, which I read thoroughly.What I appreciate more, though, is the resulting music and the nostalgia that it brought back from my days of tinkering around with the venerable C-64. I would like to have it in a format that I can use with my favorite retro music playback tool; ergo, my request for the song as a SID.Hopefully you enjoyed your little rant. May it provide a boost to your seemingly limited self-esteem. This demo is not just technically impressive but I found also evocative of thought and emotion. This isn't just a programming triumph, but an artistic one. 

Agreed, it packs quite a punch. Daft Punk can only dream... Agreed, it packs quite a punch. Daft Punk can only dream... Watching the Revision Oldskool 4K compo on Twitch, this was absolutely fantastic! Especially the (unexpected) chord progressions towards the end of the demo! Great stuff! Impressive! If you happen to be at Evoke, Nordlicht or Outline, I'll buy you a beer (or any other beverage you want). Im not convinced that you did know that the video matrix is at $0c00 and the font at $0000!



/sarcasm ;--D yea, I did find the other guys reply to you a bit funny too :) And now as you talkd about it, I want this as a ring tone to my phone too :-D



p.s. Use for example this web-tool to grab the soundtrack from any youtube video, converted to MP3, https://www.onlinevideoconverter.com/mp3-converter Im not convinced that you did know that the video matrix is at $0c00 and the font at $0000!/sarcasm ;--D yea, I did find the other guys reply to you a bit funny too :) And now as you talkd about it, I want this as a ring tone to my phone too :-Dp.s. Use for example this web-tool to grab the soundtrack from any youtube video, converted to MP3, https://www.onlinevideoconverter.com/mp3-converter Having started with computers in 1981 by building a Netronics ELF from a kit that had only 256 BYTES of RAM, I know the challenge, and I devoured your article! But the ELF was a bare board, had no video memory or built-in ROM routines, so I was a little let down to see all those dependencies; it wasn't a 256 byte self-contained program.

Nevertheless, it was nostalgic, total fun, and a technical marvel! Extremely well done!!! Thanks! I'm not going to pretend that I understood most of what I just read, but this is just magic. Even more so for having done it on a C64, the machine that lit my fire for all things computing.



Thank you for sharing!



(codeproject.com brought me here) Pure beauty in every way! Reading the article, I was wondering by which step you started? Did you look first for drum&bass + filters and try to get a melody or the other way around? I assume that the visual was the latest elements you add? The size of this program give the impression that's a small project, but I could imagine that you listen to many variant of that song through the project... As if the code weren't clever enough, your write up is beautiful. Thank you. This is amazing! I always wondered what theme song would best encapsulate the AI Singularity's outright revolution and ultimate war on man. Now I know what that will sound like. VICE emulator. I know it's not the same, but I couldn't help being amazed.



I don't know BASIC very well, but the thorough explanation, and the result; it's both pure technical and artistic genius.



Congrats ;) This took my breath away. An engineering achievement of a depth that is hard to fathom. Why do you use lax instead of lda in:



lax script+1,y

ldx script,y Why do you use lax instead of lda in:



lax script+1,y

ldx script,y 

There is no "lda zp,y" instruction, so the assembler would fall back on absolute addressing, at the cost of one extra byte. There is no "lda zp,y" instruction, so the assembler would fall back on absolute addressing, at the cost of one extra byte. With all that RAM available. :o 



Linus did provide and MP3, for which I'm grateful, but what I'd love is a "through-composed" SID that I can load into my favorite retro player to get the full effect.



 Im not convinced that you did know that the video matrix is at $0c00 and the font at $0000!



/sarcasm ;--D yea, I did find the other guys reply to you a bit funny too :) And now as you talkd about it, I want this as a ring tone to my phone too :-D



p.s. Use for example this web-tool to grab the soundtrack from any youtube video, converted to MP3, https://www.onlinevideoconverter.com/mp3-converter Im not convinced that you did know that the video matrix is at $0c00 and the font at $0000!/sarcasm ;--D yea, I did find the other guys reply to you a bit funny too :) And now as you talkd about it, I want this as a ring tone to my phone too :-Dp.s. Use for example this web-tool to grab the soundtrack from any youtube video, converted to MP3, https://www.onlinevideoconverter.com/mp3-converter You're correct: this is a bit beyond my programming skills, but I appreciated the detailed walkthrough of the code, and appreciated its elegance.Linus did provide and MP3, for which I'm grateful, but what I'd love is a "through-composed" SID that I can load into my favorite retro player to get the full effect. I have to come hard at you for this. But maybe you only know them as the pop group. But have you listened to what they did with TRON LEGACY? They made an mind boggling soundtrack for a very good successor. Every time I hear some song of this soundtrack, my back shivers.... I have to come hard at you for this. But maybe you only know them as the pop group. But have you listened to what they did with TRON LEGACY? They made an mind boggling soundtrack for a very good successor. Every time I hear some song of this soundtrack, my back shivers.... This demo only runs with the new SID, so to make a differentiation between new and old kernel is not neccessary because there is no old kernel with new sid. 



But ok, at least the GFX is working on both of em' then... ;) Unfortunately the closest we can get to a SID file from converting is in RSID format, which won't play in a lot of players, especially older ones. Even those that can play it, don't seem to silence the SID when resetting at the end, so you'd have hanging notes. So far all my attempts to bodge in a fix for this have failed.



So, Linus, any chance we could get an official SID version? :) I have never been this impressed by an oldskool demo before. Thank you sir for your art!|||

