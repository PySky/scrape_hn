Today most of the JavaScript code goes through Babel meaning that we no longer write “plain” JavaScript but a superset of it, including future JavaScript syntax and JSX. Not only Babel allows us to use new fancy syntax, but it also removes runtime overhead of code interpretation, in case of JSX by compiling it away into plain JavaScript.

If we start treating Babel as not only transpiler but a kind of an optimizing compiler this can open interesting possibilities. At the very essence source-to-source compilation allows us to use better abstractions without mental and sometimes runtime overhead. Compiling an abstraction into lower-level representation also makes it possible to apply various optimizations ahead of time. In JavaScript community this idea has been recently popping out in a form of Babel plugins for various libraries that provide a useful abstractions, for example styled-components.

As ClojureScript user I’ve been taking advantage of this for some time already, thanks to Lisp’s macro system it is very convenient.

For better or worse Babel does not allow to invent custom syntax without hooking into Babylon (Babel’s parser). But it is still possible to take advantage of it. As an experiment I’ve built a plugin that enables a long wanted feature in React — stateful functional components. It rewrites usual functional components with implicit parameters for state and setState into ES2015 classes. If you brave enough to introduce a completely new syntax (how about pattern matching or literal syntax for Immutable.js data structures?) you can try Sweet.js macros (I’ve heard at some point it will be used in Babel).

However such code transformations has downsides. In Lisp community it’s always being said: “don’t use a macro if a function will work”. The reason is because macros doesn’t compose the way functions does. The code you type in editor doesn’t necessary mean to be the same after transformation, so it’s hard to predict what it will look like unless you are confident about every transformation.

Also it would be wise to think first about how much do you really get by using particular transformation. Often times a runtime abstraction can reduce amount of the code without performance degradation. But sometimes when performance really matters it is better to compile ahead of time, even though the amount of output code will be equal to what can be written by hand.

It’s great to see that code transformation is finding its way into JavaScript not only as a transpilation process but also as a tool for ahead of time optimization and increasing language expressivity.|||

Today most of the JavaScript code goes through Babel meaning that we no longer write “plain” JavaScript but a superset of it, including future JavaScript syntax and JSX. Not only Babel allows us to…