I don’t know how popular these opinions are, but I know that I’ve been doing this long enough to have learned the following. Most of my complaints are really unpopular for managers to hear, but some will be unpopular for developers to hear too.

There is both too much (fake?) elitism, yet not enough practical (real-world) skill with programmers

Basically, people focus so much on algorithmic complexity and don’t put any focus on how to actually abstract and make use of various patterns of development. Either people come straight out of their college education with nothing but preconceived notions about what is important, they are usually wrong in a disastrous manner.

This one is probably for management to hear.

There are plenty of houses that think that they can take a developer and make that developer test for one sprint, or for a release. Although they can do it, usually they are not rigorous, because they don’t care. Developers focus on development, and testers focus on testing, and pushing someone to focus on something that they aren’t intrinsically used to. It makes for really incomplete tests.

I don’t understand why this is so difficult for most developers that sing the praises of dynamically-typed languages. The point is that you can make the compiler prove to you that something would work, but at compile-time, instead of finding out that it doesn’t at run-time. Typing cannot prevent memory exceptions, stack overflow exceptions, or weird errors caused by faulty hardware, but it can prove that your assumptions are valid. Make use of it. It’s your friend, even though it’s annoying. You don’t stop hanging out with your friends just because they do annoying stuff sometimes.

There are no good programming languages

Guess what, we have discovered that languages can be designed with even more rigorous typing than before (dependent-typing). We can create languages that can prove their own consistency. We have languages that can be run in real-time for automation purposes. We have languages with immense frameworks that have anything that you’d ever need for development. We have languages that promote rapid development. We have languages that can (almost) run on any platform. We have languages that are close to the metal. What we don’t have, and possibly can’t have, is a language that does all of that. Every language has an optimal area of usage. Get over yourself, your language is not the best, but neither is mine.

Premature optimization is the devil, but premature abstraction is heavenly

If you know that you are going to use something over and over again. Abstract it out. Do not copy-paste. Copy-paste is only your friend when it involves magic numbers, or other magic data that needs to be read by your application. That magic data should never be an uncommented part of your code (except maybe a very few set of strings).

Everyone thinks they know, but very few people know what Agile/SCRUM really is

When management is running it, then it’s not Agile nor SCRUM. When developers or testers are running it, then it’s not Agile nor SCRUM. If you spend 4 out of 5 days in meetings, then it’s not Agile, nor SCRUM. However, if you aren’t talking to each other, then it’s DEFINITELY not Agile, nor SCRUM. In most cases, you’d be better off without a system then with a half-@$$ed or poorly run version.

The purpose of senior engineers is to teach, not to spend all their time programming

Great, so you’re a senior engineer. You get paid more for what you do. You may think that means that you can still sit in your corner and take the fun and challenging tasks away from the juniors. The reason they gave you the position was so that you’d bring others to your level, not so you can hunker down in your cubicle-hole and do whatever you want.

Hoarding knowledge is a good way to get fired, instead of protecting your job

Yes, you think that you are protecting your job. You aren’t. There are experts everywhere that can do what you do, and they can hire those experts instead of you. You’d be amazed what the people with “lesser job titles” can do if you put them in the position that they had to do it. “Going Galt” will not show them how important you are to them.

You can talk about innovation all day, but you show you’re serious through your budget

This one is definitely for the managers out there. If you want a product that looks good, you have to put enough people on it. If you want it maintained, you have to keep people on it. Guess what??? You may have to rotate them out to other projects, because no one wants to sit there and do the same thing their whole lives.

If you are saying that you are all about innovation, but you don’t put any effort into preparing the development, then you aren’t actually interested in innovation.

You will never have enough time to finish

This one is for the developers. Since you are a developer, let me see if I can word this in an elitist, rigorous, techie-sounding kind of way: Development is an exercise with a utilitarian measure that, once reached, is sufficient for release. There is a concept called satisficing (Satisficing - Wikipedia). Look it up. Understand it. It does not mean that you can goof off and it will be “good enough”. It means that you will never get it perfect enough, and still make deadlines and budgets. Try for satisficing instead. THAT my friends, is what the product backlog and prioritization is really for.

You and your product owner are both responsible for defining the measure for satisficing. If you (all) don’t agree, you (all) fail. If you (all) don’t meet it, you (all) fail. You (all) are a team, act like one.

The relationship with your coworkers is more important than money or benefits

That is, unless you don’t plan on doing software development for long. Yes, you must have enough to live on, but if you push too hard and alienate people, working in a toxic environment is worse than working for an average developer salary. If you plan to become a manager, and you are going to do it quickly and aggressively, then you better plan to work somewhere else once you get that position.

It is most likely that you will not earn what you believe you are worth in your lifetime

You are trying to make money. Your company is trying to make money. If you don’t have enough money to be your own company, then you will likely not make what you think you should. They want to control costs, and globalization has shown that until everyone, all over the globe is charging reasonably close to the same for what you do, then offshoring will continue to happen. This one is kind of tough luck based on current world-based economic state of being. You were born at the wrong time. In the past, if you were good, then you would get paid for it. However, right this minute, the quality-payout metric is not favoring software engineers.

In the future, if you are good, you will get paid for it again, but likely everyone will be specialized. It’s probably going to be the case that everyone and their dog can and will program in the future. The difference will be what you are capable of doing. Most people will probably be able to talk to a Siri-like voice and command the equivalent of automation scripts through AI (what we have to “program” nowadays). Most people will also probably be able to understand rudimentary mathematics through software in about 30 years or so. However, few will be using their skills to innovate. Those skills are going to look more like advanced mathematics than the programming that you and I do nowadays on a daily basis.

Guess what?? What you are experiencing right now is the same all over the globe, for all kinds of jobs. Software engineers are not in a unique situation, except that we can still find some work where others are permanently losing their jobs. I’m not going to speak to what may or may not be “good” or “right” about the situation, because that’s not the purpose of this question.|||

