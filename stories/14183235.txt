This kind of UI can be built using Custom UIViewController Transitions, , and . First create a subclass. This will: Transform the presenting view controller to inset it from the status bar Set the frame of the presented view to make the card effect import UIKit class PresentationController: UIPresentationController { private let dimmingView: UIView = { let dimmingView = UIView() dimmingView.backgroundColor = UIColor(white: 0, alpha: 0.5) dimmingView.alpha = 0 return dimmingView }() // MARK: UIPresentationController override func presentationTransitionWillBegin() { guard let containerView = containerView, let presentedView = presentedView else { return } dimmingView.frame = containerView.bounds containerView.addSubview(dimmingView) containerView.addSubview(presentedView) guard let transitionCoordinator = presentingViewController.transitionCoordinator else { return } transitionCoordinator.animateAlongsideTransition(in: presentingViewController.view, animation: { _ in self.presentingViewController.view.transform = CGAffineTransform(scaleX: 0.94, y: 0.94) if !transitionCoordinator.isInteractive { (self.presentingViewController as? ViewController)?.statusBarStyle = .lightContent } }) transitionCoordinator.animate(alongsideTransition: { _ in self.dimmingView.alpha = 1.0 }) } override func presentationTransitionDidEnd(_ completed: Bool) { if !completed { dimmingView.removeFromSuperview() } if completed { (presentingViewController as? ViewController)?.statusBarStyle = .lightContent } } override func dismissalTransitionWillBegin() { guard let transitionCoordinator = presentingViewController.transitionCoordinator else { return } transitionCoordinator.animate(alongsideTransition: { _ in self.dimmingView.alpha = 0 }) transitionCoordinator.animateAlongsideTransition(in: presentingViewController.view, animation: { _ in self.presentingViewController.view.transform = CGAffineTransform.identity if !transitionCoordinator.isInteractive { (self.presentingViewController as? ViewController)?.statusBarStyle = .default } }) } override func dismissalTransitionDidEnd(_ completed: Bool) { guard let transitionCoordinator = presentingViewController.transitionCoordinator else { return } if transitionCoordinator.isCancelled { return } if completed { dimmingView.removeFromSuperview() (presentingViewController as? ViewController)?.statusBarStyle = .default } } override var frameOfPresentedViewInContainerView: CGRect { guard let containerView = containerView else { return .zero } var frame = containerView.bounds frame.size.height -= 40 frame.origin.y += 40 return frame } // MARK: UIViewController override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) { super.viewWillTransition(to: size, with: coordinator) guard let containerView = containerView else { return } coordinator.animate(alongsideTransition: { _ in self.dimmingView.frame = containerView.bounds }) } } Next we need an object that will do the animation between the two screens: import UIKit class AnimationController: NSObject, UIViewControllerAnimatedTransitioning { enum Direction { case present case dismiss } private let direction: Direction init(direction: Direction) { self.direction = direction super.init() } func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval { return 0.3 } func animateTransition(using transitionContext: UIViewControllerContextTransitioning) { let animator = interruptibleAnimator(using: transitionContext) animator.startAnimation() } func interruptibleAnimator(using transitionContext: UIViewControllerContextTransitioning) -> UIViewImplicitlyAnimating { let duration = transitionDuration(using: transitionContext) let animator = UIViewPropertyAnimator(duration: duration, curve: .linear) let containerView = transitionContext.containerView let containerFrame = containerView.frame switch direction { case .present: guard let toViewController = transitionContext.viewController(forKey: .to), let toView = transitionContext.view(forKey: .to) else { fatalError() } var toViewStartFrame = transitionContext.initialFrame(for: toViewController) let toViewFinalFrame = transitionContext.finalFrame(for: toViewController) toViewStartFrame = toViewFinalFrame toViewStartFrame.origin.y = containerFrame.size.height - 44 toView.frame = toViewStartFrame animator.addAnimations { toView.frame = toViewFinalFrame } case .dismiss: guard let fromViewController = transitionContext.viewController(forKey: .from), let fromView = transitionContext.view(forKey: .from) else { fatalError() } var fromViewFinalFrame = transitionContext.finalFrame(for: fromViewController) fromViewFinalFrame.origin.y = containerFrame.size.height - 44 animator.addAnimations { fromView.frame = fromViewFinalFrame } } animator.addCompletion { finish in if finish == .end { transitionContext.finishInteractiveTransition() transitionContext.completeTransition(true) } else { transitionContext.cancelInteractiveTransition() transitionContext.completeTransition(false) } } return animator } } Finally hook it all together in the view controller, adding gesture recognizers to control the interactive transition. import UIKit class ViewController: UIViewController, UIViewControllerTransitioningDelegate { var statusBarStyle: UIStatusBarStyle = .default { didSet { setNeedsStatusBarAppearanceUpdate() } } override var preferredStatusBarStyle: UIStatusBarStyle { return statusBarStyle } private var interactionController: UIPercentDrivenInteractiveTransition? override func viewDidLoad() { super.viewDidLoad() view.backgroundColor = .white let cardView = UIView(frame: .zero) cardView.translatesAutoresizingMaskIntoConstraints = false cardView.backgroundColor = UIColor(red:0.976, green:0.976, blue:0.976, alpha:1) view.addSubview(cardView) let borderView = UIView(frame: .zero) borderView.translatesAutoresizingMaskIntoConstraints = false borderView.backgroundColor = UIColor(red:0.697, green:0.698, blue:0.697, alpha:1) view.addSubview(borderView) let cardViewTextLabel = UILabel(frame: .zero) cardViewTextLabel.translatesAutoresizingMaskIntoConstraints = false cardViewTextLabel.text = "Tap or drag" cardViewTextLabel.font = UIFont.boldSystemFont(ofSize: 16) view.addSubview(cardViewTextLabel) let cardViewConstraints = [ cardView.heightAnchor.constraint(equalToConstant: 44), cardView.leadingAnchor.constraint(equalTo: view.leadingAnchor), cardView.trailingAnchor.constraint(equalTo: view.trailingAnchor), cardView.bottomAnchor.constraint(equalTo: view.bottomAnchor), borderView.heightAnchor.constraint(equalToConstant: 0.5), borderView.topAnchor.constraint(equalTo: cardView.topAnchor), borderView.leadingAnchor.constraint(equalTo: cardView.leadingAnchor), borderView.trailingAnchor.constraint(equalTo: cardView.trailingAnchor), cardViewTextLabel.centerXAnchor.constraint(equalTo: cardView.centerXAnchor), cardViewTextLabel.centerYAnchor.constraint(equalTo: cardView.centerYAnchor) ] NSLayoutConstraint.activate(cardViewConstraints) let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(handlePresentTapGesture(gestureRecognizer:))) cardView.addGestureRecognizer(tapGestureRecognizer) let panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(handlePresentPanGesture(gestureRecognizer:))) cardView.addGestureRecognizer(panGestureRecognizer) } // MARK: Actions @objc private func handlePresentTapGesture(gestureRecognizer: UITapGestureRecognizer) { let viewController = createViewController() present(viewController, animated: true, completion: nil) } @objc private func handlePresentPanGesture(gestureRecognizer: UIPanGestureRecognizer) { let translation = gestureRecognizer.translation(in: gestureRecognizer.view?.superview) let height = (gestureRecognizer.view?.superview?.bounds.height)! - 40 let percentage = abs(translation.y / height) switch gestureRecognizer.state { case .began: interactionController = UIPercentDrivenInteractiveTransition() let viewController = createViewController() present(viewController, animated: true, completion: nil) case .changed: interactionController?.update(percentage) case .ended: if percentage < 0.5 { interactionController?.cancel() } else { interactionController?.finish() } interactionController = nil default: break } } @objc private func handleDismissTapGesture(gestureRecognizer: UITapGestureRecognizer) { dismiss(animated: true, completion: nil) } @objc private func handleDismissPanGesture(gestureRecognizer: UIPanGestureRecognizer) { let translation = gestureRecognizer.translation(in: gestureRecognizer.view) let height = (gestureRecognizer.view?.bounds.height)! let percentage = (translation.y / height) switch gestureRecognizer.state { case .began: interactionController = UIPercentDrivenInteractiveTransition() dismiss(animated: true, completion: nil) case .changed: interactionController?.update(percentage) case .ended: if percentage < 0.5 { interactionController?.cancel() } else { interactionController?.finish() } interactionController = nil default: break } } // MARK: UIViewControllerTransitioningDelegate func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -> UIPresentationController? { return PresentationController(presentedViewController: presented, presenting: presenting) } func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? { // Get UIKit to animate if it's not an interative animation return interactionController != nil ? AnimationController(direction: .present) : nil } func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? { // Get UIKit to animate if it's not an interative animation return interactionController != nil ? AnimationController(direction: .dismiss) : nil } func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? { return interactionController } func interactionControllerForDismissal(using animator: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? { return interactionController } // MARK: Private func createViewController() -> UIViewController { let viewController = UIViewController(nibName: nil, bundle: nil) viewController.title = "Tap or drag" viewController.view.backgroundColor = .white let navigationController = UINavigationController(rootViewController: viewController) navigationController.transitioningDelegate = self navigationController.modalPresentationStyle = .custom UINavigationBar.appearance().titleTextAttributes = [NSFontAttributeName: UIFont.boldSystemFont(ofSize: 16)] let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(handleDismissTapGesture(gestureRecognizer:))) navigationController.view.addGestureRecognizer(tapGestureRecognizer) let panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(handleDismissPanGesture(gestureRecognizer:))) navigationController.view.addGestureRecognizer(panGestureRecognizer) return navigationController } }|||

