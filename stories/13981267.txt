Clang Thread Safety Analysis is a C++ language extension which warns about potential race conditions in code. The analysis is completely static (i.e. compile-time); there is no run-time overhead. The analysis is still under active development, but it is mature enough to be deployed in an industrial setting. It is being developed by Google, in collaboration with CERT/SEI, and is used extensively in Google’s internal code base. Thread safety analysis works very much like a type system for multi-threaded programs. In addition to declaring the type of data (e.g. , , etc.), the programmer can (optionally) declare how access to that data is controlled in a multi-threaded environment. For example, if is guarded by the mutex , then the analysis will issue a warning whenever a piece of code reads or writes to without first locking . Similarly, if there are particular routines that should only be called by the GUI thread, then the analysis will warn if other threads call those routines. // OK. Caller must have locked mu. // OK. depositImpl() has no requirements. This example demonstrates the basic concepts behind the analysis. The attribute declares that a thread must lock before it can read or write to , thus ensuring that the increment and decrement operations are atomic. Similarly, declares that the calling thread must lock before calling . Because the caller is assumed to have locked , it is safe to modify within the body of the method. The method does not have , so the analysis issues a warning. Thread safety analysis is not inter-procedural, so caller requirements must be explicitly declared. There is also a warning in , because although the method locks , it does not lock . The analysis understands that these are two separate mutexes, in two different objects. Finally, there is a warning in the method, because it fails to unlock . Every lock must have a corresponding unlock, and the analysis will detect both double locks, and double unlocks. A function is allowed to acquire a lock without releasing it, (or vice versa), but it must be annotated as such (using / ). To run the analysis, simply compile with the flag, e.g. Note that this example assumes the presence of a suitably annotated mutex.h that declares which methods perform locking, unlocking, and so on.

Thread safety analysis provides a way of protecting resources with capabilities. A resource is either a data member, or a function/method that provides access to some underlying resource. The analysis ensures that the calling thread cannot access the resource (i.e. call the function, or read/write the data) unless it has the capability to do so. Capabilities are associated with named C++ objects which declare specific methods to acquire and release the capability. The name of the object serves to identify the capability. The most common example is a mutex. For example, if is a mutex, then calling causes the calling thread to acquire the capability to access data that is protected by . Similarly, calling releases that capability. A thread may hold a capability either exclusively or shared. An exclusive capability can be held by only one thread at a time, while a shared capability can be held by many threads at the same time. This mechanism enforces a multiple-reader, single-writer pattern. Write operations to protected data require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of capabilities (e.g. the set of mutexes that it has locked.) These act like keys or tokens that allow the thread to access a given resource. Just like physical security keys, a thread cannot make copy of a capability, nor can it destroy one. A thread can only release a capability to another thread, or acquire one from another thread. The annotations are deliberately agnostic about the exact mechanism used to acquire and release capabilities; it assumes that the underlying implementation (e.g. the Mutex implementation) does the handoff in an appropriate manner. The set of capabilities that are actually held by a given thread at a given point in program execution is a run-time concept. The static analysis works by calculating an approximation of that set, called the capability environment. The capability environment is calculated for every program point, and describes the set of capabilities that are statically known to be held, or not held, at that particular point. This environment is a conservative approximation of the full set of capabilities that will actually held by a thread at run-time.

The thread safety analysis uses attributes to declare threading constraints. Attributes must be attached to named declarations, such as classes, methods, and data members. Users are strongly advised to define macros for the various attributes; example definitions can be found in mutex.h, below. The following documentation assumes the use of macros. For historical reasons, prior versions of thread safety used macro names that were very lock-centric. These macros have since been renamed to fit a more general capability model. The prior names are still in use, and will be mentioned under the tag previously where appropriate. is an attribute on data members, which declares that the data member is protected by the given capability. Read operations on the data require shared access, while write operations require exclusive access. is similar, but is intended for use on pointers and smart pointers. There is no constraint on the data member itself, but the data that it points to is protected by the given capability. is an attribute on functions or methods, which declares that the calling thread must have exclusive access to the given capabilities. More than one capability may be specified. The capabilities must be held on entry to the function, and must still be held on exit. is similar, but requires only shared access. is an attribute on functions or methods, which declares that the function acquires a capability, but does not release it. The caller must not hold the given capability on entry, and it will hold the capability on exit. is similar. and declare that the function releases the given capability. The caller must hold the capability on entry, and will no longer hold it on exit. It does not matter whether the given capability is shared or exclusive. If no argument is passed to or , then the argument is assumed to be , and the analysis will not check the body of the function. This pattern is intended for use by classes which hide locking details behind an abstract interface. For example: is an attribute on functions or methods, which declares that the caller must not hold the given capabilities. This annotation is used to prevent deadlock. Many mutex implementations are not re-entrant, so deadlock can occur if the function acquires the mutex a second time. Unlike , is optional. The analysis will not issue a warning if the attribute is missing, which can lead to false negatives in some cases. This issue is discussed further in Negative Capabilities. is an attribute on functions or methods, which turns off thread safety checking for that method. It provides an escape hatch for functions which are either (1) deliberately thread-unsafe, or (2) are thread-safe, but too complicated for the analysis to understand. Reasons for (2) will be described in the Known Limitations, below. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the interface of a function, and should thus be placed on the function definition (in the or file) rather than on the function declaration (in the header). is an attribute on functions or methods, which declares that the function returns a reference to the given capability. It is used to annotate getter methods that return mutexes. and are attributes on member declarations, specifically declarations of mutexes or other capabilities. These declarations enforce a particular order in which the mutexes must be acquired, in order to prevent deadlock. // Warning! m2 must be acquired after m1. is an attribute on classes, which specifies that objects of the class can be used as a capability. The string argument specifies the kind of capability in error messages, e.g. . See the example given above, or the class in mutex.h. is an attribute on classes that implement RAII-style locking, in which a capability is acquired in the constructor, and released in the destructor. Such classes require special handling because the constructor and destructor refer to the capability via different names; see the class in mutex.h, below. These are attributes on a function or method that tries to acquire the given capability, and returns a boolean value indicating success or failure. The first argument must be or , to specify which return value indicates success, and the remaining arguments are interpreted in the same way as . See mutex.h, below, for example uses. These are attributes on a function or method that does a run-time test to see whether the calling thread holds the given capability. The function is assumed to fail (no return) if the capability is not held. See mutex.h, below, for example uses. Use of these attributes has been deprecated. : Umbrella flag which turns on the following three: This warning can be disabled for code which has a lot of aliases. : Checks when guarded members are passed by reference. Negative Capabilities are an experimental feature, which are enabled with: When new features and checks are added to the analysis, they can often introduce additional warnings. Those warnings are initially released as beta warnings for a period of time, after which they are migrated into the standard analysis. : New features. Off by default.

Thread Safety Analysis is designed to prevent both race conditions and deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by ensuring that a capability is held before reading or writing to guarded data, and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is not held. However, EXCLUDES is an optional attribute, and does not provide the same safety guarantee as REQUIRES. In particular: A function which acquires a capability does not have to exclude it. A function which calls a function that excludes a capability does not have transitively exclude that capability. // No warning. (Should have EXCLUDES(mu)). // No warning. (Should have EXCLUDES(mu)). Negative requirements are an alternative EXCLUDES that provide a stronger safety guarantee. A negative requirement uses the REQUIRES attribute, in conjunction with the operator, to indicate that a capability should not be held. For example, using instead of will produce the appropriate warnings: Negative requirements are an experimental feature which is off by default, because it will produce many warnings in existing code. It can be enabled by passing .

Should I put attributes in the header file, or in the .cc/.cpp/.cxx file? (A) Attributes are part of the formal interface of a function, and should always go in the header, where they are visible to anything that includes the header. Attributes in the .cpp file are not visible outside of the immediate translation unit, which leads to false negatives and false positives. “Mutex is not locked on every path through here?” What does that mean?

Thread safety attributes contain ordinary C++ expressions, and thus follow ordinary C++ scoping rules. In particular, this means that mutexes and other capabilities must be declared before they can be used in an attribute. Use-before-declaration is okay within a single class, because attributes are parsed at the same time as method bodies. (C++ delays parsing of method bodies until the end of the class.) However, use-before-declaration is not allowed between classes, as illustrated below. Good software engineering practice dictates that mutexes should be private members, because the locking mechanism used by a thread-safe class is part of its internal implementation. However, private mutexes can sometimes leak into the public interface of a class. Thread safety attributes follow normal C++ access restrictions, so if is a private member of , then it is an error to write in an attribute. One workaround is to (ab)use the attribute to provide a public name for a private mutex, without actually exposing the underlying mutex. For example: // For thread safety analysis only. Does not actually return mu. In the above example, is an external routine that requires to be locked, which cannot be declared directly because is private. This pattern is discouraged because it violates encapsulation, but it is sometimes necessary, especially when adding annotations to an existing code base. The workaround is to define as a fake getter method, which is provided only for the benefit of thread safety analysis. The analysis must be able to determine whether a lock is held, or not held, at every program point. Thus, sections of code where a lock might be held will generate spurious warnings (false positives). For example: // Warning! Mutex 'mu' is not held on every path through here. The analysis currently does not do any checking inside constructors or destructors. In other words, every constructor and destructor is treated as if it was annotated with . The reason for this is that during initialization, only one thread typically has access to the object which is being initialized, and it is thus safe (and common practice) to initialize guarded members without acquiring any locks. The same is true of destructors. Ideally, the analysis would allow initialization of guarded members inside the object being initialized or destroyed, while still enforcing the usual access restrictions on everything else. However, this is difficult to enforce in practice, because in complex pointer-based data structures, it is hard to determine what data is owned by the enclosing object. Thread safety analysis is strictly intra-procedural, just like ordinary type checking. It relies only on the declared attributes of a function, and will not attempt to inline any method calls. As a result, code such as the following will not work: In this case, the destructor of calls , so the warning is bogus. However, thread safety analysis cannot see the unlock, because it does not attempt to inline the destructor. Moreover, there is no way to annotate the destructor, because the destructor is calling a function that is not statically known. This pattern is simply not supported. The analysis currently does not track pointer aliases. Thus, there can be false positives if two pointers both point to the same mutex. The MutexUnlocker class is intended to be the dual of the MutexLocker class, defined in mutex.h. However, it doesn’t work because the analysis doesn’t know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.¶ To be fixed in a future update.

Thread safety analysis can be used with any threading library, but it does require that the threading API be wrapped in classes and methods which have the appropriate annotations. The following code provides as an example; these methods should be filled in to call the appropriate underlying implementation. // The attributes can be safely erased when compiling with other compilers. // These methods can be implemented to use any internal mutex implementation. // Acquire/lock this mutex exclusively. Only one thread can have exclusive // access at any one time. Write operations to guarded data require an // Acquire/lock this mutex for read operations, which require only a shared // threads may acquire the mutex simultaneously as readers, but a writer // must wait for all of them to release the mutex before it can acquire it // Try to acquire the mutex. Returns true on success, and false on failure. // Try to acquire the mutex for read operations. // Assert that this mutex is currently held by the calling thread. // Assert that is mutex is currently held for read operations. // MutexLocker is an RAII class that acquires a mutex in its constructor, and // releases it in its destructor. // The original version of thread safety analysis the following attribute // definitions. These use a lock-based terminology. They are still in use // by existing thread safety code, and will continue to be supported.|||

