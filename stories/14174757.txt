In this article from the Design & Architecture Series, I am going to explain how to build a flexible way of configuring the current execution engine and browser. I am going to utilize the power of the Observer Design Pattern, C# reflection and attributes.

As pointed at the beginning of the post I am going to used the Observer Design Pattern in the implementation of the dynamic configuration of the test framework's engine. I suggest reading the whole article about it to understand the current solution thoroughly.

If you read my articles dedicated to the Observer Design Pattern, you know that you can utilize it in many ways so that your test framework can benefit. Because of that, I created a separate project where the additional extendable logic will be placed.

The main way of changing the execution engine and its browser will be through the ExecutionEngineAttribute. It holds properties to the type of the execution engine (WebDriver or Testing Framework) and the browser type. You can place it on a class level or change the engine only for a particular test method.

The heart of the engine's configuration logic is the ExecutionEngineBehaviourObserver. Here on PreTestInit, the current driver is resolved.  Through the method GetExecutionEngineType, we get the engine configuration specified in the class body. We pass the MethodInfo instance through the event arguments. Two other separate private methods extract the ExecutionEngineAttributes values from the class attribute or test method attributes. The same logic is applied for the browser through the ConfigureTestExecutionBrowser method.

The ResolveAllDriverDependencies is the most prominent member of the ExecutionEngineBehaviourObserver class. Inside is happening all of the magic. This code is going to be executed again and again for every test in its PreTestInit phase. Based on the type of the currently configured execution engine we override the type registrations of the driver's engine in the Unity container. First, we register as a type the IDriver interface. The interesting part is that we need to use the Unity InjectionFactory to configure it. When we resolve the IDriver interface, this factory will be executed. We need this because the TestingFrameworkDriver's constructor requires two parameters which cannot be passed using the default syntax. After that, we override the type registrations for all controls' interfaces so that they will be resolved for the correct engine- in this case for the TestingFrameworkDriver. At the end of the method, we register as instances all driver's interfaces. The next time when we try to resolve one of them, the instance passed to the RegisterInstance method will be returned. If we skip this part, every time you resolve some of these interfaces, a separate browser will be created.

This will be the base class for all of our tests. In the InitializeTestExecutionBehaviourObservers method, we subscribe the execution engine behaviour to the main MSTestExecutionProvider. This way when the CoreTestInit method is called before our tests, the PreTestInit logic of the TestExecutionBehaviourObserver will be executed. After the run of all PreTestInit methods, we resolve the IDriver so that we can pass its instance to the main test class through the Driver property.

There are two things that you need to do to use the new execution engine's configuration logic. First, your test class need to derive from the previously introduced BaseTest class. Secondly, you need to setup the ExecutionEngineAttribute. You can pass to its constructor the desired values for the execution engine's type and browser.|||

Build a Hybrid Test Automation Framework. Learn how to switch between execution engines and browsers through attributes and Observer Design Pattern.