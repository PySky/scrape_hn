The first principle of d3.express is reactivity. Rather than issuing commands to modify shared state, each piece of state in a reactive program defines how it is calculated, and the runtime manages their evaluation; the runtime propagates derived state. If you’ve written spreadsheet formulas, you’ve done reactive programming. Here’s a simple notebook in d3.express to illustrate reactive programming. It looks a bit like the browser’s developer console, except here our work is saved automatically so that we can revisit it in the future or share it with others. And it’s reactive.

In imperative programming, sets the current value of to . This is a value assignment. If or changes, retains its original value until we execute a new value assignment to . In reactive programming, is a variable definition. This means that is always equal to , even if or changes. The runtime keeps the value of up-to-date. As programmers, we now care only about the current state. The runtime manages state changes. That may seem like a small thing here, but in larger programs this eliminates a substantial burden. A discovery environment needs to do more than add a few numbers, so let’s try working with data. To load the data — a few years of Apple stock price — we’ll use d3.csv. This uses the Fetch API to download a file from GitHub, and then parses it to return an array of objects.

Oops! It throws an error. But the error is both local and temporary: other cells are unaffected, and the error will disappear when we define . Thus notebooks in d3.express are not only reactive, they are structured. Global errors no longer exist. Upon defining , we again see the effect: the data is reloaded, parsed and displayed. We are still manipulating abstract symbols, but we are at least doing so less blindly.

And this reveals another human-friendly feature: cells can be written in any order. The cell can appear after cells that reference it because the runtime maintains a directed acyclic graph of references and evaluates the graph in topological order. Like the developer console, the result of evaluating a cell in d3.express is visible immediately beneath the code. But unlike the console, cells in d3.express can output graphical user interfaces! So let’s visualize our data as a simple line chart. First we define the chart size: width, height, and margin.

This is a basic chart, but already the program’s topology is becoming more complex. Here is its directed acyclic graph of references, itself made in d3.express using GraphViz: The numbered node 93 is the SVG element. A few observations. It’s now trivial to make this chart responsive. The , and are constants, but if they were dynamic, the scales and the chart would update automatically. Likewise, it’s trivial to turn this into a dynamic chart by redefining ; we’ll see that in action with streaming data shortly. But let’s look more closely at the reactive code. In imperative programming, a variable definition tends to be sprinkled throughout the code rather than in one place. For example, we might construct the x-scale on page load but defer setting its domain until the data loads. This fragmented definition could be interspersed with unrelated code, impeding readability. In reactive programming, we can localize the definition and let the runtime manage execution order: Reactivity is thus not just a time-saving convenience; it results in cleaner code. This also improves reusability: self-contained, stateless definitions are easier to copy-and-paste or import into other documents. Also, you don’t have to use D3; despite the name, nothing in d3.express requires it. You can create whatever DOM — HTML, canvas, WebGL — using whatever libraries you want. Here’s the chart in Vega Lite:

Thus by adding a little complexity you can improve performance, and the resulting animation has negligible overhead compared to vanilla JavaScript. If generators are good for scripted animations, what about interaction? Generators again to the rescue! Only now our generators are asynchronous, yielding a promise that resolves whenever there is new input. To make the rotation interactive, let’s first define a range input. Then we connect it to a generator that yields the current value of the input whenever it changes. We could implement this generator by hand, but there’s a built-in convenience method called .

This uses the default object inspector, but you can drive anything interactively, say live summaries, live statistics, or even linked visualizations. To show this isn’t magic, above is the code to adapt d3-brush to d3.express. When there’s a brush event, we compute the new filtered selection of data, set it as the SVG node’s value, and dispatch an input event. By default, reactions are instantaneous: when a variable’s value changes, the runtime recomputes derived variables and updates the display immediately. But immediacy is not required and it is sometimes useful to animate transitions for object constancy. Here, for example, we can follow the bars as they are reordered:|||

If you’ve ever gotten frustrated trying to figure out why your code doesn’t work, or how someone else’s code works, you are not alone. This is for you. For the last eight years or so, I have been…